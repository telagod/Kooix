import "../stdlib/prelude";
import "../stage1/lexer";
import "../stage1/parser";
import "../stage1/ast";

fn main() -> Int {
  let src: Text = "record Box<T: Answer + Summary> { value: T; };";
  let tr: Result<List<S1Token>, S1Diagnostic> = s1_lex(src);
  match tr {
    Err(_e) => 1;
    Ok(ts) => {
      let pr: Result<S1Program, S1Diagnostic> = s1_parse(ts);
      match pr {
        Err(_e2) => 2;
        Ok(p) => {
          match p.items {
            Cons(i0) => {
              match i0.head {
                Record(r) => {
                  if r.name == "Box" {
                    match r.generics {
                      Cons(g0) => {
                        if g0.head.name == "T" {
                          match g0.head.bounds {
                            Cons(b0) => {
                              match b0.head.path.segments {
                                Cons(s0) => {
                                  if s0.head == "Answer" {
                                    match s0.tail {
                                      Nil => {
                                        match b0.head.args {
                                          Nil => {
                                            match b0.tail {
                                              Cons(b1) => {
                                                match b1.head.path.segments {
                                                  Cons(s1) => {
                                                    if s1.head == "Summary" {
                                                      match s1.tail {
                                                        Nil => {
                                                          match b1.head.args {
                                            Nil => {
                                              match b1.tail {
                                                Nil => {
                                                  match r.fields {
                                                    Cons(f0) => {
                                                      if f0.head.name == "value" {
                                                        match f0.head.ty.path.segments {
                                                          Cons(t0) => {
                                                            if t0.head == "T" {
                                                              match t0.tail {
                                                                Nil => {
                                                                  match f0.head.ty.args {
                                                                    Nil => 0;
                                                                    _ => 40;
                                                                  }
                                                                };
                                                                _ => 41;
                                                              }
                                                            } else { 39 }
                                                          };
                                                          _ => 39;
                                                        }
                                                      } else { 38 }
                                                    };
                                                    _ => 37;
                                                  }
                                                };
                                                _ => 36;
                                              }
                                            };
                                            _ => 35;
                                                          }
                                                        };
                                                        _ => 42;
                                                      }
                                                    } else { 34 }
                                                  };
                                                  _ => 33;
                                                }
                                              };
                                              _ => 33;
                                            }
                                          };
                                          _ => 32;
                                        }
                                      };
                                      _ => 43;
                                    }
                                  } else { 31 }
                                };
                                _ => 30;
                              }
                            };
                            _ => 30;
                          }
                        } else { 29 }
                      };
                      _ => 28;
                    }
                  } else { 27 }
                };
                _ => 26;
              }
            };
            _ => 25;
          }
        };
      }
    };
  }
};
