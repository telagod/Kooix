(*
  Kooix Grammar (Implemented MVP)
  Scope: matches the current parser implementation in crates/kooixc.
*)

Program           = { Item } EOF ;

Item              = CapabilityDecl
                  | ImportDecl
                  | RecordDecl
                  | EnumDecl
                  | FunctionDecl
                  | WorkflowDecl
                  | AgentDecl
                  ;

CapabilityDecl    = "cap" TypeRef ";" ;

ImportDecl        = "import" StringLiteral ";" ;

(* ---------- Records ---------- *)

RecordDecl         = "record" Identifier [ GenericParams ] [ WhereClause ] "{"
                     { RecordField }
                     "}" ";"
                   ;

GenericParams      = "<" GenericParam { "," GenericParam } ">" ;

GenericParam       = Identifier [ ":" TypeBoundList ] ;

TypeBoundList      = TypeRef { "+" TypeRef } ;

WhereClause        = "where" WhereConstraint { "," WhereConstraint } ;

WhereConstraint    = Identifier ":" TypeBoundList ;

RecordField        = Identifier ":" TypeRef ";" ;

(* ---------- Enums ---------- *)

EnumDecl           = "enum" Identifier [ GenericParams ] [ WhereClause ] "{"
                     { EnumVariant }
                     "}" ";"
                   ;

EnumVariant        = Identifier [ "(" TypeRef ")" ] ";" ;

(* ---------- Functions ---------- *)

FunctionDecl       = "fn" Identifier "(" [ ParamList ] ")"
                     "->" TypeRef
                     [ Intent ]
                     [ Effects ]
                     [ Requires ]
                     [ Ensures ]
                     [ Failure ]
                     [ Evidence ]
                     [ Block ]
                     ";"
                   ;

ParamList         = Param { "," Param } ;

Param             = Identifier ":" TypeRef ;

Intent            = "intent" StringLiteral ;

Effects           = "!" "{" [ EffectSpec { "," EffectSpec } ] "}" ;

EffectSpec        = Identifier [ "(" EffectArg ")" ] ;

EffectArg         = Identifier
                  | StringLiteral
                  | NumberLiteral
                  ;

Requires          = "requires" "[" [ TypeRef { "," TypeRef } ] "]" ;

Ensures           = "ensures" "[" [ EnsureClause { "," EnsureClause } ] "]" ;

EnsureClause      = PredicateValue CompareOp PredicateValue ;

PredicateValue    = SymbolPath
                  | StringLiteral
                  | NumberLiteral
                  ;

CompareOp         = "==" | "!=" | "<" | "<=" | ">" | ">=" | "in" ;

Failure           = "failure" "{" { FailureRule } "}" ;

FailureRule       = Identifier "->" FailureAction ";" ;

FailureAction     = Identifier "(" [ FailureActionArg { "," FailureActionArg } ] ")" ;

FailureActionArg  = [ Identifier "=" ] FailureValue ;

FailureValue      = Identifier | StringLiteral | NumberLiteral ;

Evidence          = "evidence" "{"
                   { EvidenceClause }
                   "}"
                  ;

EvidenceClause    = TraceClause | MetricsClause ;

TraceClause       = "trace" StringLiteral ";" ;

MetricsClause     = "metrics" "[" [ Identifier { "," Identifier } ] "]" ";" ;

(* ---------- Workflows ---------- *)

WorkflowDecl       = "workflow" Identifier "(" [ ParamList ] ")"
                     "->" TypeRef
                     [ Intent ]
                     [ Requires ]
                     Steps
                     [ OutputSpec ]
                     [ Evidence ]
                     ";"
                   ;

Steps              = "steps" "{"
                     { StepDecl }
                     "}"
                   ;

StepDecl           = Identifier ":" WorkflowCall
                     [ Ensures ]
                     [ OnFail ]
                     ";"
                   ;

OnFail             = "on_fail" "->" FailureAction ;

WorkflowCall       = Identifier "(" [ WorkflowCallArg { "," WorkflowCallArg } ] ")" ;

WorkflowCallArg    = SymbolPath | StringLiteral | NumberLiteral ;

OutputSpec         = "output" "{"
                     { OutputField }
                     "}"
                   ;

OutputField        = Identifier ":" TypeRef [ "=" SymbolPath ] ";" ;

(* ---------- Agents ---------- *)

AgentDecl          = "agent" Identifier "(" [ ParamList ] ")"
                     "->" TypeRef
                     [ Intent ]
                     StateSpec
                     PolicySpec
                     [ Requires ]
                     LoopSpec
                     [ Ensures ]
                     [ Evidence ]
                     ";"
                   ;

StateSpec          = "state" "{"
                     { StateRule }
                     "}"
                   ;

StateRule          = (Identifier | "any") "->" Identifier { "," Identifier } ";" ;

PolicySpec         = "policy" "{"
                     { PolicyRule }
                     "}"
                   ;

PolicyRule         = "allow_tools" "[" StringLiteral { "," StringLiteral } "]" ";"
                  |  "deny_tools" "[" StringLiteral { "," StringLiteral } "]" ";"
                  |  "max_iterations" "=" NumberLiteral ";"
                  |  "human_in_loop" "when" EnsureClause ";"
                  ;

LoopSpec           = "loop" "{"
                     Identifier { "->" Identifier } ";"
                     "stop" "when" EnsureClause ";"
                     "}"
                   ;

(* ---------- Function Body (Kooix-Core subset) ---------- *)

Block              = "{"
                     { Statement ";" }
                     [ Expr ]
                     "}"
                   ;

Statement          = LetStmt
                  |  AssignStmt
                  |  ReturnStmt
                  |  Expr
                  ;

LetStmt            = "let" Identifier [ ":" TypeRef ] "=" Expr ;

AssignStmt         = Identifier "=" Expr ;

ReturnStmt         = "return" [ Expr ] ;

Expr               = EqualityExpr ;

EqualityExpr       = AddExpr { ("==" | "!=") AddExpr } ;

AddExpr            = PrimaryExpr { "+" PrimaryExpr } ;

PrimaryExpr        = SymbolPath
                  |  RecordLiteral
                  |  IfExpr
                  |  WhileExpr
                  |  MatchExpr
                  |  CallExpr
                  |  NumberLiteral
                  |  StringLiteral
                  |  "true"
                  |  "false"
                  |  "(" Expr ")"
                  ;

RecordLiteral      = TypeRef "{"
                     { RecordLiteralField }
                     "}"
                   ;

RecordLiteralField = Identifier ":" Expr ";" ;

IfExpr             = "if" Expr Block [ "else" Block ] ;

WhileExpr          = "while" Expr Block ;

MatchExpr          = "match" Expr "{"
                     { MatchArm }
                     "}"
                   ;

MatchArm           = MatchPattern "=>" ( Block | Expr ) ";" ;

MatchPattern       = "_"
                  |  Identifier [ "(" Identifier ")" ]
                  ;

CallExpr           = Identifier "(" [ Expr { "," Expr } ] ")" ;

TypeRef           = Identifier [ "<" [ TypeArg { "," TypeArg } ] ">" ] ;

TypeArg           = TypeRef
                  | StringLiteral
                  | NumberLiteral
                  ;

Identifier        = Letter { Letter | Digit | "_" } ;

SymbolPath        = Identifier { "." Identifier } ;

StringLiteral     = '"' { Character - '"' | EscapedChar } '"' ;

NumberLiteral     = Digit { Digit } ;

EscapedChar       = "\\" ("\\" | '"' | "n" | "t") ;

Letter            = "A".."Z" | "a".."z" ;

Digit             = "0".."9" ;

EOF               = ? end of input ? ;
