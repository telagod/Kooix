import "../stdlib/prelude";
import "diag";
import "llvm_emit";

fn main() -> Int
intent "Stage1 compiler bootstrap: emit LLVM IR for entry file and write to disk (argv: [entry.kooix] [out.ll])"
evidence {
  trace "stage1.main.v0_13";
  metrics [stage1_main_calls];
}
{
  let argc: Int = host_argc();
  let entry_path: Text = "stage1/compiler_main.kooix";
  let out_path: Text = "/tmp/kooixc_stage3_stage1_compiler.ll";
  let ok_args: Bool = true;

  if argc == 1 {
    0
  } else {
    if argc == 2 {
      entry_path = host_argv(1);
      0
    } else {
      if argc == 3 {
        entry_path = host_argv(1);
        out_path = host_argv(2);
        0
      } else {
        ok_args = false;
        0
      }
    }
  };

  if ok_args == false {
    host_eprintln("usage: stage1-compiler [entry.kooix] [out.ll]");
    2
  } else {
    if entry_path == "--help" {
      host_eprintln("usage: stage1-compiler [entry.kooix] [out.ll]");
      0
    } else {
      if entry_path == "-h" {
        host_eprintln("usage: stage1-compiler [entry.kooix] [out.ll]");
        0
      } else {
        let src_r: Result<Text, Text> = host_load_source_map(entry_path);
        match src_r {
          Err(m) => {
            host_eprintln(m);
            2
          };
          Ok(src) => {
            let ir_r: Result<Text, S1Diagnostic> = s1_emit_llvm_ir(src);
            match ir_r {
              Err(e) => {
                host_eprintln(e.message);
                3
              };
              Ok(ir) => {
                let w: Result<Int, Text> = host_write_file(out_path, ir);
                match w {
                  Ok(_n) => 0;
                  Err(msg) => {
                    host_eprintln(msg);
                    4
                  };
                }
              };
            }
          };
        }
      }
    }
  }
};
