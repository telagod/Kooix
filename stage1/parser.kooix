import "../stdlib/prelude";
import "diag";
import "token";
import "ast";

fn s1_empty_path() -> S1Path {
  let ns: Option<Text> = None;
  S1Path { ns: ns; name: ""; }
};

fn s1_simple_path(name: Text) -> S1Path {
  let ns: Option<Text> = None;
  S1Path { ns: ns; name: name; }
};

fn s1_ns_path(ns_name: Text, name: Text) -> S1Path {
  let ns: Option<Text> = Some(ns_name);
  S1Path { ns: ns; name: name; }
};

fn s1_parse_path_tail(first: Text, rest: List<S1Token>) -> Pair<S1Path, List<S1Token>> {
  let path: S1Path = s1_simple_path(first);
  let cur: List<S1Token> = rest;

  match rest {
    Cons(c0) => {
      match c0.head.kind {
        Colon => {
          match c0.tail {
            Cons(c1) => {
              match c1.head.kind {
                Colon => {
                  match c1.tail {
                    Cons(c2) => {
                      match c2.head.kind {
                        Ident(name) => {
                          path = s1_ns_path(first, name);
                          cur = c2.tail;
                          0
                        };
                        _ => 0;
                      }
                    };
                    _ => 0;
                  };
                  0
                };
                _ => 0;
              }
            };
            _ => 0;
          };
          0
        };
        _ => 0;
      }
    };
    _ => 0;
  };

  Pair<S1Path, List<S1Token>> { a: path; b: cur; }
};

fn s1_reverse_items(xs: List<S1Item>) -> List<S1Item> {
  let acc: List<S1Item> = Nil;
  let cur: List<S1Item> = xs;
  let done: Bool = false;

  while done == false {
    match cur {
      Nil => {
        done = true;
        0
      };
      Cons(cell) => {
        acc = Cons(ListCons<S1Item> { head: cell.head; tail: acc; });
        cur = cell.tail;
        0
      };
    }
  };

  acc
};

fn s1_reverse_record_fields(xs: List<S1RecordField>) -> List<S1RecordField> {
  let acc: List<S1RecordField> = Nil;
  let cur: List<S1RecordField> = xs;
  let done: Bool = false;

  while done == false {
    match cur {
      Nil => {
        done = true;
        0
      };
      Cons(cell) => {
        acc = Cons(ListCons<S1RecordField> { head: cell.head; tail: acc; });
        cur = cell.tail;
        0
      };
    }
  };

  acc
};

fn s1_reverse_enum_variants(xs: List<S1EnumVariant>) -> List<S1EnumVariant> {
  let acc: List<S1EnumVariant> = Nil;
  let cur: List<S1EnumVariant> = xs;
  let done: Bool = false;

  while done == false {
    match cur {
      Nil => {
        done = true;
        0
      };
      Cons(cell) => {
        acc = Cons(ListCons<S1EnumVariant> { head: cell.head; tail: acc; });
        cur = cell.tail;
        0
      };
    }
  };

  acc
};

fn s1_reverse_generic_params(xs: List<S1GenericParam>) -> List<S1GenericParam> {
  let acc: List<S1GenericParam> = Nil;
  let cur: List<S1GenericParam> = xs;
  let done: Bool = false;

  while done == false {
    match cur {
      Nil => {
        done = true;
        0
      };
      Cons(cell) => {
        acc = Cons(ListCons<S1GenericParam> { head: cell.head; tail: acc; });
        cur = cell.tail;
        0
      };
    }
  };

  acc
};

fn s1_reverse_stmts(xs: List<S1Stmt>) -> List<S1Stmt> {
  let acc: List<S1Stmt> = Nil;
  let cur: List<S1Stmt> = xs;
  let done: Bool = false;

  while done == false {
    match cur {
      Nil => {
        done = true;
        0
      };
      Cons(cell) => {
        acc = Cons(ListCons<S1Stmt> { head: cell.head; tail: acc; });
        cur = cell.tail;
        0
      };
    }
  };

  acc
};

fn s1_reverse_exprs(xs: List<S1Expr>) -> List<S1Expr> {
  let acc: List<S1Expr> = Nil;
  let cur: List<S1Expr> = xs;
  let done: Bool = false;

  while done == false {
    match cur {
      Nil => {
        done = true;
        0
      };
      Cons(cell) => {
        acc = Cons(ListCons<S1Expr> { head: cell.head; tail: acc; });
        cur = cell.tail;
        0
      };
    }
  };

  acc
};

fn s1_reverse_match_arms(xs: List<S1MatchArm>) -> List<S1MatchArm> {
  let acc: List<S1MatchArm> = Nil;
  let cur: List<S1MatchArm> = xs;
  let done: Bool = false;

  while done == false {
    match cur {
      Nil => {
        done = true;
        0
      };
      Cons(cell) => {
        acc = Cons(ListCons<S1MatchArm> { head: cell.head; tail: acc; });
        cur = cell.tail;
        0
      };
    }
  };

  acc
};

fn s1_reverse_types(xs: List<S1Type>) -> List<S1Type> {
  let acc: List<S1Type> = Nil;
  let cur: List<S1Type> = xs;
  let done: Bool = false;

  while done == false {
    match cur {
      Nil => {
        done = true;
        0
      };
      Cons(cell) => {
        acc = Cons(ListCons<S1Type> { head: cell.head; tail: acc; });
        cur = cell.tail;
        0
      };
    }
  };

  acc
};

fn s1_reverse_params(xs: List<S1Param>) -> List<S1Param> {
  let acc: List<S1Param> = Nil;
  let cur: List<S1Param> = xs;
  let done: Bool = false;

  while done == false {
    match cur {
      Nil => {
        done = true;
        0
      };
      Cons(cell) => {
        acc = Cons(ListCons<S1Param> { head: cell.head; tail: acc; });
        cur = cell.tail;
        0
      };
    }
  };

  acc
};

fn s1_parse_generic_params(
  tokens: List<S1Token>
) -> Result<Pair<List<S1GenericParam>, List<S1Token>>, S1Diagnostic> {
  // Parse: <T, U: Bound + Bound2, ...>
  let ok: Bool = true;
  let diag: S1Diagnostic = s1_diag(Error, 0, 0, "parser: expected generic parameter list");

  let cur: List<S1Token> = tokens;
  let params_rev: List<S1GenericParam> = Nil;

  match cur {
    Nil => {
      ok = false;
      diag = s1_diag(Error, 0, 0, "parser: expected '<' for generic parameters");
      0
    };
    Cons(c0) => {
      match c0.head.kind {
        LAngle => {
          cur = c0.tail;
          0
        };
        _ => {
          ok = false;
          diag = s1_diag(
            Error,
            c0.head.span.start,
            c0.head.span.end,
            "parser: expected '<' for generic parameters"
          );
          0
        };
      }
    };
  };

  if ok == true {
    let done: Bool = false;
    while done == false {
      match cur {
        Nil => {
          ok = false;
          diag = s1_diag(Error, 0, 0, "parser: expected generic parameter name or '>'");
          done = true;
          0
        };
        Cons(c1) => {
          let param_name: Text = "";
          let bounds_rev: List<S1Type> = Nil;

          match c1.head.kind {
            Ident(name) => {
              param_name = name;
              cur = c1.tail;
              0
            };
            _ => {
              ok = false;
              diag = s1_diag(
                Error,
                c1.head.span.start,
                c1.head.span.end,
                "parser: expected generic parameter name"
              );
              done = true;
              0
            };
          };

          // optional bounds: : Bound (+ Bound)*
          if ok == true {
            match cur {
              Cons(b0) => {
                match b0.head.kind {
                  Colon => {
                    cur = b0.tail;
                    let bounds_done: Bool = false;
                    while bounds_done == false {
                      let parsed_b: Result<Pair<S1Type, List<S1Token>>, S1Diagnostic> =
                        s1_parse_type(cur);
                      match parsed_b {
                        Err(e) => {
                          ok = false;
                          diag = e;
                          done = true;
                          bounds_done = true;
                          0
                        };
                        Ok(pair) => {
                          bounds_rev =
                            Cons(ListCons<S1Type> { head: pair.a; tail: bounds_rev; });
                          cur = pair.b;
                          0
                        };
                      };

                      if ok == true {
                        match cur {
                          Cons(b1) => {
                            match b1.head.kind {
                              Plus => {
                                cur = b1.tail;
                                0
                              };
                              _ => {
                                bounds_done = true;
                                0
                              };
                            }
                          };
                          _ => {
                            bounds_done = true;
                            0
                          };
                        }
                      } else {
                        bounds_done = true;
                        0
                      }
                    };
                    0
                  };
                  _ => 0;
                }
              };
              _ => 0;
            };
          };

          if ok == true {
            let bounds: List<S1Type> = s1_reverse_types(bounds_rev);
            let param: S1GenericParam = S1GenericParam { name: param_name; bounds: bounds; };
            params_rev =
              Cons(ListCons<S1GenericParam> { head: param; tail: params_rev; });
            0;
          };
          0
        };
      };

      if ok == true {
        match cur {
          Nil => {
            ok = false;
            diag = s1_diag(Error, 0, 0, "parser: expected ',' or '>' after generic parameter");
            done = true;
            0
          };
          Cons(c2) => {
            match c2.head.kind {
              Comma => {
                cur = c2.tail;
                0
              };
              RAngle => {
                cur = c2.tail;
                done = true;
                0
              };
              _ => {
                ok = false;
                diag = s1_diag(
                  Error,
                  c2.head.span.start,
                  c2.head.span.end,
                  "parser: expected ',' or '>' after generic parameter"
                );
                done = true;
                0
              };
            }
          };
        }
      } else {
        done = true;
        0
      }
    };
  } else {
    0;
  };

  let out: Result<Pair<List<S1GenericParam>, List<S1Token>>, S1Diagnostic> = Err(diag);
  if ok == true {
    let params: List<S1GenericParam> = s1_reverse_generic_params(params_rev);
    out = Ok(Pair<List<S1GenericParam>, List<S1Token>> { a: params; b: cur; });
  };
  out
};

fn s1_parse_type(tokens: List<S1Token>) -> Result<Pair<S1Type, List<S1Token>>, S1Diagnostic> {
  let ok: Bool = true;
  let diag: S1Diagnostic = s1_diag(Error, 0, 0, "parser: expected type");

  let empty_args: List<S1Type> = Nil;
  let ty: S1Type = S1Type { name: ""; args: empty_args; };
  let rest: List<S1Token> = tokens;

  match tokens {
    Nil => {
      ok = false;
      0
    };
    Cons(cell0) => {
      match cell0.head.kind {
        Ident(name) => {
          ty = S1Type { name: name; args: empty_args; };
          rest = cell0.tail;
          0
        };
        _ => {
          ok = false;
          diag = s1_diag(
            Error,
            cell0.head.span.start,
            cell0.head.span.end,
            "parser: expected type"
          );
          0
        };
      }
    };
  };

  if ok == true {
    match rest {
      Cons(cell1) => {
        match cell1.head.kind {
          LAngle => {
            rest = cell1.tail;
            let args_rev: List<S1Type> = Nil;

            let args_done: Bool = false;
            while args_done == false {
              let parsed: Result<Pair<S1Type, List<S1Token>>, S1Diagnostic> =
                s1_parse_type(rest);
              match parsed {
                Err(e) => {
                  ok = false;
                  diag = e;
                  args_done = true;
                  0
                };
                Ok(pair) => {
                  args_rev =
                    Cons(ListCons<S1Type> { head: pair.a; tail: args_rev; });
                  rest = pair.b;
                  0
                };
              };

              if ok == true {
                match rest {
                  Nil => {
                    ok = false;
                    diag = s1_diag(
                      Error,
                      cell1.head.span.start,
                      cell1.head.span.end,
                      "parser: expected ',' or '>' after type argument"
                    );
                    args_done = true;
                    0
                  };
                  Cons(cell2) => {
                    match cell2.head.kind {
                      Comma => {
                        rest = cell2.tail;
                        0
                      };
                      RAngle => {
                        rest = cell2.tail;
                        args_done = true;
                        0
                      };
                      _ => {
                        ok = false;
                        diag = s1_diag(
                          Error,
                          cell2.head.span.start,
                          cell2.head.span.end,
                          "parser: expected ',' or '>' after type argument"
                        );
                        args_done = true;
                        0
                      };
                    }
                  };
                }
              } else {
                0
              }
            };

            if ok == true {
              let args: List<S1Type> = s1_reverse_types(args_rev);
              ty = S1Type { name: ty.name; args: args; };
              0
            } else {
              0
            }
          };
          _ => 0;
        }
      };
      _ => 0;
    }
  } else {
    0
  };

  let out: Result<Pair<S1Type, List<S1Token>>, S1Diagnostic> = Err(diag);
  if ok == true {
    out = Ok(Pair<S1Type, List<S1Token>> { a: ty; b: rest; });
  };
  out
};

fn s1_infer_import_ns(path: Text) -> Text {
  let n: Int = text_len(path);

  let i: Int = 0;
  let last_sep: Option<Int> = None;
  let scanning: Bool = true;
  while scanning == true {
    if i == n {
      scanning = false;
      0
    } else {
      let bopt: Option<Int> = text_byte_at(path, i);
      match bopt {
        None => {
          scanning = false;
          i = n;
          0
        };
        Some(b) => {
          if b == 47 {
            last_sep = Some(i);
            0
          } else { 0 };
          i = i + 1;
          0
        };
      }
    }
  };

  let start: Int = 0;
  match last_sep {
    None => 0;
    Some(p) => {
      start = p + 1;
      0
    };
  };

  let j: Int = start;
  let last_dot: Option<Int> = None;
  let scanning2: Bool = true;
  while scanning2 == true {
    if j == n {
      scanning2 = false;
      0
    } else {
      let bopt: Option<Int> = text_byte_at(path, j);
      match bopt {
        None => {
          scanning2 = false;
          0
        };
        Some(b) => {
          if b == 46 {
            last_dot = Some(j);
            0
          } else { 0 };
          j = j + 1;
          0
        };
      }
    }
  };

  let end: Int = n;
  match last_dot {
    None => 0;
    Some(p) => {
      end = p;
      0
    };
  };

  let slice_opt: Option<Text> = text_slice(path, start, end);
  match slice_opt {
    Some(s) => s;
    None => path;
  }
};

fn s1_parse_expr(tokens: List<S1Token>) -> Result<Pair<S1Expr, List<S1Token>>, S1Diagnostic> {
  s1_parse_equality(tokens)
};

fn s1_parse_equality(tokens: List<S1Token>) -> Result<Pair<S1Expr, List<S1Token>>, S1Diagnostic> {
  let ok: Bool = true;
  let diag: S1Diagnostic = s1_diag(Error, 0, 0, "parser: expected expression");

  let left: S1Expr = S1Expr.Path(s1_empty_path());
  let rest: List<S1Token> = tokens;

  let parsed_l: Result<Pair<S1Expr, List<S1Token>>, S1Diagnostic> =
    s1_parse_additive(tokens);
  match parsed_l {
    Err(e) => {
      ok = false;
      diag = e;
      0
    };
    Ok(pair) => {
      left = pair.a;
      rest = pair.b;
      0
    };
  };

  if ok == true {
    let done: Bool = false;
    while done == false {
      match rest {
        Cons(opcell) => {
          match opcell.head.kind {
            EqEq => {
              rest = opcell.tail;
              let rhs: S1Expr = S1Expr.Path(s1_empty_path());
              let parsed_r: Result<Pair<S1Expr, List<S1Token>>, S1Diagnostic> =
                s1_parse_additive(rest);
              match parsed_r {
                Err(e) => {
                  ok = false;
                  diag = e;
                  done = true;
                  0
                };
                Ok(pair) => {
                  rhs = pair.a;
                  rest = pair.b;
                  let prev: S1Expr = left;
                  left =
                    Binary(S1Binary { op: S1BinOp.Equals; left: prev; right: rhs; });
                  0
                };
              };
              0
            };
            NotEq => {
              rest = opcell.tail;
              let rhs: S1Expr = S1Expr.Path(s1_empty_path());
              let parsed_r: Result<Pair<S1Expr, List<S1Token>>, S1Diagnostic> =
                s1_parse_additive(rest);
              match parsed_r {
                Err(e) => {
                  ok = false;
                  diag = e;
                  done = true;
                  0
                };
                Ok(pair) => {
                  rhs = pair.a;
                  rest = pair.b;
                  let prev: S1Expr = left;
                  left =
                    Binary(S1Binary { op: S1BinOp.NotEquals; left: prev; right: rhs; });
                  0
                };
              };
              0
            };
            _ => {
              done = true;
              0
            };
          }
        };
        _ => {
          done = true;
          0
        };
      }
    };
    0;
  };

  let out: Result<Pair<S1Expr, List<S1Token>>, S1Diagnostic> = Err(diag);
  if ok == true {
    out = Ok(Pair<S1Expr, List<S1Token>> { a: left; b: rest; });
  };
  out
};

fn s1_parse_additive(tokens: List<S1Token>) -> Result<Pair<S1Expr, List<S1Token>>, S1Diagnostic> {
  let ok: Bool = true;
  let diag: S1Diagnostic = s1_diag(Error, 0, 0, "parser: expected expression");

  let left: S1Expr = S1Expr.Path(s1_empty_path());
  let rest: List<S1Token> = tokens;

  let parsed_l: Result<Pair<S1Expr, List<S1Token>>, S1Diagnostic> =
    s1_parse_primary_expr(tokens);
  match parsed_l {
    Err(e) => {
      ok = false;
      diag = e;
      0
    };
    Ok(pair) => {
      left = pair.a;
      rest = pair.b;
      0
    };
  };

  if ok == true {
    let done: Bool = false;
    while done == false {
      match rest {
        Cons(opcell) => {
          match opcell.head.kind {
            Plus => {
              rest = opcell.tail;
              let rhs: S1Expr = S1Expr.Path(s1_empty_path());
              let parsed_r: Result<Pair<S1Expr, List<S1Token>>, S1Diagnostic> =
                s1_parse_primary_expr(rest);
              match parsed_r {
                Err(e) => {
                  ok = false;
                  diag = e;
                  done = true;
                  0
                };
                Ok(pair) => {
                  rhs = pair.a;
                  rest = pair.b;
                  let prev: S1Expr = left;
                  left =
                    Binary(S1Binary { op: S1BinOp.Add; left: prev; right: rhs; });
                  0
                };
              };
              0
            };
            _ => {
              done = true;
              0
            };
          }
        };
        _ => {
          done = true;
          0
        };
      }
    };
    0;
  };

  let out: Result<Pair<S1Expr, List<S1Token>>, S1Diagnostic> = Err(diag);
  if ok == true {
    out = Ok(Pair<S1Expr, List<S1Token>> { a: left; b: rest; });
  };
  out
};

fn s1_parse_primary_expr(tokens: List<S1Token>) -> Result<Pair<S1Expr, List<S1Token>>, S1Diagnostic> {
  let ok: Bool = true;
  let diag: S1Diagnostic = s1_diag(Error, 0, 0, "parser: expected expression");

  let expr: S1Expr = S1Expr.Path(s1_empty_path());
  let rest: List<S1Token> = tokens;

  match tokens {
    Nil => {
      ok = false;
      0
    };
    Cons(cell0) => {
      match cell0.head.kind {
        KwIf => {
          rest = cell0.tail;
          let cond: S1Expr = S1Expr.Path(s1_empty_path());
          let empty_stmts: List<S1Stmt> = Nil;
          let empty_result: Option<S1Expr> = None;
          let then_block: S1Block = S1Block { stmts: empty_stmts; result: empty_result; };
          let else_block: Option<S1Block> = None;

          // condition expr
          let parsed_cond: Result<Pair<S1Expr, List<S1Token>>, S1Diagnostic> =
            s1_parse_expr(rest);
          match parsed_cond {
            Err(e) => {
              ok = false;
              diag = e;
              0
            };
            Ok(pair) => {
              cond = pair.a;
              rest = pair.b;
              0
            };
          };

          // then block
          if ok == true {
            match rest {
              Cons(t0) => {
                match t0.head.kind {
                  LBrace => {
                    let parsed_b: Result<Pair<S1Block, List<S1Token>>, S1Diagnostic> =
                      s1_parse_block(t0.tail);
                    match parsed_b {
                      Err(e) => {
                        ok = false;
                        diag = e;
                        0
                      };
                      Ok(pair) => {
                        then_block = pair.a;
                        rest = pair.b;
                        0
                      };
                    };
                    0
                  };
                  _ => {
                    ok = false;
                    diag = s1_diag(Error, t0.head.span.start, t0.head.span.end, "parser: expected '{' after if condition");
                    0
                  };
                }
              };
              _ => {
                ok = false;
                diag = s1_diag(Error, cell0.head.span.start, cell0.head.span.end, "parser: expected '{' after if condition");
                0
              };
            };
            0
          } else { 0 };

          // optional else
          if ok == true {
            match rest {
              Cons(e0) => {
                match e0.head.kind {
                  KwElse => {
                    rest = e0.tail;
                    match rest {
                      Cons(e1) => {
                        match e1.head.kind {
                          LBrace => {
                            let parsed_eb: Result<Pair<S1Block, List<S1Token>>, S1Diagnostic> =
                              s1_parse_block(e1.tail);
                            match parsed_eb {
                              Err(e) => {
                                ok = false;
                                diag = e;
                                0
                              };
                              Ok(pair) => {
                                else_block = Some(pair.a);
                                rest = pair.b;
                                0
                              };
                            };
                            0
                          };
                          _ => {
                            ok = false;
                            diag = s1_diag(Error, e1.head.span.start, e1.head.span.end, "parser: expected '{' after else");
                            0
                          };
                        }
                      };
                      _ => {
                        ok = false;
                        diag = s1_diag(Error, e0.head.span.start, e0.head.span.end, "parser: expected '{' after else");
                        0
                      };
                    }
                  };
                  _ => 0;
                }
              };
              _ => 0;
            };
            0
          } else { 0 };

          if ok == true {
            expr = If(S1If { cond: cond; then_block: then_block; else_block: else_block; });
            0
          } else {
            0
          }
        };
        KwMatch => {
          rest = cell0.tail;
          let scrutinee: S1Expr = S1Expr.Path(s1_empty_path());
          let arms_rev: List<S1MatchArm> = Nil;

          // scrutinee expr
          let parsed_scr: Result<Pair<S1Expr, List<S1Token>>, S1Diagnostic> =
            s1_parse_expr(rest);
          match parsed_scr {
            Err(e) => {
              ok = false;
              diag = e;
              0
            };
            Ok(pair) => {
              scrutinee = pair.a;
              rest = pair.b;
              0
            };
          };

          // {
          if ok == true {
            match rest {
              Cons(m0) => {
                match m0.head.kind {
                  LBrace => {
                    rest = m0.tail;
                    0
                  };
                  _ => {
                    ok = false;
                    diag = s1_diag(Error, m0.head.span.start, m0.head.span.end, "parser: expected '{' after match scrutinee");
                    0
                  };
                }
              };
              _ => {
                ok = false;
                diag = s1_diag(Error, cell0.head.span.start, cell0.head.span.end, "parser: expected '{' after match scrutinee");
                0
              };
            };
            0
          } else { 0 };

          // arms until }
          if ok == true {
            let done: Bool = false;
            while done == false {
              match rest {
                Nil => {
                  ok = false;
                  diag = s1_diag(Error, cell0.head.span.start, cell0.head.span.end, "parser: expected '}' to close match");
                  done = true;
                  0
                };
                Cons(a0) => {
                  match a0.head.kind {
                    RBrace => {
                      rest = a0.tail;
                      done = true;
                      0
                    };
                    Ident(pname) => {
                      let pat: S1Pattern = S1Pattern.Wildcard;
                      if pname == "_" {
                        pat = S1Pattern.Wildcard;
                        rest = a0.tail;
                        0
                      } else {
                        let parsed_pat: Pair<S1Path, List<S1Token>> =
                          s1_parse_path_tail(pname, a0.tail);
                        let base_path: S1Path = parsed_pat.a;
                        rest = parsed_pat.b;

                        // optional payload: (ident | _)
                        let payload: Option<S1VariantPayload> = None;
                        match rest {
                          Cons(p0) => {
                            match p0.head.kind {
                              LParen => {
                                rest = p0.tail;
                                match rest {
                                  Cons(p1) => {
                                    match p1.head.kind {
                                      Ident(binder) => {
                                        if binder == "_" {
                                          let plopt: Option<S1VariantPayload> =
                                            Some(S1VariantPayload.Wildcard);
                                          payload = plopt;
                                          0
                                        } else {
                                          let plopt: Option<S1VariantPayload> =
                                            Some(S1VariantPayload.Bind(binder));
                                          payload = plopt;
                                          0
                                        };
                                        rest = p1.tail;
                                        0
                                      };
                                      _ => {
                                        ok = false;
                                        diag = s1_diag(Error, p1.head.span.start, p1.head.span.end, "parser: expected binder name or '_' in variant pattern");
                                        done = true;
                                        0
                                      };
                                    }
                                  };
                                  _ => {
                                    ok = false;
                                    diag = s1_diag(Error, p0.head.span.start, p0.head.span.end, "parser: expected binder name or '_' in variant pattern");
                                    done = true;
                                    0
                                  };
                                };

                                if ok == true {
                                  match rest {
                                    Cons(p2) => {
                                      match p2.head.kind {
                                        RParen => {
                                          rest = p2.tail;
                                          0
                                        };
                                        _ => {
                                          ok = false;
                                          diag = s1_diag(Error, p2.head.span.start, p2.head.span.end, "parser: expected ')' to close variant pattern");
                                          done = true;
                                          0
                                        };
                                      }
                                    };
                                    _ => {
                                      ok = false;
                                      diag = s1_diag(Error, p0.head.span.start, p0.head.span.end, "parser: expected ')' to close variant pattern");
                                      done = true;
                                      0
                                    };
                                  };
                                  0
                                } else { 0 };

                                0
                              };
                              _ => 0;
                            }
                          };
                          _ => 0;
                        };

                        match payload {
                          Some(pl) => {
                            let plopt: Option<S1VariantPayload> = Some(pl);
                            let vp: S1VariantPattern =
                              S1VariantPattern { path: base_path; payload: plopt; };
                            pat = S1Pattern.Variant(vp);
                            0
                          };
                          None => {
                            pat = S1Pattern.Path(base_path);
                            0
                          };
                        };
                        0
                      };

                      // =>
                      if ok == true {
                        match rest {
                          Cons(a1) => {
                            match a1.head.kind {
                              FatArrow => {
                                rest = a1.tail;
                                0
                              };
                              _ => {
                                ok = false;
                                diag = s1_diag(Error, a1.head.span.start, a1.head.span.end, "parser: expected '=>' in match arm");
                                done = true;
                                0
                              };
                            }
                          };
                          _ => {
                            ok = false;
                            diag = s1_diag(Error, a0.head.span.start, a0.head.span.end, "parser: expected '=>' in match arm");
                            done = true;
                            0
                          };
                        }
                      } else { 0 };

                      // expr
                      let value: S1Expr = S1Expr.Path(s1_empty_path());
                      if ok == true {
                        let parsed_v: Result<Pair<S1Expr, List<S1Token>>, S1Diagnostic> =
                          s1_parse_expr(rest);
                        match parsed_v {
                          Err(e) => {
                            ok = false;
                            diag = e;
                            done = true;
                            0
                          };
                          Ok(pair) => {
                            value = pair.a;
                            rest = pair.b;
                            0
                          };
                        };
                        0
                      } else { 0 };

                      // ;
                      if ok == true {
                        match rest {
                          Cons(a2) => {
                            match a2.head.kind {
                              Semicolon => {
                                let arm: S1MatchArm = S1MatchArm { pat: pat; value: value; };
                                arms_rev =
                                  Cons(ListCons<S1MatchArm> { head: arm; tail: arms_rev; });
                                rest = a2.tail;
                                0
                              };
                              _ => {
                                ok = false;
                                diag = s1_diag(Error, a2.head.span.start, a2.head.span.end, "parser: expected ';' after match arm");
                                done = true;
                                0
                              };
                            }
                          };
                          _ => {
                            ok = false;
                            diag = s1_diag(Error, a0.head.span.start, a0.head.span.end, "parser: expected ';' after match arm");
                            done = true;
                            0
                          };
                        }
                      } else { 0 };

                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(Error, a0.head.span.start, a0.head.span.end, "parser: expected pattern or '}' in match");
                      done = true;
                      0
                    };
                  }
                };
              }
            };
            0
          } else { 0 };

          if ok == true {
            let arms: List<S1MatchArm> = s1_reverse_match_arms(arms_rev);
            expr = Match(S1Match { scrutinee: scrutinee; arms: arms; });
            0
          } else {
            0
          }
        };
        Number(n) => {
          expr = IntLit(n);
          rest = cell0.tail;
          0
        };
        String(s) => {
          expr = StringLit(s);
          rest = cell0.tail;
          0
        };
        Ident(name) => {
          // Path or Call
          let parsed_path: Pair<S1Path, List<S1Token>> = s1_parse_path_tail(name, cell0.tail);
          let path: S1Path = parsed_path.a;
          rest = parsed_path.b;
          expr = S1Expr.Path(path);

          match rest {
            Cons(cell1) => {
              match cell1.head.kind {
                LParen => {
                  rest = cell1.tail;
                  let args_rev: List<S1Expr> = Nil;
                  let done: Bool = false;

                  while done == false {
                    match rest {
                      Nil => {
                        ok = false;
                        diag = s1_diag(Error, cell0.head.span.start, cell0.head.span.end, "parser: expected ')' to close call");
                        done = true;
                        0
                      };
                      Cons(cell2) => {
                        match cell2.head.kind {
                          RParen => {
                            rest = cell2.tail;
                            done = true;
                            0
                          };
                          _ => {
                            let parsed: Result<Pair<S1Expr, List<S1Token>>, S1Diagnostic> =
                              s1_parse_expr(rest);
                            match parsed {
                              Err(e) => {
                                ok = false;
                                diag = e;
                                done = true;
                                0
                              };
                              Ok(pair) => {
                                args_rev =
                                  Cons(ListCons<S1Expr> { head: pair.a; tail: args_rev; });
                                rest = pair.b;
                                0
                              };
                            };

                            if ok == true {
                              match rest {
                                Nil => {
                                  ok = false;
                                  diag = s1_diag(Error, cell0.head.span.start, cell0.head.span.end, "parser: expected ',' or ')' after call argument");
                                  done = true;
                                  0
                                };
                                Cons(cell3) => {
                                  match cell3.head.kind {
                                    Comma => {
                                      rest = cell3.tail;
                                      0
                                    };
                                    RParen => {
                                      rest = cell3.tail;
                                      done = true;
                                      0
                                    };
                                    _ => {
                                      ok = false;
                                      diag = s1_diag(Error, cell3.head.span.start, cell3.head.span.end, "parser: expected ',' or ')' after call argument");
                                      done = true;
                                      0
                                    };
                                  }
                                };
                              }
                            } else {
                              done = true;
                              0
                            }
                          };
                        }
                      };
                    }
                  };

                  if ok == true {
                    let args: List<S1Expr> = s1_reverse_exprs(args_rev);
                    expr = Call(S1Call { callee: path; args: args; });
                    0
                  } else {
                    0
                  }
                };
                _ => 0;
              }
            };
            _ => 0;
          };
          0
        };
        LBrace => {
          let parsed_b: Result<Pair<S1Block, List<S1Token>>, S1Diagnostic> =
            s1_parse_block(cell0.tail);
          match parsed_b {
            Err(e) => {
              ok = false;
              diag = e;
              0
            };
            Ok(pair) => {
              expr = Block(pair.a);
              rest = pair.b;
              0
            };
          };
          0
        };
        _ => {
          ok = false;
          diag = s1_diag(
            Error,
            cell0.head.span.start,
            cell0.head.span.end,
            "parser: expected expression"
          );
          0
        };
      }
    };
  };

  let out: Result<Pair<S1Expr, List<S1Token>>, S1Diagnostic> = Err(diag);
  if ok == true {
    out = Ok(Pair<S1Expr, List<S1Token>> { a: expr; b: rest; });
  };
  out
};

fn s1_parse_block(tokens: List<S1Token>) -> Result<Pair<S1Block, List<S1Token>>, S1Diagnostic> {
  let ok: Bool = true;
  let diag: S1Diagnostic = s1_diag(Error, 0, 0, "parser: expected block");

  let cur: List<S1Token> = tokens;
  let stmts_rev: List<S1Stmt> = Nil;
  let result: Option<S1Expr> = None;

  let done: Bool = false;
  while done == false {
    match cur {
      Nil => {
        ok = false;
        diag = s1_diag(Error, 0, 0, "parser: expected '}' to close block");
        done = true;
        0
      };
      Cons(cell0) => {
        match cell0.head.kind {
          RBrace => {
            cur = cell0.tail;
            done = true;
            0
          };
          KwLet => {
            cur = cell0.tail;
            let name: Text = "";
            let empty_args: List<S1Type> = Nil;
            let ty: S1Type = S1Type { name: ""; args: empty_args; };
            let value: S1Expr = S1Expr.Path(s1_empty_path());

            // name
            match cur {
              Nil => {
                ok = false;
                diag = s1_diag(Error, cell0.head.span.start, cell0.head.span.end, "parser: expected name after 'let'");
                done = true;
                0
              };
              Cons(cell1) => {
                match cell1.head.kind {
                  Ident(n) => {
                    name = n;
                    cur = cell1.tail;
                    0
                  };
                  _ => {
                    ok = false;
                    diag = s1_diag(Error, cell1.head.span.start, cell1.head.span.end, "parser: expected name after 'let'");
                    done = true;
                    0
                  };
                }
              };
            };

            // :
            if ok == true {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(Error, cell0.head.span.start, cell0.head.span.end, "parser: expected ':' in let");
                  done = true;
                  0
                };
                Cons(cell2) => {
                  match cell2.head.kind {
                    Colon => {
                      cur = cell2.tail;
                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(Error, cell2.head.span.start, cell2.head.span.end, "parser: expected ':' in let");
                      done = true;
                      0
                    };
                  }
                };
              };
            };

            // type
            if ok == true {
              let parsed_ty: Result<Pair<S1Type, List<S1Token>>, S1Diagnostic> =
                s1_parse_type(cur);
              match parsed_ty {
                Err(e) => {
                  ok = false;
                  diag = e;
                  done = true;
                  0
                };
                Ok(pair) => {
                  ty = pair.a;
                  cur = pair.b;
                  0
                };
              };
            };

            // =
            if ok == true {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(Error, cell0.head.span.start, cell0.head.span.end, "parser: expected '=' in let");
                  done = true;
                  0
                };
                Cons(cell3) => {
                  match cell3.head.kind {
                    Eq => {
                      cur = cell3.tail;
                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(Error, cell3.head.span.start, cell3.head.span.end, "parser: expected '=' in let");
                      done = true;
                      0
                    };
                  }
                };
              };
            };

            // expr
            if ok == true {
              let parsed_e: Result<Pair<S1Expr, List<S1Token>>, S1Diagnostic> =
                s1_parse_expr(cur);
              match parsed_e {
                Err(e) => {
                  ok = false;
                  diag = e;
                  done = true;
                  0
                };
                Ok(pair) => {
                  value = pair.a;
                  cur = pair.b;
                  0
                };
              };
            };

            // ;
            if ok == true {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(Error, cell0.head.span.start, cell0.head.span.end, "parser: expected ';' after let");
                  done = true;
                  0
                };
                Cons(cell4) => {
                  match cell4.head.kind {
                    Semicolon => {
                      cur = cell4.tail;
                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(Error, cell4.head.span.start, cell4.head.span.end, "parser: expected ';' after let");
                      done = true;
                      0
                    };
                  }
                };
              };
            };

            if ok == true {
              let st: S1Stmt = Let(S1Let { name: name; ty: ty; value: value; });
              stmts_rev = Cons(ListCons<S1Stmt> { head: st; tail: stmts_rev; });
              0;
            };
            0
          };
          KwWhile => {
            cur = cell0.tail;
            let cond: S1Expr = S1Expr.Path(s1_empty_path());
            let empty_stmts: List<S1Stmt> = Nil;
            let empty_result: Option<S1Expr> = None;
            let body: S1Block = S1Block { stmts: empty_stmts; result: empty_result; };

            // cond expr
            let parsed_cond: Result<Pair<S1Expr, List<S1Token>>, S1Diagnostic> =
              s1_parse_expr(cur);
            match parsed_cond {
              Err(e) => {
                ok = false;
                diag = e;
                done = true;
                0
              };
              Ok(pair) => {
                cond = pair.a;
                cur = pair.b;
                0
              };
            };

            // {
            if ok == true {
              match cur {
                Cons(w0) => {
                  match w0.head.kind {
                    LBrace => {
                      let parsed_body: Result<Pair<S1Block, List<S1Token>>, S1Diagnostic> =
                        s1_parse_block(w0.tail);
                      match parsed_body {
                        Err(e) => {
                          ok = false;
                          diag = e;
                          done = true;
                          0
                        };
                        Ok(pair) => {
                          body = pair.a;
                          cur = pair.b;
                          0
                        };
                      };
                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(Error, w0.head.span.start, w0.head.span.end, "parser: expected '{' after while condition");
                      done = true;
                      0
                    };
                  }
                };
                _ => {
                  ok = false;
                  diag = s1_diag(Error, cell0.head.span.start, cell0.head.span.end, "parser: expected '{' after while condition");
                  done = true;
                  0
                };
              };
            };

            // ;
            if ok == true {
              match cur {
                Cons(w1) => {
                  match w1.head.kind {
                    Semicolon => {
                      cur = w1.tail;
                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(Error, w1.head.span.start, w1.head.span.end, "parser: expected ';' after while block");
                      done = true;
                      0
                    };
                  }
                };
                _ => {
                  ok = false;
                  diag = s1_diag(Error, cell0.head.span.start, cell0.head.span.end, "parser: expected ';' after while block");
                  done = true;
                  0
                };
              };
            };

            if ok == true {
              let st: S1Stmt = While(S1While { cond: cond; body: body; });
              stmts_rev = Cons(ListCons<S1Stmt> { head: st; tail: stmts_rev; });
              0;
            };
            0
          };
          KwReturn => {
            cur = cell0.tail;
            let value: S1Expr = S1Expr.Path(s1_empty_path());

            let parsed: Result<Pair<S1Expr, List<S1Token>>, S1Diagnostic> =
              s1_parse_expr(cur);
            match parsed {
              Err(e) => {
                ok = false;
                diag = e;
                done = true;
                0
              };
              Ok(pair) => {
                value = pair.a;
                cur = pair.b;
                0
              };
            };

            if ok == true {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(Error, cell0.head.span.start, cell0.head.span.end, "parser: expected ';' after return");
                  done = true;
                  0
                };
                Cons(cell1) => {
                  match cell1.head.kind {
                    Semicolon => {
                      cur = cell1.tail;
                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(Error, cell1.head.span.start, cell1.head.span.end, "parser: expected ';' after return");
                      done = true;
                      0
                    };
                  }
                };
              };
            };

            if ok == true {
              let st: S1Stmt = Return(S1Return { value: value; });
              stmts_rev = Cons(ListCons<S1Stmt> { head: st; tail: stmts_rev; });
              0;
            };
            0
          };
          _ => {
            // expr, assignment, expr stmt, or block result
            let parsed: Result<Pair<S1Expr, List<S1Token>>, S1Diagnostic> =
              s1_parse_expr(cur);
            let expr: S1Expr = S1Expr.Path(s1_empty_path());
            let rest: List<S1Token> = cur;

            match parsed {
              Err(e) => {
                ok = false;
                diag = e;
                done = true;
                0
              };
              Ok(pair) => {
                expr = pair.a;
                rest = pair.b;
                0
              };
            };

            if ok == true {
              match expr {
                Path(p) => {
                  match p.ns {
                    None => {
                      let name: Text = p.name;
                      match rest {
                        Cons(cell1) => {
                          match cell1.head.kind {
                            Eq => {
                              // assignment
                              rest = cell1.tail;
                              let rhs: S1Expr = S1Expr.Path(s1_empty_path());
                              let parsed_rhs: Result<Pair<S1Expr, List<S1Token>>, S1Diagnostic> =
                                s1_parse_expr(rest);
                              match parsed_rhs {
                                Err(e) => {
                                  ok = false;
                                  diag = e;
                                  done = true;
                                  0
                                };
                                Ok(pair) => {
                                  rhs = pair.a;
                                  rest = pair.b;
                                  0
                                };
                              };

                              if ok == true {
                                match rest {
                                  Nil => {
                                    ok = false;
                                    diag = s1_diag(Error, cell0.head.span.start, cell0.head.span.end, "parser: expected ';' after assignment");
                                    done = true;
                                    0
                                  };
                                  Cons(cell2) => {
                                    match cell2.head.kind {
                                      Semicolon => {
                                        cur = cell2.tail;
                                        let st: S1Stmt = Assign(S1Assign { name: name; value: rhs; });
                                        stmts_rev = Cons(ListCons<S1Stmt> { head: st; tail: stmts_rev; });
                                        0
                                      };
                                      _ => {
                                        ok = false;
                                        diag = s1_diag(Error, cell2.head.span.start, cell2.head.span.end, "parser: expected ';' after assignment");
                                        done = true;
                                        0
                                      };
                                    }
                                  };
                                }
                              } else { 0 };
                              0
                            };
                            _ => {
                              // not assignment; treat as expr stmt or result
                              match rest {
                                Cons(cell2) => {
                                  match cell2.head.kind {
                                    Semicolon => {
                                      cur = cell2.tail;
                                      let st: S1Stmt = ExprStmt(expr);
                                      stmts_rev = Cons(ListCons<S1Stmt> { head: st; tail: stmts_rev; });
                                      0
                                    };
                                    RBrace => {
                                      result = Some(expr);
                                      cur = cell2.tail;
                                      done = true;
                                      0
                                    };
                                    _ => {
                                      ok = false;
                                      diag = s1_diag(Error, cell2.head.span.start, cell2.head.span.end, "parser: expected ';' or '}' after expression");
                                      done = true;
                                      0
                                    };
                                  }
                                };
                                Nil => {
                                  ok = false;
                                  diag = s1_diag(Error, cell0.head.span.start, cell0.head.span.end, "parser: expected ';' or '}' after expression");
                                  done = true;
                                  0
                                };
                              };
                              0
                            };
                          }
                        };
                        _ => {
                          ok = false;
                          diag = s1_diag(Error, cell0.head.span.start, cell0.head.span.end, "parser: expected ';' or '}' after expression");
                          done = true;
                          0
                        };
                      };
                      0
                    };
                    _ => {
                      // qualified path can't be assignment target in Stage1
                      match rest {
                        Cons(cell2) => {
                          match cell2.head.kind {
                            Semicolon => {
                              cur = cell2.tail;
                              let st: S1Stmt = ExprStmt(expr);
                              stmts_rev = Cons(ListCons<S1Stmt> { head: st; tail: stmts_rev; });
                              0
                            };
                            RBrace => {
                              result = Some(expr);
                              cur = cell2.tail;
                              done = true;
                              0
                            };
                            _ => {
                              ok = false;
                              diag = s1_diag(Error, cell2.head.span.start, cell2.head.span.end, "parser: expected ';' or '}' after expression");
                              done = true;
                              0
                            };
                          }
                        };
                        Nil => {
                          ok = false;
                          diag = s1_diag(Error, cell0.head.span.start, cell0.head.span.end, "parser: expected ';' or '}' after expression");
                          done = true;
                          0
                        };
                      };
                      0
                    };
                  }
                };
                _ => {
                  // expr stmt or result
                  match rest {
                    Cons(cell2) => {
                      match cell2.head.kind {
                        Semicolon => {
                          cur = cell2.tail;
                          let st: S1Stmt = ExprStmt(expr);
                          stmts_rev = Cons(ListCons<S1Stmt> { head: st; tail: stmts_rev; });
                          0
                        };
                        RBrace => {
                          result = Some(expr);
                          cur = cell2.tail;
                          done = true;
                          0
                        };
                        _ => {
                          ok = false;
                          diag = s1_diag(Error, cell2.head.span.start, cell2.head.span.end, "parser: expected ';' or '}' after expression");
                          done = true;
                          0
                        };
                      }
                    };
                    Nil => {
                      ok = false;
                      diag = s1_diag(Error, cell0.head.span.start, cell0.head.span.end, "parser: expected ';' or '}' after expression");
                      done = true;
                      0
                    };
                  };
                  0
                };
              }
            } else {
              0
            }
          };
        }
      };
    }
  };

  let out: Result<Pair<S1Block, List<S1Token>>, S1Diagnostic> = Err(diag);
  if ok == true {
    let stmts: List<S1Stmt> = s1_reverse_stmts(stmts_rev);
    out = Ok(Pair<S1Block, List<S1Token>> {
      a: S1Block { stmts: stmts; result: result; };
      b: cur;
    });
  };
  out
};

fn s1_parse(tokens: List<S1Token>) -> Result<S1Program, S1Diagnostic>
intent "Stage1 parser (pure): tokens -> AST"
evidence {
  trace "stage1.parser.v0";
  metrics [stage1_parse_calls];
}
{
  let cur: List<S1Token> = tokens;
  let items_rev: List<S1Item> = Nil;

  let ok: Bool = true;
  let diag: S1Diagnostic = s1_diag(Error, 0, 0, "parser error");

  let done: Bool = false;
  while done == false {
    match cur {
      Nil => {
        ok = false;
        diag = s1_diag(Error, 0, 0, "parser: unexpected end of token stream");
        done = true;
        0
      };
      Cons(cell0) => {
        match cell0.head.kind {
          Eof => {
            done = true;
            0
          };
          KwImport => {
            // Parse: import <String> ;
            let imp_start: Int = cell0.head.span.start;
            cur = cell0.tail;

            let path: Text = "";
            let ns: Text = "";

            match cur {
              Nil => {
                ok = false;
                diag = s1_diag(Error, imp_start, imp_start, "parser: expected import path string");
                done = true;
                0
              };
              Cons(cell1) => {
                match cell1.head.kind {
                  String(s) => {
                    path = s;
                    cur = cell1.tail;
                    0
                  };
                  _ => {
                    ok = false;
                    diag = s1_diag(Error, cell1.head.span.start, cell1.head.span.end, "parser: expected import path string");
                    done = true;
                    0
                  };
                }
              };
            };

            if ok == true {
              ns = s1_infer_import_ns(path);
              0;
            };

            // optional alias: as Name
            if ok == true {
              match cur {
                Cons(cell_as0) => {
                  match cell_as0.head.kind {
                    KwAs => {
                      cur = cell_as0.tail;
                      match cur {
                        Nil => {
                          ok = false;
                          diag = s1_diag(Error, imp_start, imp_start, "parser: expected namespace after 'as'");
                          done = true;
                          0
                        };
                        Cons(cell_as1) => {
                          match cell_as1.head.kind {
                            Ident(name) => {
                              ns = name;
                              cur = cell_as1.tail;
                              0
                            };
                            _ => {
                              ok = false;
                              diag = s1_diag(
                                Error,
                                cell_as1.head.span.start,
                                cell_as1.head.span.end,
                                "parser: expected namespace after 'as'"
                              );
                              done = true;
                              0
                            };
                          }
                        };
                      };
                      0
                    };
                    _ => 0;
                  }
                };
                _ => 0;
              };
            };

            if ok == true {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(Error, imp_start, imp_start, "parser: expected ';' after import");
                  done = true;
                  0
                };
                Cons(cell2) => {
                  match cell2.head.kind {
                    Semicolon => {
                      cur = cell2.tail;
                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(Error, cell2.head.span.start, cell2.head.span.end, "parser: expected ';' after import");
                      done = true;
                      0
                    };
                  }
                };
              };
            };

            if ok == true {
              let item: S1Item = Import(S1Import { path: path; ns: ns; });
              items_rev = Cons(ListCons<S1Item> { head: item; tail: items_rev; });
              0;
            };
            0
          };
          KwFn => {
            // Parse: fn <Ident> ( <params>? ) -> <type> ( ';' | <block> ';' )
            let fn_start: Int = cell0.head.span.start;
            cur = cell0.tail;

            let fn_name: Text = "";
            let generics: List<S1GenericParam> = Nil;
            let params_rev: List<S1Param> = Nil;
            let empty_args: List<S1Type> = Nil;
            let ret_ty: S1Type = S1Type { name: ""; args: empty_args; };
            let body: Option<S1Block> = None;

            // name
            match cur {
              Nil => {
                ok = false;
                diag = s1_diag(Error, fn_start, fn_start, "parser: expected function name");
                done = true;
                0
              };
              Cons(cell1) => {
                match cell1.head.kind {
                  Ident(name) => {
                    fn_name = name;
                    cur = cell1.tail;
                    0
                  };
                  _ => {
                    ok = false;
                    diag = s1_diag(Error, cell1.head.span.start, cell1.head.span.end, "parser: expected function name");
                    done = true;
                    0
                  };
                }
              };
            };

            // optional generics: <T, ...>
            if ok == true {
              match cur {
                Cons(g0) => {
                  match g0.head.kind {
                    LAngle => {
                      let parsed_g: Result<Pair<List<S1GenericParam>, List<S1Token>>, S1Diagnostic> =
                        s1_parse_generic_params(cur);
                      match parsed_g {
                        Err(e) => {
                          ok = false;
                          diag = e;
                          done = true;
                          0
                        };
                        Ok(pair) => {
                          generics = pair.a;
                          cur = pair.b;
                          0
                        };
                      };
                      0
                    };
                    _ => 0;
                  }
                };
                _ => 0;
              };
            };

            // (
            if ok == true {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(Error, fn_start, fn_start, "parser: expected '('");
                  done = true;
                  0
                };
                Cons(cell2) => {
                  match cell2.head.kind {
                    LParen => {
                      cur = cell2.tail;
                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(Error, cell2.head.span.start, cell2.head.span.end, "parser: expected '('");
                      done = true;
                      0
                    };
                  }
                };
              };
            };

            // params? )
            if ok == true {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(Error, fn_start, fn_start, "parser: expected ')' or parameter");
                  done = true;
                  0
                };
                Cons(cell3) => {
                  match cell3.head.kind {
                    RParen => {
                      cur = cell3.tail;
                      0
                    };
                    _ => {
                      let params_done: Bool = false;
                      while params_done == false {
                        let p_name: Text = "";
                        let p_ty: S1Type = S1Type { name: ""; args: empty_args; };

                        // param name
                        match cur {
                          Nil => {
                            ok = false;
                            diag = s1_diag(Error, fn_start, fn_start, "parser: expected parameter name");
                            done = true;
                            params_done = true;
                            0
                          };
                          Cons(p0) => {
                            match p0.head.kind {
                              Ident(name) => {
                                p_name = name;
                                cur = p0.tail;
                                0
                              };
                              _ => {
                                ok = false;
                                diag = s1_diag(Error, p0.head.span.start, p0.head.span.end, "parser: expected parameter name");
                                done = true;
                                params_done = true;
                                0
                              };
                            }
                          };
                        };

                        // :
                        if ok == true {
                          match cur {
                            Nil => {
                              ok = false;
                              diag = s1_diag(Error, fn_start, fn_start, "parser: expected ':' after parameter name");
                              done = true;
                              params_done = true;
                              0
                            };
                            Cons(p1) => {
                              match p1.head.kind {
                                Colon => {
                                  cur = p1.tail;
                                  0
                                };
                                _ => {
                                  ok = false;
                                  diag = s1_diag(Error, p1.head.span.start, p1.head.span.end, "parser: expected ':' after parameter name");
                                  done = true;
                                  params_done = true;
                                  0
                                };
                              }
                            };
                          };
                        };

                        // type
                        if ok == true {
                          let parsed: Result<Pair<S1Type, List<S1Token>>, S1Diagnostic> =
                            s1_parse_type(cur);
                          match parsed {
                            Err(e) => {
                              ok = false;
                              diag = e;
                              done = true;
                              params_done = true;
                              0
                            };
                            Ok(pair) => {
                              p_ty = pair.a;
                              cur = pair.b;
                              0
                            };
                          };
                        };

                        if ok == true {
                          let param: S1Param = S1Param { name: p_name; ty: p_ty; };
                          params_rev =
                            Cons(ListCons<S1Param> { head: param; tail: params_rev; });
                          0;
                        };

                        // , or )
                        if ok == true {
                          match cur {
                            Nil => {
                              ok = false;
                              diag = s1_diag(Error, fn_start, fn_start, "parser: expected ',' or ')' after parameter");
                              done = true;
                              params_done = true;
                              0
                            };
                            Cons(p2) => {
                              match p2.head.kind {
                                Comma => {
                                  cur = p2.tail;
                                  0
                                };
                                RParen => {
                                  cur = p2.tail;
                                  params_done = true;
                                  0
                                };
                                _ => {
                                  ok = false;
                                  diag = s1_diag(Error, p2.head.span.start, p2.head.span.end, "parser: expected ',' or ')' after parameter");
                                  done = true;
                                  params_done = true;
                                  0
                                };
                              }
                            };
                          };
                        };
                      };
                      0
                    };
                  }
                };
              };
            };

            // ->
            if ok == true {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(Error, fn_start, fn_start, "parser: expected '->'");
                  done = true;
                  0
                };
                Cons(cell4) => {
                  match cell4.head.kind {
                    Arrow => {
                      cur = cell4.tail;
                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(Error, cell4.head.span.start, cell4.head.span.end, "parser: expected '->'");
                      done = true;
                      0
                    };
                  }
                };
              };
            };

            // return type
            if ok == true {
              let parsed: Result<Pair<S1Type, List<S1Token>>, S1Diagnostic> = s1_parse_type(cur);
              match parsed {
                Err(e) => {
                  ok = false;
                  diag = e;
                  done = true;
                  0
                };
                Ok(pair) => {
                  ret_ty = pair.a;
                  cur = pair.b;
                  0
                };
              };
            };

            // ';' or '{' ... '}' ';'
            if ok == true {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(Error, fn_start, fn_start, "parser: expected ';' or function body block");
                  done = true;
                  0
                };
                Cons(cell6) => {
                  match cell6.head.kind {
                    Semicolon => {
                      cur = cell6.tail;
                      body = None;
                      0
                    };
                    LBrace => {
                      cur = cell6.tail;

                      let parsed_b: Result<Pair<S1Block, List<S1Token>>, S1Diagnostic> =
                        s1_parse_block(cur);
                      match parsed_b {
                        Err(e) => {
                          ok = false;
                          diag = e;
                          done = true;
                          0
                        };
                        Ok(pair) => {
                          body = Some(pair.a);
                          cur = pair.b;
                          0
                        };
                      };

                      if ok == true {
                        match cur {
                          Nil => {
                            ok = false;
                            diag = s1_diag(Error, fn_start, fn_start, "parser: expected ';' after function body");
                            done = true;
                            0
                          };
                          Cons(semi) => {
                            match semi.head.kind {
                              Semicolon => {
                                cur = semi.tail;
                                0
                              };
                              _ => {
                                ok = false;
                                diag = s1_diag(Error, semi.head.span.start, semi.head.span.end, "parser: expected ';' after function body");
                                done = true;
                                0
                              };
                            }
                          };
                        };
                      };

                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(Error, cell6.head.span.start, cell6.head.span.end, "parser: expected ';' or function body block");
                      done = true;
                      0
                    };
                  }
                };
              };
            };

            if ok == true {
              let params: List<S1Param> = s1_reverse_params(params_rev);
              let item: S1Item = Function(
                S1Function { name: fn_name; generics: generics; params: params; return_type: ret_ty; body: body; }
              );
              items_rev = Cons(ListCons<S1Item> { head: item; tail: items_rev; });
              0
            } else {
              0
            }
          };
          KwRecord => {
            // Parse: record <Ident> { <field_name> : <type_ident> ; ... } ;
            let rec_start: Int = cell0.head.span.start;
            cur = cell0.tail;

            let rec_name: Text = "";
            let rec_generics: List<S1GenericParam> = Nil;
            let fields_rev: List<S1RecordField> = Nil;

            // name
            match cur {
              Nil => {
                ok = false;
                diag = s1_diag(Error, rec_start, rec_start, "parser: expected record name");
                done = true;
                0
              };
              Cons(cell1) => {
                match cell1.head.kind {
                  Ident(name) => {
                    rec_name = name;
                    cur = cell1.tail;
                    0
                  };
                  _ => {
                    ok = false;
                    diag = s1_diag(
                      Error,
                      cell1.head.span.start,
                      cell1.head.span.end,
                      "parser: expected record name"
                    );
                    done = true;
                    0
                  };
                }
              };
            };

            // optional generics: <T, ...>
            if ok == true {
              match cur {
                Cons(g0) => {
                  match g0.head.kind {
                    LAngle => {
                      let parsed_g: Result<Pair<List<S1GenericParam>, List<S1Token>>, S1Diagnostic> =
                        s1_parse_generic_params(cur);
                      match parsed_g {
                        Err(e) => {
                          ok = false;
                          diag = e;
                          done = true;
                          0
                        };
                        Ok(pair) => {
                          rec_generics = pair.a;
                          cur = pair.b;
                          0
                        };
                      };
                      0
                    };
                    _ => 0;
                  }
                };
                _ => 0;
              };
            };

            // {
            if ok == true {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(Error, rec_start, rec_start, "parser: expected '{' after record name");
                  done = true;
                  0
                };
                Cons(cell2) => {
                  match cell2.head.kind {
                    LBrace => {
                      cur = cell2.tail;
                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(
                        Error,
                        cell2.head.span.start,
                        cell2.head.span.end,
                        "parser: expected '{' after record name"
                      );
                      done = true;
                      0
                    };
                  }
                };
              };
            };

            // fields until }
            if ok == true {
              let field_done: Bool = false;
              while field_done == false {
                match cur {
                  Nil => {
                    ok = false;
                    diag = s1_diag(Error, rec_start, rec_start, "parser: expected '}' to close record");
                    done = true;
                    field_done = true;
                    0
                  };
                  Cons(cellf0) => {
                    match cellf0.head.kind {
                      RBrace => {
                        cur = cellf0.tail;
                        field_done = true;
                        0
                      };
                      Ident(field_name) => {
                        let field_start: Int = cellf0.head.span.start;
                        cur = cellf0.tail;

                        // :
                        match cur {
                          Nil => {
                            ok = false;
                            diag = s1_diag(Error, field_start, field_start, "parser: expected ':' in record field");
                            done = true;
                            field_done = true;
                            0
                          };
                          Cons(cellf1) => {
                            match cellf1.head.kind {
                              Colon => {
                                cur = cellf1.tail;
                                0
                              };
                              _ => {
                                ok = false;
                                diag = s1_diag(
                                  Error,
                                  cellf1.head.span.start,
                                  cellf1.head.span.end,
                                  "parser: expected ':' in record field"
                                );
                                done = true;
                                field_done = true;
                                0
                              };
                            }
                          };
                        };

                        // type
                        let empty_args: List<S1Type> = Nil;
                        let field_ty: S1Type = S1Type { name: ""; args: empty_args; };
                        if ok == true {
                          let parsed: Result<Pair<S1Type, List<S1Token>>, S1Diagnostic> =
                            s1_parse_type(cur);
                          match parsed {
                            Err(e) => {
                              ok = false;
                              diag = e;
                              done = true;
                              field_done = true;
                              0
                            };
                            Ok(pair) => {
                              field_ty = pair.a;
                              cur = pair.b;
                              0
                            };
                          };
                        };

                        // ;
                        if ok == true {
                          match cur {
                            Nil => {
                              ok = false;
                              diag = s1_diag(Error, field_start, field_start, "parser: expected ';' after record field");
                              done = true;
                              field_done = true;
                              0
                            };
                            Cons(cellf3) => {
                              match cellf3.head.kind {
                                Semicolon => {
                                  cur = cellf3.tail;
                                  0
                                };
                                _ => {
                                  ok = false;
                                  diag = s1_diag(
                                    Error,
                                    cellf3.head.span.start,
                                    cellf3.head.span.end,
                                    "parser: expected ';' after record field"
                                  );
                                  done = true;
                                  field_done = true;
                                  0
                                };
                              }
                            };
                          };
                        };

                        if ok == true {
                          let field: S1RecordField =
                            S1RecordField { name: field_name; ty: field_ty; };
                          fields_rev =
                            Cons(ListCons<S1RecordField> { head: field; tail: fields_rev; });
                          0;
                        };
                        0
                      };
                      _ => {
                        ok = false;
                        diag = s1_diag(
                          Error,
                          cellf0.head.span.start,
                          cellf0.head.span.end,
                          "parser: expected record field or '}'"
                        );
                        done = true;
                        field_done = true;
                        0
                      };
                    }
                  };
                }
              };
            };

            // ;
            if ok == true {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(Error, rec_start, rec_start, "parser: expected ';' after record");
                  done = true;
                  0
                };
                Cons(cell_end) => {
                  match cell_end.head.kind {
                    Semicolon => {
                      cur = cell_end.tail;
                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(
                        Error,
                        cell_end.head.span.start,
                        cell_end.head.span.end,
                        "parser: expected ';' after record"
                      );
                      done = true;
                      0
                    };
                  }
                };
              };
            };

            if ok == true {
              let fields: List<S1RecordField> = s1_reverse_record_fields(fields_rev);
              let item: S1Item = Record(S1Record { name: rec_name; generics: rec_generics; fields: fields; });
              items_rev = Cons(ListCons<S1Item> { head: item; tail: items_rev; });
              0;
            };
            0
          };
          KwEnum => {
            // Parse: enum <Ident> { <Variant> ; <Variant>(<type_ident>) ; ... } ;
            let enum_start: Int = cell0.head.span.start;
            cur = cell0.tail;

            let enum_name: Text = "";
            let enum_generics: List<S1GenericParam> = Nil;
            let variants_rev: List<S1EnumVariant> = Nil;

            // name
            match cur {
              Nil => {
                ok = false;
                diag = s1_diag(Error, enum_start, enum_start, "parser: expected enum name");
                done = true;
                0
              };
              Cons(cell1) => {
                match cell1.head.kind {
                  Ident(name) => {
                    enum_name = name;
                    cur = cell1.tail;
                    0
                  };
                  _ => {
                    ok = false;
                    diag = s1_diag(
                      Error,
                      cell1.head.span.start,
                      cell1.head.span.end,
                      "parser: expected enum name"
                    );
                    done = true;
                    0
                  };
                }
              };
            };

            // optional generics: <T, ...>
            if ok == true {
              match cur {
                Cons(g0) => {
                  match g0.head.kind {
                    LAngle => {
                      let parsed_g: Result<Pair<List<S1GenericParam>, List<S1Token>>, S1Diagnostic> =
                        s1_parse_generic_params(cur);
                      match parsed_g {
                        Err(e) => {
                          ok = false;
                          diag = e;
                          done = true;
                          0
                        };
                        Ok(pair) => {
                          enum_generics = pair.a;
                          cur = pair.b;
                          0
                        };
                      };
                      0
                    };
                    _ => 0;
                  }
                };
                _ => 0;
              };
            };

            // {
            if ok == true {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(Error, enum_start, enum_start, "parser: expected '{' after enum name");
                  done = true;
                  0
                };
                Cons(cell2) => {
                  match cell2.head.kind {
                    LBrace => {
                      cur = cell2.tail;
                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(
                        Error,
                        cell2.head.span.start,
                        cell2.head.span.end,
                        "parser: expected '{' after enum name"
                      );
                      done = true;
                      0
                    };
                  }
                };
              };
            };

            // variants until }
            let variant_done: Bool = false;
            while variant_done == false {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(
                    Error,
                    enum_start,
                    enum_start,
                    "parser: expected enum variant or '}'"
                  );
                  done = true;
                  variant_done = true;
                  0
                };
                Cons(v0) => {
                  match v0.head.kind {
                    RBrace => {
                      cur = v0.tail;
                      variant_done = true;
                      0
                    };
                    Ident(vname) => {
                      cur = v0.tail;
                      let payload_ty: Option<S1Type> = None;

                      // optional payload: (Ty)
                      match cur {
                        Nil => 0;
                        Cons(v1) => {
                          match v1.head.kind {
                            LParen => {
                              cur = v1.tail;

                              let parsed: Result<Pair<S1Type, List<S1Token>>, S1Diagnostic> =
                                s1_parse_type(cur);
                              match parsed {
                                Err(e) => {
                                  ok = false;
                                  diag = e;
                                  done = true;
                                  variant_done = true;
                                  0
                                };
                                Ok(pair) => {
                                  payload_ty = Some(pair.a);
                                  cur = pair.b;
                                  0
                                };
                              };

                              if ok == true {
                                match cur {
                                  Nil => {
                                    ok = false;
                                    diag = s1_diag(
                                      Error,
                                      enum_start,
                                      enum_start,
                                      "parser: expected ')' after payload type"
                                    );
                                    done = true;
                                    variant_done = true;
                                    0
                                  };
                                  Cons(v3) => {
                                    match v3.head.kind {
                                      RParen => {
                                        cur = v3.tail;
                                        0
                                      };
                                      _ => {
                                        ok = false;
                                        diag = s1_diag(
                                          Error,
                                          v3.head.span.start,
                                          v3.head.span.end,
                                          "parser: expected ')' after payload type"
                                        );
                                        done = true;
                                        variant_done = true;
                                        0
                                      };
                                    }
                                  };
                                };
                              };
                              0
                            };
                            _ => 0;
                          }
                        };
                      };

                      if ok == true {
                        match cur {
                          Nil => {
                            ok = false;
                            diag = s1_diag(
                              Error,
                              enum_start,
                              enum_start,
                              "parser: expected ';' after enum variant"
                            );
                            done = true;
                            variant_done = true;
                            0
                          };
                          Cons(v4) => {
                            match v4.head.kind {
                              Semicolon => {
                                let variant: S1EnumVariant = S1EnumVariant {
                                  name: vname;
                                  payload_ty: payload_ty;
                                };
                                variants_rev = Cons(ListCons<S1EnumVariant> { head: variant; tail: variants_rev; });
                                cur = v4.tail;
                                0
                              };
                              _ => {
                                ok = false;
                                diag = s1_diag(
                                  Error,
                                  v4.head.span.start,
                                  v4.head.span.end,
                                  "parser: expected ';' after enum variant"
                                );
                                done = true;
                                variant_done = true;
                                0
                              };
                            }
                          };
                        };
                      };

                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(
                        Error,
                        v0.head.span.start,
                        v0.head.span.end,
                        "parser: expected enum variant or '}'"
                      );
                      done = true;
                      variant_done = true;
                      0
                    };
                  }
                };
              }
            };

            // ;
            if ok == true {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(Error, enum_start, enum_start, "parser: expected ';' after enum");
                  done = true;
                  0
                };
                Cons(cell_end) => {
                  match cell_end.head.kind {
                    Semicolon => {
                      cur = cell_end.tail;
                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(
                        Error,
                        cell_end.head.span.start,
                        cell_end.head.span.end,
                        "parser: expected ';' after enum"
                      );
                      done = true;
                      0
                    };
                  }
                };
              };
            };

            if ok == true {
              let variants: List<S1EnumVariant> = s1_reverse_enum_variants(variants_rev);
              let item: S1Item = Enum(S1Enum { name: enum_name; generics: enum_generics; variants: variants; });
              items_rev = Cons(ListCons<S1Item> { head: item; tail: items_rev; });
              0;
            };

            0
          };
          _ => {
            ok = false;
            diag = s1_diag(
              Error,
              cell0.head.span.start,
              cell0.head.span.end,
              "parser: unexpected token (expected 'import', 'record', 'enum', 'fn', or EOF)"
            );
            done = true;
            0
          };
        }
      };
    }
  };

  let out: Result<S1Program, S1Diagnostic> = Err(diag);
  if ok == true {
    let items: List<S1Item> = s1_reverse_items(items_rev);
    out = Ok(S1Program { items: items; });
    0;
  };
  out
};
