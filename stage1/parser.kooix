import "../stdlib/prelude";
import "diag";
import "token";
import "ast";

fn s1_reverse_items(xs: List<S1Item>) -> List<S1Item> {
  let acc: List<S1Item> = Nil;
  let cur: List<S1Item> = xs;
  let done: Bool = false;

  while done == false {
    match cur {
      Nil => {
        done = true;
        0
      };
      Cons(cell) => {
        acc = Cons(ListCons<S1Item> { head: cell.head; tail: acc; });
        cur = cell.tail;
        0
      };
    }
  };

  acc
};

fn s1_reverse_record_fields(xs: List<S1RecordField>) -> List<S1RecordField> {
  let acc: List<S1RecordField> = Nil;
  let cur: List<S1RecordField> = xs;
  let done: Bool = false;

  while done == false {
    match cur {
      Nil => {
        done = true;
        0
      };
      Cons(cell) => {
        acc = Cons(ListCons<S1RecordField> { head: cell.head; tail: acc; });
        cur = cell.tail;
        0
      };
    }
  };

  acc
};

fn s1_parse(tokens: List<S1Token>) -> Result<S1Program, S1Diagnostic>
intent "Stage1 parser (pure): tokens -> AST"
evidence {
  trace "stage1.parser.v0";
  metrics [stage1_parse_calls];
}
{
  let cur: List<S1Token> = tokens;
  let items_rev: List<S1Item> = Nil;

  let ok: Bool = true;
  let diag: S1Diagnostic = s1_diag(Error, 0, 0, "parser error");

  let done: Bool = false;
  while done == false {
    match cur {
      Nil => {
        ok = false;
        diag = s1_diag(Error, 0, 0, "parser: unexpected end of token stream");
        done = true;
        0
      };
      Cons(cell0) => {
        match cell0.head.kind {
          Eof => {
            done = true;
            0
          };
          KwImport => {
            // Parse: import <String> ;
            let imp_start: Int = cell0.head.span.start;
            cur = cell0.tail;

            let path: Text = "";

            match cur {
              Nil => {
                ok = false;
                diag = s1_diag(Error, imp_start, imp_start, "parser: expected import path string");
                done = true;
                0
              };
              Cons(cell1) => {
                match cell1.head.kind {
                  String(s) => {
                    path = s;
                    cur = cell1.tail;
                    0
                  };
                  _ => {
                    ok = false;
                    diag = s1_diag(Error, cell1.head.span.start, cell1.head.span.end, "parser: expected import path string");
                    done = true;
                    0
                  };
                }
              };
            };

            if ok == true {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(Error, imp_start, imp_start, "parser: expected ';' after import");
                  done = true;
                  0
                };
                Cons(cell2) => {
                  match cell2.head.kind {
                    Semicolon => {
                      cur = cell2.tail;
                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(Error, cell2.head.span.start, cell2.head.span.end, "parser: expected ';' after import");
                      done = true;
                      0
                    };
                  }
                };
              };
            };

            if ok == true {
              let item: S1Item = Import(S1Import { path: path; });
              items_rev = Cons(ListCons<S1Item> { head: item; tail: items_rev; });
              0;
            };
            0
          };
          KwFn => {
            // Parse: fn <Ident> ( ) -> <Ident> ;
            let fn_start: Int = cell0.head.span.start;
            cur = cell0.tail;

            let fn_name: Text = "";
            let ret_ty: Text = "";

            // name
            match cur {
              Nil => {
                ok = false;
                diag = s1_diag(Error, fn_start, fn_start, "parser: expected function name");
                done = true;
                0
              };
              Cons(cell1) => {
                match cell1.head.kind {
                  Ident(name) => {
                    fn_name = name;
                    cur = cell1.tail;
                    0
                  };
                  _ => {
                    ok = false;
                    diag = s1_diag(Error, cell1.head.span.start, cell1.head.span.end, "parser: expected function name");
                    done = true;
                    0
                  };
                }
              };
            };

            // (
            if ok == true {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(Error, fn_start, fn_start, "parser: expected '('");
                  done = true;
                  0
                };
                Cons(cell2) => {
                  match cell2.head.kind {
                    LParen => {
                      cur = cell2.tail;
                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(Error, cell2.head.span.start, cell2.head.span.end, "parser: expected '('");
                      done = true;
                      0
                    };
                  }
                };
              };
            };

            // )
            if ok == true {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(Error, fn_start, fn_start, "parser: expected ')'");
                  done = true;
                  0
                };
                Cons(cell3) => {
                  match cell3.head.kind {
                    RParen => {
                      cur = cell3.tail;
                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(Error, cell3.head.span.start, cell3.head.span.end, "parser: expected ')'");
                      done = true;
                      0
                    };
                  }
                };
              };
            };

            // ->
            if ok == true {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(Error, fn_start, fn_start, "parser: expected '->'");
                  done = true;
                  0
                };
                Cons(cell4) => {
                  match cell4.head.kind {
                    Arrow => {
                      cur = cell4.tail;
                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(Error, cell4.head.span.start, cell4.head.span.end, "parser: expected '->'");
                      done = true;
                      0
                    };
                  }
                };
              };
            };

            // return type
            if ok == true {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(Error, fn_start, fn_start, "parser: expected return type");
                  done = true;
                  0
                };
                Cons(cell5) => {
                  match cell5.head.kind {
                    Ident(name) => {
                      ret_ty = name;
                      cur = cell5.tail;
                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(Error, cell5.head.span.start, cell5.head.span.end, "parser: expected return type");
                      done = true;
                      0
                    };
                  }
                };
              };
            };

            // ;
            if ok == true {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(Error, fn_start, fn_start, "parser: expected ';'");
                  done = true;
                  0
                };
                Cons(cell6) => {
                  match cell6.head.kind {
                    Semicolon => {
                      cur = cell6.tail;
                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(Error, cell6.head.span.start, cell6.head.span.end, "parser: expected ';'");
                      done = true;
                      0
                    };
                  }
                };
              };
            };

            if ok == true {
              let item: S1Item = Function(S1Function { name: fn_name; return_type: ret_ty; });
              items_rev = Cons(ListCons<S1Item> { head: item; tail: items_rev; });
              0
            } else {
              0
            }
          };
          KwRecord => {
            // Parse: record <Ident> { <field_name> : <type_ident> ; ... } ;
            let rec_start: Int = cell0.head.span.start;
            cur = cell0.tail;

            let rec_name: Text = "";
            let fields_rev: List<S1RecordField> = Nil;

            // name
            match cur {
              Nil => {
                ok = false;
                diag = s1_diag(Error, rec_start, rec_start, "parser: expected record name");
                done = true;
                0
              };
              Cons(cell1) => {
                match cell1.head.kind {
                  Ident(name) => {
                    rec_name = name;
                    cur = cell1.tail;
                    0
                  };
                  _ => {
                    ok = false;
                    diag = s1_diag(
                      Error,
                      cell1.head.span.start,
                      cell1.head.span.end,
                      "parser: expected record name"
                    );
                    done = true;
                    0
                  };
                }
              };
            };

            // {
            if ok == true {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(Error, rec_start, rec_start, "parser: expected '{' after record name");
                  done = true;
                  0
                };
                Cons(cell2) => {
                  match cell2.head.kind {
                    LBrace => {
                      cur = cell2.tail;
                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(
                        Error,
                        cell2.head.span.start,
                        cell2.head.span.end,
                        "parser: expected '{' after record name"
                      );
                      done = true;
                      0
                    };
                  }
                };
              };
            };

            // fields until }
            if ok == true {
              let field_done: Bool = false;
              while field_done == false {
                match cur {
                  Nil => {
                    ok = false;
                    diag = s1_diag(Error, rec_start, rec_start, "parser: expected '}' to close record");
                    done = true;
                    field_done = true;
                    0
                  };
                  Cons(cellf0) => {
                    match cellf0.head.kind {
                      RBrace => {
                        cur = cellf0.tail;
                        field_done = true;
                        0
                      };
                      Ident(field_name) => {
                        let field_start: Int = cellf0.head.span.start;
                        cur = cellf0.tail;

                        // :
                        match cur {
                          Nil => {
                            ok = false;
                            diag = s1_diag(Error, field_start, field_start, "parser: expected ':' in record field");
                            done = true;
                            field_done = true;
                            0
                          };
                          Cons(cellf1) => {
                            match cellf1.head.kind {
                              Colon => {
                                cur = cellf1.tail;
                                0
                              };
                              _ => {
                                ok = false;
                                diag = s1_diag(
                                  Error,
                                  cellf1.head.span.start,
                                  cellf1.head.span.end,
                                  "parser: expected ':' in record field"
                                );
                                done = true;
                                field_done = true;
                                0
                              };
                            }
                          };
                        };

                        // type ident
                        let field_ty: Text = "";
                        if ok == true {
                          match cur {
                            Nil => {
                              ok = false;
                              diag = s1_diag(Error, field_start, field_start, "parser: expected type in record field");
                              done = true;
                              field_done = true;
                              0
                            };
                            Cons(cellf2) => {
                              match cellf2.head.kind {
                                Ident(ty_name) => {
                                  field_ty = ty_name;
                                  cur = cellf2.tail;
                                  0
                                };
                                _ => {
                                  ok = false;
                                  diag = s1_diag(
                                    Error,
                                    cellf2.head.span.start,
                                    cellf2.head.span.end,
                                    "parser: expected type in record field"
                                  );
                                  done = true;
                                  field_done = true;
                                  0
                                };
                              }
                            };
                          };
                        };

                        // ;
                        if ok == true {
                          match cur {
                            Nil => {
                              ok = false;
                              diag = s1_diag(Error, field_start, field_start, "parser: expected ';' after record field");
                              done = true;
                              field_done = true;
                              0
                            };
                            Cons(cellf3) => {
                              match cellf3.head.kind {
                                Semicolon => {
                                  cur = cellf3.tail;
                                  0
                                };
                                _ => {
                                  ok = false;
                                  diag = s1_diag(
                                    Error,
                                    cellf3.head.span.start,
                                    cellf3.head.span.end,
                                    "parser: expected ';' after record field"
                                  );
                                  done = true;
                                  field_done = true;
                                  0
                                };
                              }
                            };
                          };
                        };

                        if ok == true {
                          let field: S1RecordField =
                            S1RecordField { name: field_name; ty: field_ty; };
                          fields_rev =
                            Cons(ListCons<S1RecordField> { head: field; tail: fields_rev; });
                          0;
                        };
                        0
                      };
                      _ => {
                        ok = false;
                        diag = s1_diag(
                          Error,
                          cellf0.head.span.start,
                          cellf0.head.span.end,
                          "parser: expected record field or '}'"
                        );
                        done = true;
                        field_done = true;
                        0
                      };
                    }
                  };
                }
              };
            };

            // ;
            if ok == true {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(Error, rec_start, rec_start, "parser: expected ';' after record");
                  done = true;
                  0
                };
                Cons(cell_end) => {
                  match cell_end.head.kind {
                    Semicolon => {
                      cur = cell_end.tail;
                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(
                        Error,
                        cell_end.head.span.start,
                        cell_end.head.span.end,
                        "parser: expected ';' after record"
                      );
                      done = true;
                      0
                    };
                  }
                };
              };
            };

            if ok == true {
              let fields: List<S1RecordField> = s1_reverse_record_fields(fields_rev);
              let item: S1Item = Record(S1Record { name: rec_name; fields: fields; });
              items_rev = Cons(ListCons<S1Item> { head: item; tail: items_rev; });
              0;
            };
            0
          };
          _ => {
            ok = false;
            diag = s1_diag(
              Error,
              cell0.head.span.start,
              cell0.head.span.end,
              "parser: unexpected token (expected 'import', 'record', 'fn', or EOF)"
            );
            done = true;
            0
          };
        }
      };
    }
  };

  let out: Result<S1Program, S1Diagnostic> = Err(diag);
  if ok == true {
    let items: List<S1Item> = s1_reverse_items(items_rev);
    out = Ok(S1Program { items: items; });
  };
  out
};
