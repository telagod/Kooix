import "../stdlib/prelude";
import "diag";
import "token";
import "ast";

fn s1_reverse_items(xs: List<S1Item>) -> List<S1Item> {
  let acc: List<S1Item> = Nil;
  let cur: List<S1Item> = xs;
  let done: Bool = false;

  while done == false {
    match cur {
      Nil => {
        done = true;
        0
      };
      Cons(cell) => {
        acc = Cons(ListCons<S1Item> { head: cell.head; tail: acc; });
        cur = cell.tail;
        0
      };
    }
  };

  acc
};

fn s1_reverse_record_fields(xs: List<S1RecordField>) -> List<S1RecordField> {
  let acc: List<S1RecordField> = Nil;
  let cur: List<S1RecordField> = xs;
  let done: Bool = false;

  while done == false {
    match cur {
      Nil => {
        done = true;
        0
      };
      Cons(cell) => {
        acc = Cons(ListCons<S1RecordField> { head: cell.head; tail: acc; });
        cur = cell.tail;
        0
      };
    }
  };

  acc
};

fn s1_reverse_enum_variants(xs: List<S1EnumVariant>) -> List<S1EnumVariant> {
  let acc: List<S1EnumVariant> = Nil;
  let cur: List<S1EnumVariant> = xs;
  let done: Bool = false;

  while done == false {
    match cur {
      Nil => {
        done = true;
        0
      };
      Cons(cell) => {
        acc = Cons(ListCons<S1EnumVariant> { head: cell.head; tail: acc; });
        cur = cell.tail;
        0
      };
    }
  };

  acc
};

fn s1_reverse_types(xs: List<S1Type>) -> List<S1Type> {
  let acc: List<S1Type> = Nil;
  let cur: List<S1Type> = xs;
  let done: Bool = false;

  while done == false {
    match cur {
      Nil => {
        done = true;
        0
      };
      Cons(cell) => {
        acc = Cons(ListCons<S1Type> { head: cell.head; tail: acc; });
        cur = cell.tail;
        0
      };
    }
  };

  acc
};

fn s1_reverse_params(xs: List<S1Param>) -> List<S1Param> {
  let acc: List<S1Param> = Nil;
  let cur: List<S1Param> = xs;
  let done: Bool = false;

  while done == false {
    match cur {
      Nil => {
        done = true;
        0
      };
      Cons(cell) => {
        acc = Cons(ListCons<S1Param> { head: cell.head; tail: acc; });
        cur = cell.tail;
        0
      };
    }
  };

  acc
};

fn s1_parse_type(tokens: List<S1Token>) -> Result<Pair<S1Type, List<S1Token>>, S1Diagnostic> {
  let ok: Bool = true;
  let diag: S1Diagnostic = s1_diag(Error, 0, 0, "parser: expected type");

  let empty_args: List<S1Type> = Nil;
  let ty: S1Type = S1Type { name: ""; args: empty_args; };
  let rest: List<S1Token> = tokens;

  match tokens {
    Nil => {
      ok = false;
      0
    };
    Cons(cell0) => {
      match cell0.head.kind {
        Ident(name) => {
          ty = S1Type { name: name; args: empty_args; };
          rest = cell0.tail;
          0
        };
        _ => {
          ok = false;
          diag = s1_diag(
            Error,
            cell0.head.span.start,
            cell0.head.span.end,
            "parser: expected type"
          );
          0
        };
      }
    };
  };

  if ok == true {
    match rest {
      Cons(cell1) => {
        match cell1.head.kind {
          LAngle => {
            rest = cell1.tail;
            let args_rev: List<S1Type> = Nil;

            let args_done: Bool = false;
            while args_done == false {
              let parsed: Result<Pair<S1Type, List<S1Token>>, S1Diagnostic> =
                s1_parse_type(rest);
              match parsed {
                Err(e) => {
                  ok = false;
                  diag = e;
                  args_done = true;
                  0
                };
                Ok(pair) => {
                  args_rev =
                    Cons(ListCons<S1Type> { head: pair.a; tail: args_rev; });
                  rest = pair.b;
                  0
                };
              };

              if ok == true {
                match rest {
                  Nil => {
                    ok = false;
                    diag = s1_diag(
                      Error,
                      cell1.head.span.start,
                      cell1.head.span.end,
                      "parser: expected ',' or '>' after type argument"
                    );
                    args_done = true;
                    0
                  };
                  Cons(cell2) => {
                    match cell2.head.kind {
                      Comma => {
                        rest = cell2.tail;
                        0
                      };
                      RAngle => {
                        rest = cell2.tail;
                        args_done = true;
                        0
                      };
                      _ => {
                        ok = false;
                        diag = s1_diag(
                          Error,
                          cell2.head.span.start,
                          cell2.head.span.end,
                          "parser: expected ',' or '>' after type argument"
                        );
                        args_done = true;
                        0
                      };
                    }
                  };
                }
              } else {
                0
              }
            };

            if ok == true {
              let args: List<S1Type> = s1_reverse_types(args_rev);
              ty = S1Type { name: ty.name; args: args; };
              0
            } else {
              0
            }
          };
          _ => 0;
        }
      };
      _ => 0;
    }
  } else {
    0
  };

  let out: Result<Pair<S1Type, List<S1Token>>, S1Diagnostic> = Err(diag);
  if ok == true {
    out = Ok(Pair<S1Type, List<S1Token>> { a: ty; b: rest; });
  };
  out
};

fn s1_parse(tokens: List<S1Token>) -> Result<S1Program, S1Diagnostic>
intent "Stage1 parser (pure): tokens -> AST"
evidence {
  trace "stage1.parser.v0";
  metrics [stage1_parse_calls];
}
{
  let cur: List<S1Token> = tokens;
  let items_rev: List<S1Item> = Nil;

  let ok: Bool = true;
  let diag: S1Diagnostic = s1_diag(Error, 0, 0, "parser error");

  let done: Bool = false;
  while done == false {
    match cur {
      Nil => {
        ok = false;
        diag = s1_diag(Error, 0, 0, "parser: unexpected end of token stream");
        done = true;
        0
      };
      Cons(cell0) => {
        match cell0.head.kind {
          Eof => {
            done = true;
            0
          };
          KwImport => {
            // Parse: import <String> ;
            let imp_start: Int = cell0.head.span.start;
            cur = cell0.tail;

            let path: Text = "";

            match cur {
              Nil => {
                ok = false;
                diag = s1_diag(Error, imp_start, imp_start, "parser: expected import path string");
                done = true;
                0
              };
              Cons(cell1) => {
                match cell1.head.kind {
                  String(s) => {
                    path = s;
                    cur = cell1.tail;
                    0
                  };
                  _ => {
                    ok = false;
                    diag = s1_diag(Error, cell1.head.span.start, cell1.head.span.end, "parser: expected import path string");
                    done = true;
                    0
                  };
                }
              };
            };

            if ok == true {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(Error, imp_start, imp_start, "parser: expected ';' after import");
                  done = true;
                  0
                };
                Cons(cell2) => {
                  match cell2.head.kind {
                    Semicolon => {
                      cur = cell2.tail;
                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(Error, cell2.head.span.start, cell2.head.span.end, "parser: expected ';' after import");
                      done = true;
                      0
                    };
                  }
                };
              };
            };

            if ok == true {
              let item: S1Item = Import(S1Import { path: path; });
              items_rev = Cons(ListCons<S1Item> { head: item; tail: items_rev; });
              0;
            };
            0
          };
          KwFn => {
            // Parse: fn <Ident> ( <params>? ) -> <type> ( ';' | <block> ';' )
            let fn_start: Int = cell0.head.span.start;
            cur = cell0.tail;

            let fn_name: Text = "";
            let params_rev: List<S1Param> = Nil;
            let empty_args: List<S1Type> = Nil;
            let ret_ty: S1Type = S1Type { name: ""; args: empty_args; };
            let has_body: Bool = false;

            // name
            match cur {
              Nil => {
                ok = false;
                diag = s1_diag(Error, fn_start, fn_start, "parser: expected function name");
                done = true;
                0
              };
              Cons(cell1) => {
                match cell1.head.kind {
                  Ident(name) => {
                    fn_name = name;
                    cur = cell1.tail;
                    0
                  };
                  _ => {
                    ok = false;
                    diag = s1_diag(Error, cell1.head.span.start, cell1.head.span.end, "parser: expected function name");
                    done = true;
                    0
                  };
                }
              };
            };

            // (
            if ok == true {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(Error, fn_start, fn_start, "parser: expected '('");
                  done = true;
                  0
                };
                Cons(cell2) => {
                  match cell2.head.kind {
                    LParen => {
                      cur = cell2.tail;
                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(Error, cell2.head.span.start, cell2.head.span.end, "parser: expected '('");
                      done = true;
                      0
                    };
                  }
                };
              };
            };

            // params? )
            if ok == true {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(Error, fn_start, fn_start, "parser: expected ')' or parameter");
                  done = true;
                  0
                };
                Cons(cell3) => {
                  match cell3.head.kind {
                    RParen => {
                      cur = cell3.tail;
                      0
                    };
                    _ => {
                      let params_done: Bool = false;
                      while params_done == false {
                        let p_name: Text = "";
                        let p_ty: S1Type = S1Type { name: ""; args: empty_args; };

                        // param name
                        match cur {
                          Nil => {
                            ok = false;
                            diag = s1_diag(Error, fn_start, fn_start, "parser: expected parameter name");
                            done = true;
                            params_done = true;
                            0
                          };
                          Cons(p0) => {
                            match p0.head.kind {
                              Ident(name) => {
                                p_name = name;
                                cur = p0.tail;
                                0
                              };
                              _ => {
                                ok = false;
                                diag = s1_diag(Error, p0.head.span.start, p0.head.span.end, "parser: expected parameter name");
                                done = true;
                                params_done = true;
                                0
                              };
                            }
                          };
                        };

                        // :
                        if ok == true {
                          match cur {
                            Nil => {
                              ok = false;
                              diag = s1_diag(Error, fn_start, fn_start, "parser: expected ':' after parameter name");
                              done = true;
                              params_done = true;
                              0
                            };
                            Cons(p1) => {
                              match p1.head.kind {
                                Colon => {
                                  cur = p1.tail;
                                  0
                                };
                                _ => {
                                  ok = false;
                                  diag = s1_diag(Error, p1.head.span.start, p1.head.span.end, "parser: expected ':' after parameter name");
                                  done = true;
                                  params_done = true;
                                  0
                                };
                              }
                            };
                          };
                        };

                        // type
                        if ok == true {
                          let parsed: Result<Pair<S1Type, List<S1Token>>, S1Diagnostic> =
                            s1_parse_type(cur);
                          match parsed {
                            Err(e) => {
                              ok = false;
                              diag = e;
                              done = true;
                              params_done = true;
                              0
                            };
                            Ok(pair) => {
                              p_ty = pair.a;
                              cur = pair.b;
                              0
                            };
                          };
                        };

                        if ok == true {
                          let param: S1Param = S1Param { name: p_name; ty: p_ty; };
                          params_rev =
                            Cons(ListCons<S1Param> { head: param; tail: params_rev; });
                          0;
                        };

                        // , or )
                        if ok == true {
                          match cur {
                            Nil => {
                              ok = false;
                              diag = s1_diag(Error, fn_start, fn_start, "parser: expected ',' or ')' after parameter");
                              done = true;
                              params_done = true;
                              0
                            };
                            Cons(p2) => {
                              match p2.head.kind {
                                Comma => {
                                  cur = p2.tail;
                                  0
                                };
                                RParen => {
                                  cur = p2.tail;
                                  params_done = true;
                                  0
                                };
                                _ => {
                                  ok = false;
                                  diag = s1_diag(Error, p2.head.span.start, p2.head.span.end, "parser: expected ',' or ')' after parameter");
                                  done = true;
                                  params_done = true;
                                  0
                                };
                              }
                            };
                          };
                        };
                      };
                      0
                    };
                  }
                };
              };
            };

            // ->
            if ok == true {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(Error, fn_start, fn_start, "parser: expected '->'");
                  done = true;
                  0
                };
                Cons(cell4) => {
                  match cell4.head.kind {
                    Arrow => {
                      cur = cell4.tail;
                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(Error, cell4.head.span.start, cell4.head.span.end, "parser: expected '->'");
                      done = true;
                      0
                    };
                  }
                };
              };
            };

            // return type
            if ok == true {
              let parsed: Result<Pair<S1Type, List<S1Token>>, S1Diagnostic> = s1_parse_type(cur);
              match parsed {
                Err(e) => {
                  ok = false;
                  diag = e;
                  done = true;
                  0
                };
                Ok(pair) => {
                  ret_ty = pair.a;
                  cur = pair.b;
                  0
                };
              };
            };

            // ';' or '{' ... '}' ';'
            if ok == true {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(Error, fn_start, fn_start, "parser: expected ';' or function body block");
                  done = true;
                  0
                };
                Cons(cell6) => {
                  match cell6.head.kind {
                    Semicolon => {
                      cur = cell6.tail;
                      has_body = false;
                      0
                    };
                    LBrace => {
                      has_body = true;
                      cur = cell6.tail;

                      let empty_stack: List<Int> = Nil;
                      let stack: List<Int> =
                        Cons(ListCons<Int> { head: 0; tail: empty_stack; });
                      let scanning: Bool = true;
                      while scanning == true {
                        match cur {
                          Nil => {
                            ok = false;
                            diag = s1_diag(Error, fn_start, fn_start, "parser: expected '}' to close function body");
                            done = true;
                            scanning = false;
                            0
                          };
                          Cons(b0) => {
                            match b0.head.kind {
                              LBrace => {
                                stack =
                                  Cons(ListCons<Int> { head: 0; tail: stack; });
                                cur = b0.tail;
                                0
                              };
                              RBrace => {
                                match stack {
                                  Nil => {
                                    ok = false;
                                    diag = s1_diag(Error, fn_start, fn_start, "parser: unexpected '}' in function body");
                                    done = true;
                                    scanning = false;
                                    0
                                  };
                                  Cons(s0) => {
                                    stack = s0.tail;
                                    cur = b0.tail;
                                    match stack {
                                      Nil => {
                                        scanning = false;
                                        0
                                      };
                                      _ => 0;
                                    }
                                  };
                                }
                              };
                              _ => {
                                cur = b0.tail;
                                0
                              };
                            }
                          };
                        }
                      };

                      if ok == true {
                        match cur {
                          Nil => {
                            ok = false;
                            diag = s1_diag(Error, fn_start, fn_start, "parser: expected ';' after function body");
                            done = true;
                            0
                          };
                          Cons(semi) => {
                            match semi.head.kind {
                              Semicolon => {
                                cur = semi.tail;
                                0
                              };
                              _ => {
                                ok = false;
                                diag = s1_diag(Error, semi.head.span.start, semi.head.span.end, "parser: expected ';' after function body");
                                done = true;
                                0
                              };
                            }
                          };
                        };
                      };

                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(Error, cell6.head.span.start, cell6.head.span.end, "parser: expected ';' or function body block");
                      done = true;
                      0
                    };
                  }
                };
              };
            };

            if ok == true {
              let params: List<S1Param> = s1_reverse_params(params_rev);
              let item: S1Item = Function(
                S1Function { name: fn_name; params: params; return_type: ret_ty; has_body: has_body; }
              );
              items_rev = Cons(ListCons<S1Item> { head: item; tail: items_rev; });
              0
            } else {
              0
            }
          };
          KwRecord => {
            // Parse: record <Ident> { <field_name> : <type_ident> ; ... } ;
            let rec_start: Int = cell0.head.span.start;
            cur = cell0.tail;

            let rec_name: Text = "";
            let fields_rev: List<S1RecordField> = Nil;

            // name
            match cur {
              Nil => {
                ok = false;
                diag = s1_diag(Error, rec_start, rec_start, "parser: expected record name");
                done = true;
                0
              };
              Cons(cell1) => {
                match cell1.head.kind {
                  Ident(name) => {
                    rec_name = name;
                    cur = cell1.tail;
                    0
                  };
                  _ => {
                    ok = false;
                    diag = s1_diag(
                      Error,
                      cell1.head.span.start,
                      cell1.head.span.end,
                      "parser: expected record name"
                    );
                    done = true;
                    0
                  };
                }
              };
            };

            // {
            if ok == true {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(Error, rec_start, rec_start, "parser: expected '{' after record name");
                  done = true;
                  0
                };
                Cons(cell2) => {
                  match cell2.head.kind {
                    LBrace => {
                      cur = cell2.tail;
                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(
                        Error,
                        cell2.head.span.start,
                        cell2.head.span.end,
                        "parser: expected '{' after record name"
                      );
                      done = true;
                      0
                    };
                  }
                };
              };
            };

            // fields until }
            if ok == true {
              let field_done: Bool = false;
              while field_done == false {
                match cur {
                  Nil => {
                    ok = false;
                    diag = s1_diag(Error, rec_start, rec_start, "parser: expected '}' to close record");
                    done = true;
                    field_done = true;
                    0
                  };
                  Cons(cellf0) => {
                    match cellf0.head.kind {
                      RBrace => {
                        cur = cellf0.tail;
                        field_done = true;
                        0
                      };
                      Ident(field_name) => {
                        let field_start: Int = cellf0.head.span.start;
                        cur = cellf0.tail;

                        // :
                        match cur {
                          Nil => {
                            ok = false;
                            diag = s1_diag(Error, field_start, field_start, "parser: expected ':' in record field");
                            done = true;
                            field_done = true;
                            0
                          };
                          Cons(cellf1) => {
                            match cellf1.head.kind {
                              Colon => {
                                cur = cellf1.tail;
                                0
                              };
                              _ => {
                                ok = false;
                                diag = s1_diag(
                                  Error,
                                  cellf1.head.span.start,
                                  cellf1.head.span.end,
                                  "parser: expected ':' in record field"
                                );
                                done = true;
                                field_done = true;
                                0
                              };
                            }
                          };
                        };

                        // type
                        let empty_args: List<S1Type> = Nil;
                        let field_ty: S1Type = S1Type { name: ""; args: empty_args; };
                        if ok == true {
                          let parsed: Result<Pair<S1Type, List<S1Token>>, S1Diagnostic> =
                            s1_parse_type(cur);
                          match parsed {
                            Err(e) => {
                              ok = false;
                              diag = e;
                              done = true;
                              field_done = true;
                              0
                            };
                            Ok(pair) => {
                              field_ty = pair.a;
                              cur = pair.b;
                              0
                            };
                          };
                        };

                        // ;
                        if ok == true {
                          match cur {
                            Nil => {
                              ok = false;
                              diag = s1_diag(Error, field_start, field_start, "parser: expected ';' after record field");
                              done = true;
                              field_done = true;
                              0
                            };
                            Cons(cellf3) => {
                              match cellf3.head.kind {
                                Semicolon => {
                                  cur = cellf3.tail;
                                  0
                                };
                                _ => {
                                  ok = false;
                                  diag = s1_diag(
                                    Error,
                                    cellf3.head.span.start,
                                    cellf3.head.span.end,
                                    "parser: expected ';' after record field"
                                  );
                                  done = true;
                                  field_done = true;
                                  0
                                };
                              }
                            };
                          };
                        };

                        if ok == true {
                          let field: S1RecordField =
                            S1RecordField { name: field_name; ty: field_ty; };
                          fields_rev =
                            Cons(ListCons<S1RecordField> { head: field; tail: fields_rev; });
                          0;
                        };
                        0
                      };
                      _ => {
                        ok = false;
                        diag = s1_diag(
                          Error,
                          cellf0.head.span.start,
                          cellf0.head.span.end,
                          "parser: expected record field or '}'"
                        );
                        done = true;
                        field_done = true;
                        0
                      };
                    }
                  };
                }
              };
            };

            // ;
            if ok == true {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(Error, rec_start, rec_start, "parser: expected ';' after record");
                  done = true;
                  0
                };
                Cons(cell_end) => {
                  match cell_end.head.kind {
                    Semicolon => {
                      cur = cell_end.tail;
                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(
                        Error,
                        cell_end.head.span.start,
                        cell_end.head.span.end,
                        "parser: expected ';' after record"
                      );
                      done = true;
                      0
                    };
                  }
                };
              };
            };

            if ok == true {
              let fields: List<S1RecordField> = s1_reverse_record_fields(fields_rev);
              let item: S1Item = Record(S1Record { name: rec_name; fields: fields; });
              items_rev = Cons(ListCons<S1Item> { head: item; tail: items_rev; });
              0;
            };
            0
          };
          KwEnum => {
            // Parse: enum <Ident> { <Variant> ; <Variant>(<type_ident>) ; ... } ;
            let enum_start: Int = cell0.head.span.start;
            cur = cell0.tail;

            let enum_name: Text = "";
            let variants_rev: List<S1EnumVariant> = Nil;

            // name
            match cur {
              Nil => {
                ok = false;
                diag = s1_diag(Error, enum_start, enum_start, "parser: expected enum name");
                done = true;
                0
              };
              Cons(cell1) => {
                match cell1.head.kind {
                  Ident(name) => {
                    enum_name = name;
                    cur = cell1.tail;
                    0
                  };
                  _ => {
                    ok = false;
                    diag = s1_diag(
                      Error,
                      cell1.head.span.start,
                      cell1.head.span.end,
                      "parser: expected enum name"
                    );
                    done = true;
                    0
                  };
                }
              };
            };

            // {
            if ok == true {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(Error, enum_start, enum_start, "parser: expected '{' after enum name");
                  done = true;
                  0
                };
                Cons(cell2) => {
                  match cell2.head.kind {
                    LBrace => {
                      cur = cell2.tail;
                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(
                        Error,
                        cell2.head.span.start,
                        cell2.head.span.end,
                        "parser: expected '{' after enum name"
                      );
                      done = true;
                      0
                    };
                  }
                };
              };
            };

            // variants until }
            let variant_done: Bool = false;
            while variant_done == false {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(
                    Error,
                    enum_start,
                    enum_start,
                    "parser: expected enum variant or '}'"
                  );
                  done = true;
                  variant_done = true;
                  0
                };
                Cons(v0) => {
                  match v0.head.kind {
                    RBrace => {
                      cur = v0.tail;
                      variant_done = true;
                      0
                    };
                    Ident(vname) => {
                      cur = v0.tail;
                      let payload_ty: Option<S1Type> = None;

                      // optional payload: (Ty)
                      match cur {
                        Nil => 0;
                        Cons(v1) => {
                          match v1.head.kind {
                            LParen => {
                              cur = v1.tail;

                              let parsed: Result<Pair<S1Type, List<S1Token>>, S1Diagnostic> =
                                s1_parse_type(cur);
                              match parsed {
                                Err(e) => {
                                  ok = false;
                                  diag = e;
                                  done = true;
                                  variant_done = true;
                                  0
                                };
                                Ok(pair) => {
                                  payload_ty = Some(pair.a);
                                  cur = pair.b;
                                  0
                                };
                              };

                              if ok == true {
                                match cur {
                                  Nil => {
                                    ok = false;
                                    diag = s1_diag(
                                      Error,
                                      enum_start,
                                      enum_start,
                                      "parser: expected ')' after payload type"
                                    );
                                    done = true;
                                    variant_done = true;
                                    0
                                  };
                                  Cons(v3) => {
                                    match v3.head.kind {
                                      RParen => {
                                        cur = v3.tail;
                                        0
                                      };
                                      _ => {
                                        ok = false;
                                        diag = s1_diag(
                                          Error,
                                          v3.head.span.start,
                                          v3.head.span.end,
                                          "parser: expected ')' after payload type"
                                        );
                                        done = true;
                                        variant_done = true;
                                        0
                                      };
                                    }
                                  };
                                };
                              };
                              0
                            };
                            _ => 0;
                          }
                        };
                      };

                      if ok == true {
                        match cur {
                          Nil => {
                            ok = false;
                            diag = s1_diag(
                              Error,
                              enum_start,
                              enum_start,
                              "parser: expected ';' after enum variant"
                            );
                            done = true;
                            variant_done = true;
                            0
                          };
                          Cons(v4) => {
                            match v4.head.kind {
                              Semicolon => {
                                let variant: S1EnumVariant = S1EnumVariant {
                                  name: vname;
                                  payload_ty: payload_ty;
                                };
                                variants_rev = Cons(ListCons<S1EnumVariant> { head: variant; tail: variants_rev; });
                                cur = v4.tail;
                                0
                              };
                              _ => {
                                ok = false;
                                diag = s1_diag(
                                  Error,
                                  v4.head.span.start,
                                  v4.head.span.end,
                                  "parser: expected ';' after enum variant"
                                );
                                done = true;
                                variant_done = true;
                                0
                              };
                            }
                          };
                        };
                      };

                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(
                        Error,
                        v0.head.span.start,
                        v0.head.span.end,
                        "parser: expected enum variant or '}'"
                      );
                      done = true;
                      variant_done = true;
                      0
                    };
                  }
                };
              }
            };

            // ;
            if ok == true {
              match cur {
                Nil => {
                  ok = false;
                  diag = s1_diag(Error, enum_start, enum_start, "parser: expected ';' after enum");
                  done = true;
                  0
                };
                Cons(cell_end) => {
                  match cell_end.head.kind {
                    Semicolon => {
                      cur = cell_end.tail;
                      0
                    };
                    _ => {
                      ok = false;
                      diag = s1_diag(
                        Error,
                        cell_end.head.span.start,
                        cell_end.head.span.end,
                        "parser: expected ';' after enum"
                      );
                      done = true;
                      0
                    };
                  }
                };
              };
            };

            if ok == true {
              let variants: List<S1EnumVariant> = s1_reverse_enum_variants(variants_rev);
              let item: S1Item = Enum(S1Enum { name: enum_name; variants: variants; });
              items_rev = Cons(ListCons<S1Item> { head: item; tail: items_rev; });
              0;
            };

            0
          };
          _ => {
            ok = false;
            diag = s1_diag(
              Error,
              cell0.head.span.start,
              cell0.head.span.end,
              "parser: unexpected token (expected 'import', 'record', 'enum', 'fn', or EOF)"
            );
            done = true;
            0
          };
        }
      };
    }
  };

  let out: Result<S1Program, S1Diagnostic> = Err(diag);
  if ok == true {
    let items: List<S1Item> = s1_reverse_items(items_rev);
    out = Ok(S1Program { items: items; });
  };
  out
};
