import "../stdlib/prelude";
import "diag";
import "token";

fn s1_reverse_tokens(xs: List<S1Token>) -> List<S1Token> {
  let acc: List<S1Token> = Nil;
  let cur: List<S1Token> = xs;
  let done: Bool = false;

  while done == false {
    match cur {
      Nil => {
        done = true;
        0
      };
      Cons(cell) => {
        acc = Cons(ListCons<S1Token> { head: cell.head; tail: acc; });
        cur = cell.tail;
        0
      };
    }
  };

  acc
};

fn s1_keyword_or_ident(lexeme: Text) -> S1TokenKind {
  if lexeme == "fn" { KwFn } else {
    if lexeme == "record" { KwRecord } else {
      if lexeme == "enum" { KwEnum } else {
        if lexeme == "import" { KwImport } else {
          if lexeme == "as" { KwAs } else {
            if lexeme == "let" { KwLet } else {
              if lexeme == "return" { KwReturn } else {
                if lexeme == "if" { KwIf } else {
                  if lexeme == "else" { KwElse } else {
                    if lexeme == "while" { KwWhile } else {
                      if lexeme == "match" { KwMatch } else {
                        Ident(lexeme)
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
};

fn s1_lex_unescape_string(raw: Text, base: Int) -> Result<Text, S1Diagnostic> {
  let out: Text = "";
  let ot: Text = out;
  let i: Int = 0;
  let n: Int = text_len(raw);
  let done: Bool = false;
  let ok: Bool = true;
  let diag: S1Diagnostic = s1_diag(Error, base, base, "lexer: invalid escape sequence");

  while done == false {
    if i == n {
      done = true;
      0
    } else {
      match text_byte_at(raw, i) {
        None => {
          done = true;
          0
        };
        Some(b) => {
          if b == 92 {
            match text_byte_at(raw, i + 1) {
              None => {
                ok = false;
                diag = s1_diag(Error, base + i, base + i + 1, "lexer: invalid escape sequence");
                done = true;
                0
              };
              Some(b2) => {
                if b2 == 110 { ot = text_concat(ot, "\n"); i = i + 2; 0 } else {
                  if b2 == 114 { ot = text_concat(ot, "\r"); i = i + 2; 0 } else {
                    if b2 == 116 { ot = text_concat(ot, "\t"); i = i + 2; 0 } else {
                      if b2 == 34 { ot = text_concat(ot, "\""); i = i + 2; 0 } else {
                        if b2 == 92 { ot = text_concat(ot, "\\"); i = i + 2; 0 } else {
                          ok = false;
                          diag = s1_diag(Error, base + i, base + i + 2, "lexer: unknown escape sequence");
                          done = true;
                          0
                        }
                      }
                    }
                  }
                };
                0
              };
            }
          } else {
            match text_slice(raw, i, i + 1) {
              None => {
                ok = false;
                diag = s1_diag(Error, base + i, base + i + 1, "lexer: invalid string slice");
                done = true;
                0
              };
              Some(ch) => {
                ot = text_concat(ot, ch);
                i = i + 1;
                0
              };
            }
          };
          0
        };
      }
    }
  };

  let r: Result<Text, S1Diagnostic> = Err(diag);
  if ok == true { r = Ok(ot); 0 } else { r = Err(diag); 0 };
  r
};

fn s1_lex(source: Text) -> Result<List<S1Token>, S1Diagnostic>
intent "Stage1 lexer (pure): source -> tokens"
evidence {
  trace "stage1.lexer.v0";
  metrics [stage1_lex_calls];
}
{
  let n: Int = text_len(source);
  let i: Int = 0;
  let tokens_rev: List<S1Token> = Nil;

  let running: Bool = true;
  let ok: Bool = true;
  let diag: S1Diagnostic = s1_diag(Error, 0, 0, "lexer error");

  while running == true {
    if i == n {
      running = false;
      0
    } else {
      // Skip whitespace (ASCII only).
      let skipping: Bool = true;
      while skipping == true {
        if i == n {
          skipping = false;
          0
        } else {
          let byte_opt: Option<Int> = text_byte_at(source, i);
          match byte_opt {
            Some(b) => {
              if byte_is_ascii_whitespace(b) {
                i = i + 1;
                0
              } else {
                if b == 47 {
                  // Line comment: //
                  let next: Option<Int> = text_byte_at(source, i + 1);
                  match next {
                    Some(b2) => {
                      if b2 == 47 {
                        i = i + 2;
                        let scan: Bool = true;
                        while scan == true {
                          if i == n {
                            scan = false;
                            0
                          } else {
                            let b3_opt: Option<Int> = text_byte_at(source, i);
                            match b3_opt {
                              None => {
                                i = n;
                                scan = false;
                                0
                              };
                              Some(b3) => {
                                if b3 == 10 {
                                  i = i + 1;
                                  scan = false;
                                  0
                                } else {
                                  i = i + 1;
                                  0
                                }
                              };
                            }
                          }
                        };
                        0
                      } else {
                        skipping = false;
                        0
                      }
                    };
                    None => {
                      skipping = false;
                      0
                    };
                  }
                } else {
                  skipping = false;
                  0
                }
              }
            };
            None => {
              skipping = false;
              i = n;
              0
            };
          }
        }
      };

      if i == n {
        // End after whitespace.
        running = false;
        0
      } else {
        let byte_opt2: Option<Int> = text_byte_at(source, i);
        match byte_opt2 {
          None => {
            running = false;
            0
          };
          Some(b0) => {
            if b0 == 34 {
              // String literal: "...." (supports basic escapes).
              let start: Int = i;
              let j: Int = i + 1;
              let scanning: Bool = true;
              let closed: Bool = false;

              while scanning == true {
                if j == n {
                  scanning = false;
                  ok = false;
                  diag = s1_diag(Error, start, n, "lexer: unterminated string literal");
                  running = false;
                  0
                } else {
                  let bopt: Option<Int> = text_byte_at(source, j);
                  match bopt {
                    None => {
                      scanning = false;
                      ok = false;
                      diag = s1_diag(Error, start, n, "lexer: unterminated string literal");
                      running = false;
                      0
                    };
                    Some(b1) => {
                      if b1 == 92 {
                        // Skip escaped byte.
                        match text_byte_at(source, j + 1) {
                          None => {
                            scanning = false;
                            ok = false;
                            diag = s1_diag(Error, start, n, "lexer: unterminated string literal");
                            running = false;
                            0
                          };
                          Some(_b2) => {
                            j = j + 2;
                            0
                          };
                        }
                      } else {
                        if b1 == 34 {
                          closed = true;
                          scanning = false;
                          0
                        } else {
                          j = j + 1;
                          0
                        }
                      }
                    };
                  }
                }
              };

              if ok == true {
                if closed == true {
                  let content_start: Int = start + 1;
                  let content_end: Int = j;
                  let end: Int = j + 1;

                  let slice_opt: Option<Text> = text_slice(source, content_start, content_end);
                  match slice_opt {
                    None => {
                      ok = false;
                      diag = s1_diag(Error, start, end, "lexer: invalid string slice");
                      running = false;
                      0
                    };
                    Some(content_raw) => {
                      let unesc_r: Result<Text, S1Diagnostic> =
                        s1_lex_unescape_string(content_raw, content_start);
                      match unesc_r {
                        Err(e) => {
                          ok = false;
                          diag = e;
                          running = false;
                          0
                        };
                        Ok(content) => {
                          let tok: S1Token = S1Token {
                            kind: String(content);
                            span: S1Span { start: start; end: end; };
                          };
                          tokens_rev =
                            Cons(ListCons<S1Token> { head: tok; tail: tokens_rev; });
                          i = end;
                          0
                        };
                      }
                    };
                  }
                } else {
                  ok = false;
                  diag = s1_diag(Error, start, n, "lexer: unterminated string literal");
                  running = false;
                  0
                }
              } else {
                0
              }
            } else {
              if byte_is_ascii_ident_start(b0) {
                // Identifier/keyword.
                let start: Int = i;
                let j: Int = i;
                let scanning: Bool = true;

                while scanning == true {
                  if j == n {
                    scanning = false;
                    0
                  } else {
                    let bopt: Option<Int> = text_byte_at(source, j);
                    match bopt {
                      None => {
                        scanning = false;
                        0
                      };
                      Some(b1) => {
                        if byte_is_ascii_ident_continue(b1) {
                          j = j + 1;
                          0
                        } else {
                          scanning = false;
                          0
                        }
                      };
                    }
                  }
                };

                let slice_opt: Option<Text> = text_slice(source, start, j);
                match slice_opt {
                  None => {
                    ok = false;
                    diag = s1_diag(Error, start, j, "lexer: invalid identifier slice");
                    running = false;
                    0
                  };
                  Some(lexeme) => {
                    let kind: S1TokenKind = s1_keyword_or_ident(lexeme);
                    let tok: S1Token =
                      S1Token { kind: kind; span: S1Span { start: start; end: j; }; };
                    tokens_rev =
                      Cons(ListCons<S1Token> { head: tok; tail: tokens_rev; });
                    i = j;
                    0
                  };
                }
              } else {
                if byte_is_ascii_digit(b0) {
                  // Number (integer digits only).
                  let start: Int = i;
                  let j: Int = i;
                  let scanning: Bool = true;

                  while scanning == true {
                    if j == n {
                      scanning = false;
                      0
                    } else {
                      let bopt: Option<Int> = text_byte_at(source, j);
                      match bopt {
                        None => {
                          scanning = false;
                          0
                        };
                        Some(b1) => {
                          if byte_is_ascii_digit(b1) {
                            j = j + 1;
                            0
                          } else {
                            scanning = false;
                            0
                          }
                        };
                      }
                    }
                  };

                  let slice_opt: Option<Text> = text_slice(source, start, j);
                  match slice_opt {
                    None => {
                      ok = false;
                      diag = s1_diag(Error, start, j, "lexer: invalid number slice");
                      running = false;
                      0
                    };
                    Some(lexeme) => {
                      let tok: S1Token =
                        S1Token { kind: Number(lexeme); span: S1Span { start: start; end: j; }; };
                      tokens_rev =
                        Cons(ListCons<S1Token> { head: tok; tail: tokens_rev; });
                      i = j;
                      0
                    };
                  }
                } else {
                  let start: Int = i;
                  let end1: Int = i + 1;

                  if b0 == 40 {
                    // (
                    let tok: S1Token = S1Token { kind: LParen; span: S1Span { start: start; end: end1; }; };
                    tokens_rev = Cons(ListCons<S1Token> { head: tok; tail: tokens_rev; });
                    i = end1;
                    0
                  } else {
                    if b0 == 41 {
                      // )
                      let tok: S1Token = S1Token { kind: RParen; span: S1Span { start: start; end: end1; }; };
                      tokens_rev = Cons(ListCons<S1Token> { head: tok; tail: tokens_rev; });
                      i = end1;
                      0
                    } else {
                      if b0 == 123 {
                        // {
                        let tok: S1Token = S1Token { kind: LBrace; span: S1Span { start: start; end: end1; }; };
                        tokens_rev = Cons(ListCons<S1Token> { head: tok; tail: tokens_rev; });
                        i = end1;
                        0
                      } else {
                        if b0 == 125 {
                          // }
                          let tok: S1Token = S1Token { kind: RBrace; span: S1Span { start: start; end: end1; }; };
                          tokens_rev = Cons(ListCons<S1Token> { head: tok; tail: tokens_rev; });
                          i = end1;
                          0
                        } else {
                          if b0 == 91 {
                            // [
                            let tok: S1Token = S1Token { kind: LBracket; span: S1Span { start: start; end: end1; }; };
                            tokens_rev = Cons(ListCons<S1Token> { head: tok; tail: tokens_rev; });
                            i = end1;
                            0
                          } else {
                            if b0 == 93 {
                              // ]
                              let tok: S1Token = S1Token { kind: RBracket; span: S1Span { start: start; end: end1; }; };
                              tokens_rev = Cons(ListCons<S1Token> { head: tok; tail: tokens_rev; });
                              i = end1;
                              0
                            } else {
                              if b0 == 44 {
                                // ,
                                let tok: S1Token = S1Token { kind: Comma; span: S1Span { start: start; end: end1; }; };
                                tokens_rev = Cons(ListCons<S1Token> { head: tok; tail: tokens_rev; });
                                i = end1;
                                0
                              } else {
                                if b0 == 46 {
                                  // .
                                  let tok: S1Token = S1Token { kind: Dot; span: S1Span { start: start; end: end1; }; };
                                  tokens_rev = Cons(ListCons<S1Token> { head: tok; tail: tokens_rev; });
                                  i = end1;
                                  0
                                } else {
                                  if b0 == 58 {
                                    // :
                                    let tok: S1Token = S1Token { kind: Colon; span: S1Span { start: start; end: end1; }; };
                                    tokens_rev = Cons(ListCons<S1Token> { head: tok; tail: tokens_rev; });
                                    i = end1;
                                    0
                                  } else {
                                    if b0 == 59 {
                                      // ;
                                      let tok: S1Token = S1Token { kind: Semicolon; span: S1Span { start: start; end: end1; }; };
                                      tokens_rev = Cons(ListCons<S1Token> { head: tok; tail: tokens_rev; });
                                      i = end1;
                                      0
                                    } else {
                                      if b0 == 43 {
                                        // +
                                        let tok: S1Token = S1Token { kind: Plus; span: S1Span { start: start; end: end1; }; };
                                        tokens_rev = Cons(ListCons<S1Token> { head: tok; tail: tokens_rev; });
                                        i = end1;
                                        0
                                      } else {
                                        if b0 == 60 {
                                          // < or <=
                                          let next: Option<Int> = text_byte_at(source, i + 1);
                                          match next {
                                            Some(b1) => {
                                              if b1 == 61 {
                                                let end2: Int = i + 2;
                                                let tok: S1Token = S1Token { kind: Lte; span: S1Span { start: start; end: end2; }; };
                                                tokens_rev = Cons(ListCons<S1Token> { head: tok; tail: tokens_rev; });
                                                i = end2;
                                                0
                                              } else {
                                                let tok: S1Token = S1Token { kind: LAngle; span: S1Span { start: start; end: end1; }; };
                                                tokens_rev = Cons(ListCons<S1Token> { head: tok; tail: tokens_rev; });
                                                i = end1;
                                                0
                                              }
                                            };
                                            None => {
                                              let tok: S1Token = S1Token { kind: LAngle; span: S1Span { start: start; end: end1; }; };
                                              tokens_rev = Cons(ListCons<S1Token> { head: tok; tail: tokens_rev; });
                                              i = end1;
                                              0
                                            };
                                          }
                                        } else {
                                          if b0 == 62 {
                                            // > or >=
                                            let next: Option<Int> = text_byte_at(source, i + 1);
                                            match next {
                                              Some(b1) => {
                                                if b1 == 61 {
                                                  let end2: Int = i + 2;
                                                  let tok: S1Token = S1Token { kind: Gte; span: S1Span { start: start; end: end2; }; };
                                                  tokens_rev = Cons(ListCons<S1Token> { head: tok; tail: tokens_rev; });
                                                  i = end2;
                                                  0
                                                } else {
                                                  let tok: S1Token = S1Token { kind: RAngle; span: S1Span { start: start; end: end1; }; };
                                                  tokens_rev = Cons(ListCons<S1Token> { head: tok; tail: tokens_rev; });
                                                  i = end1;
                                                  0
                                                }
                                              };
                                              None => {
                                                let tok: S1Token = S1Token { kind: RAngle; span: S1Span { start: start; end: end1; }; };
                                                tokens_rev = Cons(ListCons<S1Token> { head: tok; tail: tokens_rev; });
                                                i = end1;
                                                0
                                              };
                                            }
                                          } else {
                                            if b0 == 61 {
                                              // =, ==, =>
                                              let next: Option<Int> = text_byte_at(source, i + 1);
                                              match next {
                                                Some(b1) => {
                                                  if b1 == 61 {
                                                    let end2: Int = i + 2;
                                                    let tok: S1Token = S1Token { kind: EqEq; span: S1Span { start: start; end: end2; }; };
                                                    tokens_rev = Cons(ListCons<S1Token> { head: tok; tail: tokens_rev; });
                                                    i = end2;
                                                    0
                                                  } else {
                                                    if b1 == 62 {
                                                      let end2: Int = i + 2;
                                                      let tok: S1Token = S1Token { kind: FatArrow; span: S1Span { start: start; end: end2; }; };
                                                      tokens_rev = Cons(ListCons<S1Token> { head: tok; tail: tokens_rev; });
                                                      i = end2;
                                                      0
                                                    } else {
                                                      let tok: S1Token = S1Token { kind: Eq; span: S1Span { start: start; end: end1; }; };
                                                      tokens_rev = Cons(ListCons<S1Token> { head: tok; tail: tokens_rev; });
                                                      i = end1;
                                                      0
                                                    }
                                                  }
                                                };
                                                None => {
                                                  let tok: S1Token = S1Token { kind: Eq; span: S1Span { start: start; end: end1; }; };
                                                  tokens_rev = Cons(ListCons<S1Token> { head: tok; tail: tokens_rev; });
                                                  i = end1;
                                                  0
                                                };
                                              }
                                            } else {
                                              if b0 == 33 {
                                                // ! or !=
                                                let next: Option<Int> = text_byte_at(source, i + 1);
                                                match next {
                                                  Some(b1) => {
                                                    if b1 == 61 {
                                                      let end2: Int = i + 2;
                                                      let tok: S1Token = S1Token { kind: NotEq; span: S1Span { start: start; end: end2; }; };
                                                      tokens_rev = Cons(ListCons<S1Token> { head: tok; tail: tokens_rev; });
                                                      i = end2;
                                                      0
                                                    } else {
                                                      let tok: S1Token = S1Token { kind: Bang; span: S1Span { start: start; end: end1; }; };
                                                      tokens_rev = Cons(ListCons<S1Token> { head: tok; tail: tokens_rev; });
                                                      i = end1;
                                                      0
                                                    }
                                                  };
                                                  None => {
                                                    let tok: S1Token = S1Token { kind: Bang; span: S1Span { start: start; end: end1; }; };
                                                    tokens_rev = Cons(ListCons<S1Token> { head: tok; tail: tokens_rev; });
                                                    i = end1;
                                                    0
                                                  };
                                                }
                                              } else {
                                                if b0 == 45 {
                                                  // - or ->
                                                  let next: Option<Int> = text_byte_at(source, i + 1);
                                                  match next {
                                                    Some(b1) => {
                                                      if b1 == 62 {
                                                        let end2: Int = i + 2;
                                                        let tok: S1Token = S1Token { kind: Arrow; span: S1Span { start: start; end: end2; }; };
                                                        tokens_rev = Cons(ListCons<S1Token> { head: tok; tail: tokens_rev; });
                                                        i = end2;
                                                        0
                                                      } else {
                                                        ok = false;
                                                        diag = s1_diag(Error, i, i + 1, "lexer: unexpected '-' (expected '->')");
                                                        running = false;
                                                        0
                                                      }
                                                    };
                                                    None => {
                                                      ok = false;
                                                      diag = s1_diag(Error, i, i + 1, "lexer: unexpected '-' (expected '->')");
                                                      running = false;
                                                      0
                                                    };
                                                  }
                                                } else {
                                                  ok = false;
                                                  diag = s1_diag(Error, i, i + 1, "lexer: unexpected character");
                                                  running = false;
                                                  0
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          };
        }
      }
    }
  };

  let out: Result<List<S1Token>, S1Diagnostic> = Err(diag);
  if ok == true {
    let eof: S1Token = S1Token { kind: Eof; span: S1Span { start: n; end: n; }; };
    tokens_rev = Cons(ListCons<S1Token> { head: eof; tail: tokens_rev; });
    let tokens: List<S1Token> = s1_reverse_tokens(tokens_rev);
    out = Ok(tokens);
  };

  out
};
