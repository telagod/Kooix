import "../stdlib/prelude";
import "ast";

record S1Module { ns: Text; items: List<S1Item>; };

fn s1_mod_reverse_items(xs: List<S1Item>) -> List<S1Item> {
  let acc: List<S1Item> = Nil;
  let cur: List<S1Item> = xs;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => {
        done = true;
        0
      };
      Cons(cell) => {
        acc = Cons(ListCons<S1Item> { head: cell.head; tail: acc; });
        cur = cell.tail;
        0
      };
    }
  };
  acc
};

fn s1_mod_reverse_texts(xs: List<Text>) -> List<Text> {
  let acc: List<Text> = Nil;
  let cur: List<Text> = xs;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => {
        done = true;
        0
      };
      Cons(cell) => {
        acc = Cons(ListCons<Text> { head: cell.head; tail: acc; });
        cur = cell.tail;
        0
      };
    }
  };
  acc
};

fn s1_mod_reverse_types(xs: List<S1Type>) -> List<S1Type> {
  let acc: List<S1Type> = Nil;
  let cur: List<S1Type> = xs;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => {
        done = true;
        0
      };
      Cons(cell) => {
        acc = Cons(ListCons<S1Type> { head: cell.head; tail: acc; });
        cur = cell.tail;
        0
      };
    }
  };
  acc
};

fn s1_mod_simple_path(name: Text) -> S1Path {
  let empty: List<Text> = Nil;
  let segs: List<Text> = Cons(ListCons<Text> { head: name; tail: empty; });
  S1Path { segments: segs; }
};

fn s1_mod_ns_path(ns: Text, name: Text) -> S1Path {
  let empty: List<Text> = Nil;
  let tail: List<Text> = Cons(ListCons<Text> { head: ns; tail: empty; });
  let segs_rev: List<Text> = Cons(ListCons<Text> {
    head: name;
    tail: tail;
  });
  S1Path { segments: s1_mod_reverse_texts(segs_rev); }
};

fn s1_mod_type_path(path: S1Path, args: List<S1Type>) -> S1Type {
  S1Type { path: path; args: args; }
};

fn s1_mod_type_simple(name: Text) -> S1Type {
  let args: List<S1Type> = Nil;
  s1_mod_type_path(s1_mod_simple_path(name), args)
};

fn s1_mod_type_ns(ns: Text, name: Text, args: List<S1Type>) -> S1Type {
  s1_mod_type_path(s1_mod_ns_path(ns, name), args)
};

fn s1_mod_generic(name: Text) -> S1GenericParam {
  let bounds: List<S1Type> = Nil;
  S1GenericParam { name: name; bounds: bounds; }
};

fn s1_mod_generics1(a: Text) -> List<S1GenericParam> {
  let empty: List<S1GenericParam> = Nil;
  Cons(ListCons<S1GenericParam> { head: s1_mod_generic(a); tail: empty; })
};

fn s1_mod_generics2(a: Text, b: Text) -> List<S1GenericParam> {
  let empty: List<S1GenericParam> = Nil;
  let tail: List<S1GenericParam> =
    Cons(ListCons<S1GenericParam> { head: s1_mod_generic(b); tail: empty; });
  Cons(ListCons<S1GenericParam> {
    head: s1_mod_generic(a);
    tail: tail;
  })
};

fn s1_mod_variants2(v0: S1EnumVariant, v1: S1EnumVariant) -> List<S1EnumVariant> {
  let empty: List<S1EnumVariant> = Nil;
  let tail: List<S1EnumVariant> =
    Cons(ListCons<S1EnumVariant> { head: v1; tail: empty; });
  Cons(ListCons<S1EnumVariant> { head: v0; tail: tail; })
};

fn s1_mod_fields2(f0: S1RecordField, f1: S1RecordField) -> List<S1RecordField> {
  let empty: List<S1RecordField> = Nil;
  let tail: List<S1RecordField> =
    Cons(ListCons<S1RecordField> { head: f1; tail: empty; });
  Cons(ListCons<S1RecordField> { head: f0; tail: tail; })
};

fn s1_mod_prelude_stub_items(ns: Text) -> List<S1Item> {
  // fn text_len(s: Text) -> Int;
  let empty_fn_generics: List<S1GenericParam> = Nil;
  let empty_params: List<S1Param> = Nil;
  let no_body: Option<S1Block> = None;
  let p_s: S1Param = S1Param { name: "s"; ty: s1_mod_type_simple("Text"); };
  let ps1: List<S1Param> = Cons(ListCons<S1Param> { head: p_s; tail: empty_params; });
  let f_len: S1Function = S1Function {
    name: "text_len";
    generics: empty_fn_generics;
    params: ps1;
    return_type: s1_mod_type_simple("Int");
    body: no_body;
  };
  let f_len_i: S1Item = Function(f_len);

  // fn text_byte_at(s: Text, i: Int) -> Option<Int>;
  let p_i: S1Param = S1Param { name: "i"; ty: s1_mod_type_simple("Int"); };
  let tail1: List<S1Param> = Cons(ListCons<S1Param> { head: p_i; tail: empty_params; });
  let ps2: List<S1Param> = Cons(ListCons<S1Param> { head: p_s; tail: tail1; });
  let empty_ty_args: List<S1Type> = Nil;
  let opt_int_args: List<S1Type> =
    Cons(ListCons<S1Type> { head: s1_mod_type_simple("Int"); tail: empty_ty_args; });
  let opt_int: S1Type = s1_mod_type_ns(ns, "Option", opt_int_args);
  let f_ba: S1Function = S1Function {
    name: "text_byte_at";
    generics: empty_fn_generics;
    params: ps2;
    return_type: opt_int;
    body: no_body;
  };
  let f_ba_i: S1Item = Function(f_ba);

  // fn text_slice(s: Text, start: Int, end: Int) -> Option<Text>;
  let p_start: S1Param = S1Param { name: "start"; ty: s1_mod_type_simple("Int"); };
  let p_end: S1Param = S1Param { name: "end"; ty: s1_mod_type_simple("Int"); };
  let tail2a: List<S1Param> = Cons(ListCons<S1Param> { head: p_end; tail: empty_params; });
  let tail2b: List<S1Param> = Cons(ListCons<S1Param> { head: p_start; tail: tail2a; });
  let ps3: List<S1Param> = Cons(ListCons<S1Param> { head: p_s; tail: tail2b; });
  let opt_text_args: List<S1Type> =
    Cons(ListCons<S1Type> { head: s1_mod_type_simple("Text"); tail: empty_ty_args; });
  let opt_text: S1Type = s1_mod_type_ns(ns, "Option", opt_text_args);
  let f_sl: S1Function = S1Function {
    name: "text_slice";
    generics: empty_fn_generics;
    params: ps3;
    return_type: opt_text;
    body: no_body;
  };
  let f_sl_i: S1Item = Function(f_sl);

  // fn text_starts_with(s: Text, prefix: Text) -> Bool;
  let p_prefix: S1Param = S1Param { name: "prefix"; ty: s1_mod_type_simple("Text"); };
  let tail_sw: List<S1Param> = Cons(ListCons<S1Param> { head: p_prefix; tail: empty_params; });
  let ps_sw: List<S1Param> = Cons(ListCons<S1Param> { head: p_s; tail: tail_sw; });
  let f_sw: S1Function = S1Function {
    name: "text_starts_with";
    generics: empty_fn_generics;
    params: ps_sw;
    return_type: s1_mod_type_simple("Bool");
    body: no_body;
  };
  let f_sw_i: S1Item = Function(f_sw);

  // fn byte_is_ascii_* (b: Int) -> Bool;
  let p_b: S1Param = S1Param { name: "b"; ty: s1_mod_type_simple("Int"); };
  let ps_b: List<S1Param> = Cons(ListCons<S1Param> { head: p_b; tail: empty_params; });

  let f_ws: S1Function = S1Function {
    name: "byte_is_ascii_whitespace";
    generics: empty_fn_generics;
    params: ps_b;
    return_type: s1_mod_type_simple("Bool");
    body: no_body;
  };
  let f_ws_i: S1Item = Function(f_ws);

  let f_d: S1Function = S1Function {
    name: "byte_is_ascii_digit";
    generics: empty_fn_generics;
    params: ps_b;
    return_type: s1_mod_type_simple("Bool");
    body: no_body;
  };
  let f_d_i: S1Item = Function(f_d);

  let f_a: S1Function = S1Function {
    name: "byte_is_ascii_alpha";
    generics: empty_fn_generics;
    params: ps_b;
    return_type: s1_mod_type_simple("Bool");
    body: no_body;
  };
  let f_a_i: S1Item = Function(f_a);

  let f_an: S1Function = S1Function {
    name: "byte_is_ascii_alnum";
    generics: empty_fn_generics;
    params: ps_b;
    return_type: s1_mod_type_simple("Bool");
    body: no_body;
  };
  let f_an_i: S1Item = Function(f_an);

  let f_is: S1Function = S1Function {
    name: "byte_is_ascii_ident_start";
    generics: empty_fn_generics;
    params: ps_b;
    return_type: s1_mod_type_simple("Bool");
    body: no_body;
  };
  let f_is_i: S1Item = Function(f_is);

  let f_ic: S1Function = S1Function {
    name: "byte_is_ascii_ident_continue";
    generics: empty_fn_generics;
    params: ps_b;
    return_type: s1_mod_type_simple("Bool");
    body: no_body;
  };
  let f_ic_i: S1Item = Function(f_ic);

  // enum Option<T> { Some(T); None; }
  let gen_t: List<S1GenericParam> = s1_mod_generics1("T");
  let t_ty: S1Type = s1_mod_type_simple("T");
  let some_pl: Option<S1Type> = Some(t_ty);
  let none_pl: Option<S1Type> = None;
  let some_v: S1EnumVariant = S1EnumVariant { name: "Some"; payload_ty: some_pl; };
  let none_v: S1EnumVariant = S1EnumVariant { name: "None"; payload_ty: none_pl; };
  let opt_e: S1Enum = S1Enum { name: "Option"; generics: gen_t; variants: s1_mod_variants2(some_v, none_v); };
  let opt_i: S1Item = Enum(opt_e);

  // enum Result<T, E> { Ok(T); Err(E); }
  let gen_te: List<S1GenericParam> = s1_mod_generics2("T", "E");
  let ok_pl: Option<S1Type> = Some(s1_mod_type_simple("T"));
  let err_pl: Option<S1Type> = Some(s1_mod_type_simple("E"));
  let ok_v: S1EnumVariant = S1EnumVariant { name: "Ok"; payload_ty: ok_pl; };
  let err_v: S1EnumVariant = S1EnumVariant { name: "Err"; payload_ty: err_pl; };
  let res_e: S1Enum = S1Enum { name: "Result"; generics: gen_te; variants: s1_mod_variants2(ok_v, err_v); };
  let res_i: S1Item = Enum(res_e);

  // record Pair<A, B> { a: A; b: B; }
  let gen_ab: List<S1GenericParam> = s1_mod_generics2("A", "B");
  let a_f: S1RecordField = S1RecordField { name: "a"; ty: s1_mod_type_simple("A"); };
  let b_f: S1RecordField = S1RecordField { name: "b"; ty: s1_mod_type_simple("B"); };
  let pair_r: S1Record = S1Record { name: "Pair"; generics: gen_ab; fields: s1_mod_fields2(a_f, b_f); };
  let pair_i: S1Item = Record(pair_r);

  // record ListCons<T> { head: T; tail: List<T>; }
  let gen_t2: List<S1GenericParam> = s1_mod_generics1("T");
  let head_f: S1RecordField = S1RecordField { name: "head"; ty: s1_mod_type_simple("T"); };
  let list_t_args: List<S1Type> =
    Cons(ListCons<S1Type> { head: s1_mod_type_simple("T"); tail: empty_ty_args; });
  let tail_f: S1RecordField = S1RecordField { name: "tail"; ty: s1_mod_type_ns(ns, "List", list_t_args); };
  let listcons_r: S1Record = S1Record { name: "ListCons"; generics: gen_t2; fields: s1_mod_fields2(head_f, tail_f); };
  let listcons_i: S1Item = Record(listcons_r);

  // enum List<T> { Nil; Cons(ListCons<T>); }
  let gen_t3: List<S1GenericParam> = s1_mod_generics1("T");
  let nil_pl: Option<S1Type> = None;
  let nil_v: S1EnumVariant = S1EnumVariant { name: "Nil"; payload_ty: nil_pl; };
  let lc_args: List<S1Type> =
    Cons(ListCons<S1Type> { head: s1_mod_type_simple("T"); tail: empty_ty_args; });
  let cons_payload: S1Type = s1_mod_type_ns(ns, "ListCons", lc_args);
  let cons_pl: Option<S1Type> = Some(cons_payload);
  let cons_v: S1EnumVariant = S1EnumVariant { name: "Cons"; payload_ty: cons_pl; };
  let list_e: S1Enum = S1Enum { name: "List"; generics: gen_t3; variants: s1_mod_variants2(nil_v, cons_v); };
  let list_i: S1Item = Enum(list_e);

  let empty_items: List<S1Item> = Nil;
  let xs0: List<S1Item> = Cons(ListCons<S1Item> { head: opt_i; tail: empty_items; });
  let xs1: List<S1Item> = Cons(ListCons<S1Item> { head: res_i; tail: xs0; });
  let xs2: List<S1Item> = Cons(ListCons<S1Item> { head: pair_i; tail: xs1; });
  let xs3: List<S1Item> = Cons(ListCons<S1Item> { head: listcons_i; tail: xs2; });
  let xs4: List<S1Item> = Cons(ListCons<S1Item> { head: list_i; tail: xs3; });
  let xs5: List<S1Item> = Cons(ListCons<S1Item> { head: f_len_i; tail: xs4; });
  let xs6: List<S1Item> = Cons(ListCons<S1Item> { head: f_ba_i; tail: xs5; });
  let xs7: List<S1Item> = Cons(ListCons<S1Item> { head: f_sl_i; tail: xs6; });
  let xs8: List<S1Item> = Cons(ListCons<S1Item> { head: f_sw_i; tail: xs7; });
  let xs9: List<S1Item> = Cons(ListCons<S1Item> { head: f_ws_i; tail: xs8; });
  let xs10: List<S1Item> = Cons(ListCons<S1Item> { head: f_d_i; tail: xs9; });
  let xs11: List<S1Item> = Cons(ListCons<S1Item> { head: f_a_i; tail: xs10; });
  let xs12: List<S1Item> = Cons(ListCons<S1Item> { head: f_an_i; tail: xs11; });
  let xs13: List<S1Item> = Cons(ListCons<S1Item> { head: f_is_i; tail: xs12; });
  let xs14: List<S1Item> = Cons(ListCons<S1Item> { head: f_ic_i; tail: xs13; });
  xs14
};

fn s1_mod_infer_basename_no_ext(path: Text) -> Text {
  let n: Int = text_len(path);

  let i: Int = 0;
  let last_sep: Option<Int> = None;
  let scanning: Bool = true;
  while scanning == true {
    if i == n {
      scanning = false;
      0
    } else {
      let bopt: Option<Int> = text_byte_at(path, i);
      match bopt {
        None => {
          scanning = false;
          0
        };
        Some(b) => {
          if b == 47 {
            last_sep = Some(i);
            0
          } else { 0 };
          i = i + 1;
          0
        };
      }
    }
  };

  let start: Int = 0;
  match last_sep {
    None => 0;
    Some(p) => {
      start = p + 1;
      0
    };
  };

  let j: Int = start;
  let last_dot: Option<Int> = None;
  let scanning2: Bool = true;
  while scanning2 == true {
    if j == n {
      scanning2 = false;
      0
    } else {
      let bopt: Option<Int> = text_byte_at(path, j);
      match bopt {
        None => {
          scanning2 = false;
          0
        };
        Some(b) => {
          if b == 46 {
            last_dot = Some(j);
            0
          } else { 0 };
          j = j + 1;
          0
        };
      }
    }
  };

  let end: Int = n;
  match last_dot {
    None => 0;
    Some(p) => {
      end = p;
      0
    };
  };

  let slice_opt: Option<Text> = text_slice(path, start, end);
  match slice_opt {
    Some(s) => s;
    None => path;
  }
};

fn s1_mod_is_prelude_path(path: Text) -> Bool {
  s1_mod_infer_basename_no_ext(path) == "prelude"
};

fn s1_mod_reverse_modules(xs: List<S1Module>) -> List<S1Module> {
  let acc: List<S1Module> = Nil;
  let cur: List<S1Module> = xs;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => {
        done = true;
        0
      };
      Cons(cell) => {
        acc = Cons(ListCons<S1Module> { head: cell.head; tail: acc; });
        cur = cell.tail;
        0
      };
    }
  };
  acc
};

fn s1_mod_build(items: List<S1Item>) -> List<S1Module> {
  let rev: List<S1Module> = Nil;
  let cur: List<S1Item> = items;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => {
        done = true;
        0
      };
      Cons(cell) => {
        match cell.head {
          Import(imp) => {
            if s1_mod_is_prelude_path(imp.path) == true {
              let stub: List<S1Item> = s1_mod_prelude_stub_items(imp.ns);
              rev = Cons(ListCons<S1Module> { head: S1Module { ns: imp.ns; items: stub; }; tail: rev; });
              0
            } else { 0 };
            0
          };
          _ => 0;
        };
        cur = cell.tail;
        0
      };
    }
  };
  s1_mod_reverse_modules(rev)
};

fn s1_mod_lookup(mods: List<S1Module>, ns: Text) -> Option<S1Module> {
  let out: Option<S1Module> = None;
  let cur: List<S1Module> = mods;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => {
        done = true;
        0
      };
      Cons(cell) => {
        if cell.head.ns == ns {
          out = Some(cell.head);
          done = true;
          0
        } else {
          cur = cell.tail;
          0
        };
        0
      };
    }
  };
  out
};

fn s1_mod_module_has_type(m: S1Module, name: Text) -> Bool {
  let found: Bool = false;
  let cur: List<S1Item> = m.items;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => {
        done = true;
        0
      };
      Cons(cell) => {
        match cell.head {
          Record(r) => {
            if r.name == name {
              found = true;
              done = true;
              0
            } else {
              cur = cell.tail;
              0
            };
            0
          };
          Enum(e) => {
            if e.name == name {
              found = true;
              done = true;
              0
            } else {
              cur = cell.tail;
              0
            };
            0
          };
          _ => {
            cur = cell.tail;
            0
          };
        };
        0
      };
    }
  };
  found
};

fn s1_mod_lookup_enum(m: S1Module, name: Text) -> Option<S1Enum> {
  let out: Option<S1Enum> = None;
  let cur: List<S1Item> = m.items;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => {
        done = true;
        0
      };
      Cons(cell) => {
        match cell.head {
          Enum(e) => {
            if e.name == name {
              out = Some(e);
              done = true;
              0
            } else {
              cur = cell.tail;
              0
            };
            0
          };
          _ => {
            cur = cell.tail;
            0
          };
        };
        0
      };
    }
  };
  out
};

fn s1_mod_lookup_record(m: S1Module, name: Text) -> Option<S1Record> {
  let out: Option<S1Record> = None;
  let cur: List<S1Item> = m.items;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => {
        done = true;
        0
      };
      Cons(cell) => {
        match cell.head {
          Record(r) => {
            if r.name == name {
              out = Some(r);
              done = true;
              0
            } else {
              cur = cell.tail;
              0
            };
            0
          };
          _ => {
            cur = cell.tail;
            0
          };
        };
        0
      };
    }
  };
  out
};

fn s1_mod_lookup_fn(m: S1Module, name: Text) -> Option<S1Function> {
  let out: Option<S1Function> = None;
  let cur: List<S1Item> = m.items;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => {
        done = true;
        0
      };
      Cons(cell) => {
        match cell.head {
          Function(f) => {
            if f.name == name {
              out = Some(f);
              done = true;
              0
            } else {
              cur = cell.tail;
              0
            };
            0
          };
          _ => {
            cur = cell.tail;
            0
          };
        };
        0
      };
    }
  };
  out
};
