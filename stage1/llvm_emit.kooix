import "../stdlib/prelude";
import "diag";
import "ast";
import "lexer";
import "parser";
import "resolver";
import "typecheck";

record S1CgEnvBind { name: Text; llvm: Text; ty: Text; };
record S1CgExprOut { text: Text; value: Text; ty: Text; bb: Text; next_tmp: Int; };
record S1CgBlockOut { text: Text; env: List<S1CgEnvBind>; bb: Text; next_tmp: Int; };
record S1CgStrConst { lit: Text; global: Text; n: Int; };

fn s1_cg_type_is_plain_int(ty: S1Type) -> Bool {
  let ok: Bool = false;
  match ty.args {
    Nil => {
      match s1_cg_path_single_name(ty.path) {
        Some(name) => {
          if name == "Int" { ok = true; 0 } else { 0 };
          0
        };
        _ => 0;
      };
      0
    };
    _ => 0;
  };
  ok
};

fn s1_cg_type_is_plain_bool(ty: S1Type) -> Bool {
  let ok: Bool = false;
  match ty.args {
    Nil => {
      match s1_cg_path_single_name(ty.path) {
        Some(name) => {
          if name == "Bool" { ok = true; 0 } else { 0 };
          0
        };
        _ => 0;
      };
      0
    };
    _ => 0;
  };
  ok
};

fn s1_cg_type_is_plain_text(ty: S1Type) -> Bool {
  let ok: Bool = false;
  match ty.args {
    Nil => {
      match s1_cg_path_single_name(ty.path) {
        Some(name) => {
          if name == "Text" { ok = true; 0 } else { 0 };
          0
        };
        _ => 0;
      };
      0
    };
    _ => 0;
  };
  ok
};

fn s1_cg_block_supported(b: S1Block) -> Bool {
  let ok: Bool = true;
  let cur: List<S1Stmt> = b.stmts;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        match c0.head {
          Let(_l) => { cur = c0.tail; 0 };
          Assign(_a) => { cur = c0.tail; 0 };
          ExprStmt(_e) => { cur = c0.tail; 0 };
          While(w) => {
            if s1_cg_block_supported(w.body) == true {
              cur = c0.tail;
              0
            } else {
              ok = false;
              done = true;
              0
            }
          };
          Return(_r) => { ok = false; done = true; 0 };
        };
        0
      };
    }
  };
  ok
};

fn s1_cg_function_supported(f: S1Function) -> Bool {
  // v0 subset: no generics, Int-only params/ret.
  // Body supports:
  // - zero or more: `let` / assignment / `while` and expression statements
  // - trailing `result` expression (no `return` in v0 subset)
  let ok: Bool = true;

  match f.generics {
    Nil => 0;
    _ => { ok = false; 0 };
  };

  if ok == true {
    if s1_cg_type_is_plain_int(f.return_type) { 0 } else { ok = false; 0 };
    0
  } else { 0 };

  if ok == true {
    let curp: List<S1Param> = f.params;
    let donep: Bool = false;
    while donep == false {
      match curp {
        Nil => { donep = true; 0 };
        Cons(c0) => {
          if s1_cg_type_is_plain_int(c0.head.ty) { 0 } else { ok = false; donep = true; 0 };
          curp = c0.tail;
          0
        };
      }
    };
    0
  } else { 0 };

  if ok == true {
    match f.body {
      None => { ok = false; 0 };
      Some(b) => {
        if s1_cg_block_supported(b) == true { 0 } else { ok = false; 0 };

        if ok == true {
          match b.result {
            Some(_e) => 0;
            _ => { ok = false; 0 };
          };
          0
        } else { 0 };
        0
      };
    };
    0
  } else { 0 };

  ok
};

fn s1_cg_text_err(diag: S1Diagnostic) -> Result<Text, S1Diagnostic> {
  let r: Result<Text, S1Diagnostic> = Err(diag);
  r
};

fn s1_cg_text_ok(value: Text) -> Result<Text, S1Diagnostic> {
  let r: Result<Text, S1Diagnostic> = Ok(value);
  r
};

fn s1_cg_expr_err(diag: S1Diagnostic) -> Result<S1CgExprOut, S1Diagnostic> {
  let r: Result<S1CgExprOut, S1Diagnostic> = Err(diag);
  r
};

fn s1_cg_expr_ok(value: S1CgExprOut) -> Result<S1CgExprOut, S1Diagnostic> {
  let r: Result<S1CgExprOut, S1Diagnostic> = Ok(value);
  r
};

fn s1_cg_block_err(diag: S1Diagnostic) -> Result<S1CgBlockOut, S1Diagnostic> {
  let r: Result<S1CgBlockOut, S1Diagnostic> = Err(diag);
  r
};

fn s1_cg_block_ok(value: S1CgBlockOut) -> Result<S1CgBlockOut, S1Diagnostic> {
  let r: Result<S1CgBlockOut, S1Diagnostic> = Ok(value);
  r
};

fn s1_cg_err(message: Text) -> Result<Text, S1Diagnostic> {
  s1_cg_text_err(s1_diag(Error, 0, 0, message))
};

fn s1_cg_text_append(out: Text, s: Text) -> Text {
  text_concat(out, s)
};

fn s1_cg_line(out: Text, s: Text) -> Text {
  text_concat(text_concat(out, s), "\n")
};

fn s1_cg_path_single_name(path: S1Path) -> Option<Text> {
  let out: Option<Text> = None;
  match path.segments {
    Nil => 0;
    Cons(c0) => {
      match c0.tail {
        Nil => { out = Some(c0.head); 0 };
        _ => 0;
      };
      0
    };
  };
  out
};

fn s1_cg_lookup_env(env: List<S1CgEnvBind>, name: Text) -> Option<S1CgEnvBind> {
  let out: Option<S1CgEnvBind> = None;
  let cur: List<S1CgEnvBind> = env;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        if c0.head.name == name {
          out = Some(c0.head);
          done = true;
          0
        } else {
          cur = c0.tail;
          0
        };
        0
      };
    }
  };
  out
};

fn s1_cg_build_env(params: List<S1Param>) -> List<S1CgEnvBind> {
  let acc: List<S1CgEnvBind> = Nil;
  let cur: List<S1Param> = params;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        let llvm: Text = text_concat("%", c0.head.name);
        let bind: S1CgEnvBind = S1CgEnvBind { name: c0.head.name; llvm: llvm; ty: "i64"; };
        acc = Cons(ListCons<S1CgEnvBind> { head: bind; tail: acc; });
        cur = c0.tail;
        0
      };
    }
  };

  // Reverse to preserve param order (small lists; simple impl).
  let out: List<S1CgEnvBind> = Nil;
  let cur2: List<S1CgEnvBind> = acc;
  let done2: Bool = false;
  while done2 == false {
    match cur2 {
      Nil => { done2 = true; 0 };
      Cons(c0) => {
        out = Cons(ListCons<S1CgEnvBind> { head: c0.head; tail: out; });
        cur2 = c0.tail;
        0
      };
    }
  };
  out
};

fn s1_cg_lookup_str_const(strs: List<S1CgStrConst>, lit: Text) -> Option<S1CgStrConst> {
  let out: Option<S1CgStrConst> = None;
  let cur: List<S1CgStrConst> = strs;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        if c0.head.lit == lit {
          out = Some(c0.head);
          done = true;
          0
        } else {
          cur = c0.tail;
          0
        };
        0
      };
    }
  };
  out
};

fn s1_cg_emit_expr_min(out: Text, env: List<S1CgEnvBind>, next_tmp: Int, bb: Text, strs: List<S1CgStrConst>, e: S1Expr) -> Result<S1CgExprOut, S1Diagnostic> {
  match e {
    IntLit(raw) => s1_cg_expr_ok(S1CgExprOut { text: out; value: raw; ty: "i64"; bb: bb; next_tmp: next_tmp; });
    BoolLit(v) => {
      let raw: Text = "0";
      if v == true { raw = "1"; 0 } else { 0 };
      s1_cg_expr_ok(S1CgExprOut { text: out; value: raw; ty: "i1"; bb: bb; next_tmp: next_tmp; })
    };
    StringLit(raw) => {
      match s1_cg_lookup_str_const(strs, raw) {
        None => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: internal error: missing string literal constant"));
        Some(sc) => {
          let tmp_id: Text = int_to_text(next_tmp);
          let tmp: Text = text_concat("%t", tmp_id);
          let n_txt: Text = int_to_text(sc.n);
          let arr_ty: Text = text_concat(text_concat("[", n_txt), " x i8]");
          let head: Text = text_concat(text_concat(text_concat(text_concat("  ", tmp), " = getelementptr inbounds "), arr_ty), text_concat(text_concat(", ", arr_ty), "* "));
          let tail: Text = text_concat(text_concat(sc.global, ", i64 0"), ", i64 0");
          let out2: Text = s1_cg_line(out, text_concat(head, tail));
          s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: "i8*"; bb: bb; next_tmp: next_tmp + 1; })
        };
      }
    };
    Path(p) => {
      match s1_cg_path_single_name(p) {
        None => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: multi-segment path not supported"));
        Some(name) => {
          match s1_cg_lookup_env(env, name) {
            None => s1_cg_expr_err(s1_diag(Error, 0, 0, text_concat("codegen: unknown variable ", name)));
            Some(v) => {
              let tmp_id: Text = int_to_text(next_tmp);
              let tmp: Text = text_concat("%t", tmp_id);
              let inst1: Text = text_concat(text_concat(text_concat(text_concat("  ", tmp), " = load "), v.ty), text_concat(text_concat(", ", v.ty), text_concat("* ", v.llvm)));
              let out2: Text = s1_cg_line(out, inst1);
              s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: v.ty; bb: bb; next_tmp: next_tmp + 1; })
            };
          }
        };
      }
    };
    Binary(b) => {
      match b.op {
        Add => {
          let l_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(out, env, next_tmp, bb, strs, b.left);
          match l_r {
            Err(e1) => s1_cg_expr_err(e1);
            Ok(l) => {
              let r_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(l.text, env, l.next_tmp, l.bb, strs, b.right);
              match r_r {
                Err(e2) => s1_cg_expr_err(e2);
                Ok(r) => {
                  if l.ty == "i64" {
                    if r.ty == "i64" {
                      let tmp_id: Text = int_to_text(r.next_tmp);
                      let tmp: Text = text_concat("%t", tmp_id);
                      let inst: Text = text_concat(text_concat(text_concat(text_concat("  ", tmp), " = add i64 "), l.value), text_concat(", ", r.value));
                      let out2: Text = s1_cg_line(r.text, inst);
                      s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: "i64"; bb: r.bb; next_tmp: r.next_tmp + 1; })
                    } else {
                      s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: add expects i64 operands"))
                    }
                  } else {
                    s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: add expects i64 operands"))
                  }
                };
              }
            };
          }
        };
        Equals => {
          let l_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(out, env, next_tmp, bb, strs, b.left);
          match l_r {
            Err(e1) => s1_cg_expr_err(e1);
            Ok(l) => {
              let r_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(l.text, env, l.next_tmp, l.bb, strs, b.right);
              match r_r {
                Err(e2) => s1_cg_expr_err(e2);
                Ok(r) => {
                  if l.ty == r.ty {
                    if l.ty == "i64" {
                      let tmp_id: Text = int_to_text(r.next_tmp);
                      let tmp: Text = text_concat("%t", tmp_id);
                      let inst: Text = text_concat(text_concat(text_concat(text_concat("  ", tmp), " = icmp eq i64 "), l.value), text_concat(", ", r.value));
                      let out2: Text = s1_cg_line(r.text, inst);
                      s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: "i1"; bb: r.bb; next_tmp: r.next_tmp + 1; })
                    } else {
                      if l.ty == "i1" {
                        let tmp_id: Text = int_to_text(r.next_tmp);
                        let tmp: Text = text_concat("%t", tmp_id);
                        let inst: Text = text_concat(text_concat(text_concat(text_concat("  ", tmp), " = icmp eq i1 "), l.value), text_concat(", ", r.value));
                        let out2: Text = s1_cg_line(r.text, inst);
                        s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: "i1"; bb: r.bb; next_tmp: r.next_tmp + 1; })
                      } else {
                        if l.ty == "i8*" {
                          let cmp_id: Text = int_to_text(r.next_tmp);
                          let cmp: Text = text_concat("%t", cmp_id);
                          let inst0: Text = text_concat(text_concat(text_concat("  ", cmp), " = call i32 @strcmp(i8* "), l.value);
                          let inst1: Text = text_concat(inst0, ", i8* ");
                          let inst2: Text = text_concat(inst1, r.value);
                          let inst_cmp: Text = text_concat(inst2, ")");
                          let out2: Text = s1_cg_line(r.text, inst_cmp);

                          let tmp_id: Text = int_to_text(r.next_tmp + 1);
                          let tmp: Text = text_concat("%t", tmp_id);
                          let inst_eq: Text = text_concat(text_concat(text_concat(text_concat("  ", tmp), " = icmp eq i32 "), cmp), ", 0");
                          let out3: Text = s1_cg_line(out2, inst_eq);
                          s1_cg_expr_ok(S1CgExprOut { text: out3; value: tmp; ty: "i1"; bb: r.bb; next_tmp: r.next_tmp + 2; })
	                        } else {
	                          s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: == expects i64/i1/Text operands"))
	                        }
	                      }
	                    }
	                  } else {
	                    s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: == expects same-typed operands"))
	                  }
                };
              }
            };
          }
        };
        NotEquals => {
          let l_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(out, env, next_tmp, bb, strs, b.left);
          match l_r {
            Err(e1) => s1_cg_expr_err(e1);
            Ok(l) => {
              let r_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(l.text, env, l.next_tmp, l.bb, strs, b.right);
              match r_r {
                Err(e2) => s1_cg_expr_err(e2);
                Ok(r) => {
                  if l.ty == r.ty {
                    if l.ty == "i64" {
                      let tmp_id: Text = int_to_text(r.next_tmp);
                      let tmp: Text = text_concat("%t", tmp_id);
                      let inst: Text = text_concat(text_concat(text_concat(text_concat("  ", tmp), " = icmp ne i64 "), l.value), text_concat(", ", r.value));
                      let out2: Text = s1_cg_line(r.text, inst);
                      s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: "i1"; bb: r.bb; next_tmp: r.next_tmp + 1; })
                    } else {
                      if l.ty == "i1" {
                        let tmp_id: Text = int_to_text(r.next_tmp);
                        let tmp: Text = text_concat("%t", tmp_id);
                        let inst: Text = text_concat(text_concat(text_concat(text_concat("  ", tmp), " = icmp ne i1 "), l.value), text_concat(", ", r.value));
                        let out2: Text = s1_cg_line(r.text, inst);
                        s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: "i1"; bb: r.bb; next_tmp: r.next_tmp + 1; })
                      } else {
                        if l.ty == "i8*" {
                          let cmp_id: Text = int_to_text(r.next_tmp);
                          let cmp: Text = text_concat("%t", cmp_id);
                          let inst0: Text = text_concat(text_concat(text_concat("  ", cmp), " = call i32 @strcmp(i8* "), l.value);
                          let inst1: Text = text_concat(inst0, ", i8* ");
                          let inst2: Text = text_concat(inst1, r.value);
                          let inst_cmp: Text = text_concat(inst2, ")");
                          let out2: Text = s1_cg_line(r.text, inst_cmp);

                          let tmp_id: Text = int_to_text(r.next_tmp + 1);
                          let tmp: Text = text_concat("%t", tmp_id);
                          let inst_ne: Text = text_concat(text_concat(text_concat(text_concat("  ", tmp), " = icmp ne i32 "), cmp), ", 0");
                          let out3: Text = s1_cg_line(out2, inst_ne);
                          s1_cg_expr_ok(S1CgExprOut { text: out3; value: tmp; ty: "i1"; bb: r.bb; next_tmp: r.next_tmp + 2; })
	                        } else {
	                          s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: != expects i64/i1/Text operands"))
	                        }
	                      }
	                    }
	                  } else {
	                    s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: != expects same-typed operands"))
	                  }
                };
              }
            };
          }
        };
      }
    };
    Call(c) => {
      // Only support `callee` as a single-segment path (direct function call).
      match c.callee {
        Path(p) => {
          match s1_cg_path_single_name(p) {
            None => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: callee path not supported"));
            Some(fname) => {
              // Evaluate args left-to-right.
              let args_text: Text = "";
              let out_acc: Text = out;
              let next_acc: Int = next_tmp;
              let cur: List<S1Expr> = c.args;
              let done: Bool = false;

              // Mutable accumulators.
              let at: Text = args_text;
              let ot: Text = out_acc;
              let nt: Int = next_acc;
              let bt: Text = bb;
              let first: Bool = true;
              let ok: Bool = true;
              let diag: S1Diagnostic = s1_diag(Error, 0, 0, "codegen: arg eval failed");
              let argc: Int = 0;
              let a_val: Text = "";
              let a_ty: Text = "";
              let b_val: Text = "";
              let b_ty: Text = "";
              let all_i64: Bool = true;

              while done == false {
                match cur {
                  Nil => { done = true; 0 };
                  Cons(c0) => {
                    let rr: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(ot, env, nt, bt, strs, c0.head);
                    match rr {
                      Err(e3) => {
                        ok = false;
                        diag = e3;
                        done = true;
                        0
                      };
                      Ok(r) => {
                        let piece: Text = text_concat(text_concat(r.ty, " "), r.value);
                        if first == true {
                          at = piece;
                          first = false;
                          0
                        } else {
                          at = text_concat(text_concat(at, ", "), piece);
                          0
                        };

                        if argc == 0 { a_val = r.value; a_ty = r.ty; 0 } else { 0 };
                        if argc == 1 { b_val = r.value; b_ty = r.ty; 0 } else { 0 };
                        argc = argc + 1;
                        if r.ty == "i64" { 0 } else { all_i64 = false; 0 };

                        ot = r.text;
                        nt = r.next_tmp;
                        bt = r.bb;
                        cur = c0.tail;
                        0
                      };
                    }
                    ;
                    0
                  };
                }
              };

              if ok == false {
                s1_cg_expr_err(diag)
              } else {
                if fname == "text_concat" {
                  if argc == 2 {
                    if a_ty == "i8*" {
                      if b_ty == "i8*" {
                        let tmp_id: Text = int_to_text(nt);
                        let tmp: Text = text_concat("%t", tmp_id);
                        let call_head: Text = text_concat(text_concat(text_concat("  ", tmp), " = call i8* @kx_text_concat"), "(");
                        let inst: Text = text_concat(call_head, text_concat(at, ")"));
                        let out2: Text = s1_cg_line(ot, inst);
                        s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: "i8*"; bb: bt; next_tmp: nt + 1; })
                      } else {
                        s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_concat expects (Text, Text)"))
                      }
                    } else {
                      s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_concat expects (Text, Text)"))
                    }
                  } else {
                    s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_concat expects (Text, Text)"))
                  }
                } else {
                  if fname == "int_to_text" {
                    if argc == 1 {
                      if a_ty == "i64" {
                        let tmp_id: Text = int_to_text(nt);
                        let tmp: Text = text_concat("%t", tmp_id);
                        let inst: Text = text_concat(
                          text_concat(text_concat(text_concat("  ", tmp), " = call i8* @kx_int_to_text(i64 "), a_val),
                          ")"
                        );
                        let out2: Text = s1_cg_line(ot, inst);
                        s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: "i8*"; bb: bt; next_tmp: nt + 1; })
                      } else {
                        s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: int_to_text expects (Int)"))
                      }
                    } else {
                      s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: int_to_text expects (Int)"))
                    }
                  } else {
                    if fname == "text_len" {
                      if argc == 1 {
                        if a_ty == "i8*" {
                          let tmp_id: Text = int_to_text(nt);
                          let tmp: Text = text_concat("%t", tmp_id);
                          let inst: Text = text_concat(
                            text_concat(text_concat(text_concat("  ", tmp), " = call i64 @strlen(i8* "), a_val),
                            ")"
                          );
                          let out2: Text = s1_cg_line(ot, inst);
                          s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: "i64"; bb: bt; next_tmp: nt + 1; })
                        } else {
                          s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_len expects (Text)"))
                        }
                      } else {
                        s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_len expects (Text)"))
                      }
                    } else {
                      if fname == "text_starts_with" {
                        if argc == 2 {
                          if a_ty == "i8*" {
                            if b_ty == "i8*" {
                          // Implemented in terms of strlen+memcmp; avoids out-of-bounds reads.
                          let plen_id: Text = int_to_text(nt);
                          let plen: Text = text_concat("%t", plen_id);
                          let inst_plen: Text = text_concat(
                            text_concat(text_concat(text_concat("  ", plen), " = call i64 @strlen(i8* "), b_val),
                            ")"
                          );
                          let out1: Text = s1_cg_line(ot, inst_plen);
	                          let slen_id: Text = int_to_text(nt + 1);
	                          let slen: Text = text_concat("%t", slen_id);
	                          let inst_slen: Text = text_concat(
	                            text_concat(text_concat(text_concat("  ", slen), " = call i64 @strlen(i8* "), a_val),
	                            ")"
	                          );
	                          let out2: Text = s1_cg_line(out1, inst_slen);
                          let ge_id: Text = int_to_text(nt + 2);
                          let ge: Text = text_concat("%t", ge_id);
                          let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat(text_concat("  ", ge), " = icmp uge i64 "), slen), text_concat(", ", plen)));

                          let slot_id: Text = int_to_text(nt + 3);
                          let slot: Text = text_concat("%t", slot_id);
                          let out4: Text = s1_cg_line(out3, text_concat(text_concat(text_concat("  ", slot), " = alloca "), "i1"));
                          let out5: Text = s1_cg_line(out4, text_concat("  store i1 0, i1* ", slot));

                          let ok_lbl: Text = text_concat("sw_ok", int_to_text(nt + 4));
                          let join_lbl: Text = text_concat("sw_join", int_to_text(nt + 5));
                          let br1: Text = text_concat(
                            text_concat(text_concat("  br i1 ", ge), text_concat(", label %", ok_lbl)),
                            text_concat(", label %", join_lbl)
                          );
                          let out6: Text = s1_cg_line(out5, br1);

	                          let out_ok_lbl: Text = s1_cg_line(out6, text_concat(ok_lbl, ":"));
	                          let cmp_id: Text = int_to_text(nt + 6);
	                          let cmp: Text = text_concat("%t", cmp_id);
	                          let inst_cmp0: Text = text_concat(text_concat("  ", cmp), " = call i32 @memcmp(i8* ");
	                          let inst_cmp1: Text = text_concat(inst_cmp0, a_val);
	                          let inst_cmp2: Text = text_concat(inst_cmp1, ", i8* ");
	                          let inst_cmp3: Text = text_concat(inst_cmp2, b_val);
	                          let inst_cmp4: Text = text_concat(inst_cmp3, ", i64 ");
	                          let inst_cmp5: Text = text_concat(inst_cmp4, plen);
	                          let inst_cmp: Text = text_concat(inst_cmp5, ")");
	                          let out7: Text = s1_cg_line(out_ok_lbl, inst_cmp);

                          let eq_id: Text = int_to_text(nt + 7);
                          let eq0: Text = text_concat("%t", eq_id);
                          let out8: Text = s1_cg_line(out7, text_concat(text_concat(text_concat(text_concat("  ", eq0), " = icmp eq i32 "), cmp), ", 0"));
                          let out9: Text = s1_cg_line(out8, text_concat("  store i1 ", text_concat(eq0, text_concat(", i1* ", slot))));
                          let out10: Text = s1_cg_line(out9, text_concat("  br label %", join_lbl));

                          let out_join_lbl: Text = s1_cg_line(out10, text_concat(join_lbl, ":"));
                          let outv_id: Text = int_to_text(nt + 8);
                          let outv: Text = text_concat("%t", outv_id);
                          let out11: Text = s1_cg_line(out_join_lbl, text_concat(text_concat(text_concat("  ", outv), " = load i1, i1* "), slot));

                          s1_cg_expr_ok(S1CgExprOut { text: out11; value: outv; ty: "i1"; bb: join_lbl; next_tmp: nt + 9; })
                            } else {
                              s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_starts_with expects (Text, Text)"))
                            }
                          } else {
                            s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_starts_with expects (Text, Text)"))
                          }
                        } else {
                          s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_starts_with expects (Text, Text)"))
                        }
                      } else {
                        if fname == "host_eprintln" {
                          if argc == 1 {
                            if a_ty == "i8*" {
                              let inst: Text = text_concat(text_concat("  call void @kx_host_eprintln(i8* ", a_val), ")");
                              let out2: Text = s1_cg_line(ot, inst);
                              s1_cg_expr_ok(S1CgExprOut { text: out2; value: "0"; ty: "void"; bb: bt; next_tmp: nt; })
                            } else {
                              s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: host_eprintln expects (Text)"))
                            }
                          } else {
                            s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: host_eprintln expects (Text)"))
                          }
                        } else {
                        if all_i64 == true {
                          let tmp_id: Text = int_to_text(nt);
                          let tmp: Text = text_concat("%t", tmp_id);
                          let call_head: Text = text_concat(text_concat(text_concat("  ", tmp), " = call i64 @"), fname);
                          let inst: Text = text_concat(text_concat(call_head, "("), text_concat(at, ")"));
                          let out2: Text = s1_cg_line(ot, inst);
                          s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: "i64"; bb: bt; next_tmp: nt + 1; })
                        } else {
                          s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: call expects i64 args in v0"))
                        }
                        }
                      }
                    }
                  }
                }
              }
            };
          }
        };
        _ => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: callee must be a path in v0"));
      }
    };
    If(i) => {
      let c_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(out, env, next_tmp, bb, strs, i.cond);
      match c_r {
        Err(e1) => s1_cg_expr_err(e1);
        Ok(c0) => {
          if c0.ty == "i1" {
            match i.else_block {
              None => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: if expression requires else branch in v0"));
              Some(else_b) => {
                match i.then_block.result {
                  None => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: if-then block has no value"));
                  Some(then_e) => {
                    match else_b.result {
                      None => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: if-else block has no value"));
                      Some(else_e) => {
                        // Allocate labels.
                        let then_id: Text = int_to_text(c0.next_tmp);
                        let then_lbl: Text = text_concat("then", then_id);
                        let else_id: Text = int_to_text(c0.next_tmp + 1);
                        let else_lbl: Text = text_concat("else", else_id);
                        let join_id: Text = int_to_text(c0.next_tmp + 2);
                        let join_lbl: Text = text_concat("join", join_id);
                        let nt0: Int = c0.next_tmp + 3;

                        let br1: Text = text_concat(text_concat("  br i1 ", c0.value), text_concat(text_concat(", label %", then_lbl), text_concat(", label %", else_lbl)));
                        let out_br: Text = s1_cg_line(c0.text, br1);

                        // then:
                        let out_then_lbl: Text = s1_cg_line(out_br, text_concat(then_lbl, ":"));
                        let tr: Result<S1CgBlockOut, S1Diagnostic> =
                          s1_cg_emit_stmt_list_min(out_then_lbl, env, nt0, then_lbl, strs, i.then_block.stmts);
                        match tr {
                          Err(e2) => s1_cg_expr_err(e2);
                          Ok(tb) => {
                            let t_r: Result<S1CgExprOut, S1Diagnostic> =
                              s1_cg_emit_expr_min(tb.text, tb.env, tb.next_tmp, tb.bb, strs, then_e);
                            match t_r {
                              Err(e3) => s1_cg_expr_err(e3);
                              Ok(t0) => {
                                let out_then_end: Text = s1_cg_line(t0.text, text_concat("  br label %", join_lbl));

                                // else:
                                let out_else_lbl: Text = s1_cg_line(out_then_end, text_concat(else_lbl, ":"));
                                let er: Result<S1CgBlockOut, S1Diagnostic> =
                                  s1_cg_emit_stmt_list_min(out_else_lbl, env, t0.next_tmp, else_lbl, strs, else_b.stmts);
                                match er {
                                  Err(e4) => s1_cg_expr_err(e4);
                                  Ok(eb) => {
                                    let e_r: Result<S1CgExprOut, S1Diagnostic> =
                                      s1_cg_emit_expr_min(eb.text, eb.env, eb.next_tmp, eb.bb, strs, else_e);
                                    match e_r {
                                      Err(e5) => s1_cg_expr_err(e5);
                                      Ok(e0) => {
                                        if e0.ty == t0.ty {
                                          if t0.ty == "i64" {
                                            let out_else_end: Text = s1_cg_line(e0.text, text_concat("  br label %", join_lbl));
                                            let out_join_lbl: Text = s1_cg_line(out_else_end, text_concat(join_lbl, ":"));
                                            let phi_id: Text = int_to_text(e0.next_tmp);
                                            let phi_tmp: Text = text_concat("%t", phi_id);
                                            let p1: Text = text_concat(text_concat(text_concat("  ", phi_tmp), " = phi "), text_concat(t0.ty, " "));
                                            let in1: Text = text_concat(text_concat("[ ", t0.value), text_concat(text_concat(", %", t0.bb), " ]"));
                                            let in2: Text = text_concat(text_concat("[ ", e0.value), text_concat(text_concat(", %", e0.bb), " ]"));
                                            let inst: Text = text_concat(text_concat(p1, in1), text_concat(", ", in2));
                                            let out_phi: Text = s1_cg_line(out_join_lbl, inst);
                                            s1_cg_expr_ok(S1CgExprOut { text: out_phi; value: phi_tmp; ty: t0.ty; bb: join_lbl; next_tmp: e0.next_tmp + 1; })
                                          } else {
                                            if t0.ty == "i1" {
                                              let out_else_end: Text = s1_cg_line(e0.text, text_concat("  br label %", join_lbl));
                                              let out_join_lbl: Text = s1_cg_line(out_else_end, text_concat(join_lbl, ":"));
                                              let phi_id: Text = int_to_text(e0.next_tmp);
                                              let phi_tmp: Text = text_concat("%t", phi_id);
                                              let p1: Text = text_concat(text_concat(text_concat("  ", phi_tmp), " = phi "), text_concat(t0.ty, " "));
                                              let in1: Text = text_concat(text_concat("[ ", t0.value), text_concat(text_concat(", %", t0.bb), " ]"));
                                              let in2: Text = text_concat(text_concat("[ ", e0.value), text_concat(text_concat(", %", e0.bb), " ]"));
                                              let inst: Text = text_concat(text_concat(p1, in1), text_concat(", ", in2));
                                              let out_phi: Text = s1_cg_line(out_join_lbl, inst);
                                              s1_cg_expr_ok(S1CgExprOut { text: out_phi; value: phi_tmp; ty: t0.ty; bb: join_lbl; next_tmp: e0.next_tmp + 1; })
                                            } else {
                                              s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: if branch type not supported in v0"))
                                            }
                                          }
                                        } else {
                                          s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: if branches must return same type in v0"))
                                        }
                                      };
                                    }
                                  };
                                }
                              };
                            }
                          };
                        }
                      };
                    }
                  };
                }
              };
            }
          } else {
            s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: if condition must be Bool (i1)"))
          }
        };
      }
    };
    Block(b) => {
      match b.result {
        None => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: block has no value"));
        Some(e2) => {
          let br: Result<S1CgBlockOut, S1Diagnostic> = s1_cg_emit_stmt_list_min(out, env, next_tmp, bb, strs, b.stmts);
          match br {
            Err(e3) => s1_cg_expr_err(e3);
            Ok(b0) => {
              // Block scope: use the extended env for the tail expression, but do not leak it to callers.
              let rr: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(b0.text, b0.env, b0.next_tmp, b0.bb, strs, e2);
              match rr {
                Err(e4) => s1_cg_expr_err(e4);
                Ok(r0) => {
                  s1_cg_expr_ok(S1CgExprOut { text: r0.text; value: r0.value; ty: r0.ty; bb: r0.bb; next_tmp: r0.next_tmp; })
                };
              }
            };
          }
        };
      }
    };
    _ => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: expr kind not supported in v0"));
  }
};

fn s1_cg_emit_while_stmt_min(out: Text, env: List<S1CgEnvBind>, next_tmp: Int, strs: List<S1CgStrConst>, w: S1While) -> Result<S1CgBlockOut, S1Diagnostic> {
  let cond_id: Text = int_to_text(next_tmp);
  let cond_lbl: Text = text_concat("while_cond", cond_id);
  let body_id: Text = int_to_text(next_tmp + 1);
  let body_lbl: Text = text_concat("while_body", body_id);
  let end_id: Text = int_to_text(next_tmp + 2);
  let end_lbl: Text = text_concat("while_end", end_id);
  let nt0: Int = next_tmp + 3;

  let out1: Text = s1_cg_line(out, text_concat("  br label %", cond_lbl));
  let out2: Text = s1_cg_line(out1, text_concat(cond_lbl, ":"));
  let cond_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(out2, env, nt0, cond_lbl, strs, w.cond);
  match cond_r {
    Err(e) => s1_cg_block_err(e);
    Ok(c0) => {
      if c0.ty == "i1" {
        let br2: Text =
          text_concat(
            text_concat(text_concat("  br i1 ", c0.value), text_concat(", label %", body_lbl)),
            text_concat(", label %", end_lbl)
          );
        let out3: Text = s1_cg_line(c0.text, br2);
        let out4: Text = s1_cg_line(out3, text_concat(body_lbl, ":"));

        let body_env: List<S1CgEnvBind> = env;
        let body_r: Result<S1CgBlockOut, S1Diagnostic> =
          s1_cg_emit_stmt_list_min(out4, body_env, c0.next_tmp, body_lbl, strs, w.body.stmts);
        match body_r {
          Err(e2) => s1_cg_block_err(e2);
          Ok(b0) => {
            let ot: Text = b0.text;
            let nt: Int = b0.next_tmp;
            let env2: List<S1CgEnvBind> = b0.env;

            // Evaluate (and drop) tail expr if present.
            match w.body.result {
              None => {
                let out_back: Text = s1_cg_line(ot, text_concat("  br label %", cond_lbl));
                let out_end: Text = s1_cg_line(out_back, text_concat(end_lbl, ":"));
                s1_cg_block_ok(S1CgBlockOut { text: out_end; env: env; bb: end_lbl; next_tmp: nt; })
              };
              Some(expr) => {
                let rr: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(ot, env2, nt, b0.bb, strs, expr);
                match rr {
                  Err(e3) => s1_cg_block_err(e3);
                  Ok(r0) => {
                    let out_back: Text = s1_cg_line(r0.text, text_concat("  br label %", cond_lbl));
                    let out_end: Text = s1_cg_line(out_back, text_concat(end_lbl, ":"));
                    s1_cg_block_ok(S1CgBlockOut { text: out_end; env: env; bb: end_lbl; next_tmp: r0.next_tmp; })
                  };
                }
              };
            }
          };
        }
      } else {
        s1_cg_block_err(s1_diag(Error, 0, 0, "codegen: while condition must be Bool (i1)"))
      }
    };
  }
};

fn s1_cg_emit_stmt_list_min(out: Text, env: List<S1CgEnvBind>, next_tmp: Int, bb: Text, strs: List<S1CgStrConst>, stmts: List<S1Stmt>) -> Result<S1CgBlockOut, S1Diagnostic> {
  let ot: Text = out;
  let envt: List<S1CgEnvBind> = env;
  let bbt: Text = bb;
  let nt: Int = next_tmp;
  let ok: Bool = true;
  let diag: S1Diagnostic = s1_diag(Error, 0, 0, "codegen: stmt list failed");

  let cur: List<S1Stmt> = stmts;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        if ok == false {
          done = true;
          0
        } else {
          match c0.head {
            Let(l0) => {
              let rr: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(ot, envt, nt, bbt, strs, l0.value);
              match rr {
                Err(e) => { ok = false; diag = e; done = true; 0 };
                Ok(r) => {
                  // Only Int/Bool/Text locals in v0.
                  let expected: Text = "i64";
                  if s1_cg_type_is_plain_int(l0.ty) == true {
                    expected = "i64";
                    0
                  } else {
                    if s1_cg_type_is_plain_bool(l0.ty) == true {
                      expected = "i1";
                      0
                    } else {
                      if s1_cg_type_is_plain_text(l0.ty) == true {
                        expected = "i8*";
                        0
                      } else {
                        ok = false;
                        diag = s1_diag(Error, 0, 0, "codegen: let type not supported in v0");
                        done = true;
                        0
                      }
                    }
                  };

                  if ok == true {
                    if r.ty == expected {
                      let slot_id: Text = int_to_text(r.next_tmp);
                      let slot: Text = text_concat("%t", slot_id);
                      let alloca_inst: Text = text_concat(text_concat(text_concat("  ", slot), " = alloca "), expected);
                      let out1: Text = s1_cg_line(r.text, alloca_inst);
                      let store_head: Text = text_concat(text_concat("  store ", expected), text_concat(" ", r.value));
                      let store_tail: Text = text_concat(text_concat(", ", expected), text_concat("* ", slot));
                      let out2: Text = s1_cg_line(out1, text_concat(store_head, store_tail));

                      let bind: S1CgEnvBind = S1CgEnvBind { name: l0.name; llvm: slot; ty: expected; };
                      envt = Cons(ListCons<S1CgEnvBind> { head: bind; tail: envt; });
                      ot = out2;
                      bbt = r.bb;
                      nt = r.next_tmp + 1;
                      cur = c0.tail;
                      0
                    } else {
                      ok = false;
                      diag = s1_diag(Error, 0, 0, "codegen: let value type mismatch in v0");
                      done = true;
                      0
                    }
                  } else { 0 };
                  0
                };
              }
            };
            Assign(a0) => {
              match s1_cg_lookup_env(envt, a0.name) {
                None => {
                  ok = false;
                  diag = s1_diag(Error, 0, 0, text_concat("codegen: assignment to unknown variable ", a0.name));
                  done = true;
                  0
                };
                Some(v) => {
                  let rr: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(ot, envt, nt, bbt, strs, a0.value);
                  match rr {
                    Err(e) => { ok = false; diag = e; done = true; 0 };
                    Ok(r) => {
                      if r.ty == v.ty {
                        let store_head: Text = text_concat(text_concat("  store ", v.ty), text_concat(" ", r.value));
                        let store_tail: Text = text_concat(text_concat(", ", v.ty), text_concat("* ", v.llvm));
                        ot = s1_cg_line(r.text, text_concat(store_head, store_tail));
                        bbt = r.bb;
                        nt = r.next_tmp;
                        cur = c0.tail;
                        0
                      } else {
                        ok = false;
                        diag = s1_diag(Error, 0, 0, "codegen: assignment type mismatch in v0");
                        done = true;
                        0
                      }
                    };
                  }
                };
              }
            };
            While(w0) => {
              let wr: Result<S1CgBlockOut, S1Diagnostic> = s1_cg_emit_while_stmt_min(ot, envt, nt, strs, w0);
              match wr {
                Err(e) => { ok = false; diag = e; done = true; 0 };
                Ok(b) => {
                  ot = b.text;
                  bbt = b.bb;
                  nt = b.next_tmp;
                  cur = c0.tail;
                  0
                };
              }
            };
            ExprStmt(e0) => {
              let rr: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(ot, envt, nt, bbt, strs, e0);
              match rr {
                Err(e) => { ok = false; diag = e; done = true; 0 };
                Ok(r) => {
                  ot = r.text;
                  bbt = r.bb;
                  nt = r.next_tmp;
                  cur = c0.tail;
                  0
                };
              }
            };
            Return(_r0) => {
              ok = false;
              diag = s1_diag(Error, 0, 0, "codegen: return statement not supported in v0 subset");
              done = true;
              0
            };
          };
          0
        };
        0
      };
    }
  };

  if ok == false {
    s1_cg_block_err(diag)
  } else {
    s1_cg_block_ok(S1CgBlockOut { text: ot; env: envt; bb: bbt; next_tmp: nt; })
  }
};

fn s1_cg_emit_function_min(out: Text, strs: List<S1CgStrConst>, f: S1Function) -> Result<Text, S1Diagnostic> {
  // Caller must ensure `s1_cg_function_supported(f) == true`.
  let params_str: Text = "";
  let curp: List<S1Param> = f.params;
  let donep: Bool = false;
  let ps: Text = params_str;
  let first: Bool = true;
  while donep == false {
    match curp {
      Nil => { donep = true; 0 };
      Cons(c0) => {
        let seg: Text = text_concat("i64 %", c0.head.name);
        if first == true {
          ps = seg;
          first = false;
          0
        } else {
          ps = text_concat(text_concat(ps, ", "), seg);
          0
        };
        curp = c0.tail;
        0
      };
    }
  };

  match f.body {
    None => s1_cg_text_ok(out);
    Some(body) => {
      let out1: Text = s1_cg_line(out, text_concat(text_concat("define i64 @", f.name), text_concat("(", text_concat(ps, ") {"))));
      let out2: Text = s1_cg_line(out1, "entry:");

      // Parameters become stack slots so assignment works without SSA/phi complexity.
      let env: List<S1CgEnvBind> = Nil;
      let ot: Text = out2;
      let nt: Int = 0;
      let pcur: List<S1Param> = f.params;
      let pdone: Bool = false;
      while pdone == false {
        match pcur {
          Nil => { pdone = true; 0 };
          Cons(pc0) => {
            let slot_id: Text = int_to_text(nt);
            let slot: Text = text_concat("%t", slot_id);
            let alloca_inst: Text = text_concat(text_concat(text_concat("  ", slot), " = alloca "), "i64");
            let out3: Text = s1_cg_line(ot, alloca_inst);
            let store_head: Text = text_concat("  store i64 %", pc0.head.name);
            let store_tail: Text = text_concat(", i64* ", slot);
            let out4: Text = s1_cg_line(out3, text_concat(store_head, store_tail));

            let bind: S1CgEnvBind = S1CgEnvBind { name: pc0.head.name; llvm: slot; ty: "i64"; };
            env = Cons(ListCons<S1CgEnvBind> { head: bind; tail: env; });
            ot = out4;
            nt = nt + 1;
            pcur = pc0.tail;
            0
          };
        }
      };

      let stmts_r: Result<S1CgBlockOut, S1Diagnostic> = s1_cg_emit_stmt_list_min(ot, env, nt, "entry", strs, body.stmts);
      match stmts_r {
        Err(e) => s1_cg_text_err(e);
        Ok(s0) => {
          match body.result {
            None => s1_cg_text_err(s1_diag(Error, 0, 0, "codegen: function body has no result"));
            Some(expr) => {
              let rr: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(s0.text, s0.env, s0.next_tmp, s0.bb, strs, expr);
              match rr {
                Err(e2) => s1_cg_text_err(e2);
                Ok(r0) => {
                  if r0.ty == "i64" {
                    let out3: Text = s1_cg_line(r0.text, text_concat("  ret i64 ", r0.value));
                    let out4: Text = s1_cg_line(out3, "}");
                    let out5: Text = s1_cg_line(out4, "");
                    s1_cg_text_ok(out5)
                  } else {
                    s1_cg_text_err(s1_diag(Error, 0, 0, "codegen: function result must be Int in v0"))
                  }
                };
              }
            };
          }
        };
      }
    };
  }
};

fn s1_cg_text_list_contains(xs: List<Text>, value: Text) -> Bool {
  let ok: Bool = false;
  let cur: List<Text> = xs;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        if c0.head == value { ok = true; done = true; 0 } else { cur = c0.tail; 0 };
        0
      };
    }
  };
  ok
};

fn s1_cg_add_str_lit(acc: List<Text>, lit: Text) -> List<Text> {
  if s1_cg_text_list_contains(acc, lit) == true {
    acc
  } else {
    let out: List<Text> = Cons(ListCons<Text> { head: lit; tail: acc; });
    out
  }
};

fn s1_cg_reverse_text_list(xs: List<Text>) -> List<Text> {
  let out: List<Text> = Nil;
  let cur: List<Text> = xs;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        out = Cons(ListCons<Text> { head: c0.head; tail: out; });
        cur = c0.tail;
        0
      };
    }
  };
  out
};

fn s1_cg_reverse_str_const_list(xs: List<S1CgStrConst>) -> List<S1CgStrConst> {
  let out: List<S1CgStrConst> = Nil;
  let cur: List<S1CgStrConst> = xs;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        out = Cons(ListCons<S1CgStrConst> { head: c0.head; tail: out; });
        cur = c0.tail;
        0
      };
    }
  };
  out
};

fn s1_cg_collect_strs_expr(acc: List<Text>, e: S1Expr) -> List<Text> {
  match e {
    IntLit(_n) => acc;
    BoolLit(_b) => acc;
    Path(_p) => acc;
    StringLit(s) => s1_cg_add_str_lit(acc, s);
    Member(m) => s1_cg_collect_strs_expr(acc, m.base);
    Binary(b) => {
      let a1: List<Text> = s1_cg_collect_strs_expr(acc, b.left);
      s1_cg_collect_strs_expr(a1, b.right)
    };
    Call(c) => {
      let a1: List<Text> = s1_cg_collect_strs_expr(acc, c.callee);
      let cur: List<S1Expr> = c.args;
      let out: List<Text> = a1;
      let done: Bool = false;
      while done == false {
        match cur {
          Nil => { done = true; 0 };
          Cons(c0) => { out = s1_cg_collect_strs_expr(out, c0.head); cur = c0.tail; 0 };
        }
      };
      out
    };
    Block(b) => s1_cg_collect_strs_block(acc, b);
    If(i) => {
      let a1: List<Text> = s1_cg_collect_strs_expr(acc, i.cond);
      let a2: List<Text> = s1_cg_collect_strs_block(a1, i.then_block);
      match i.else_block {
        None => a2;
        Some(eb) => s1_cg_collect_strs_block(a2, eb);
      }
    };
    Match(m) => {
      let a1: List<Text> = s1_cg_collect_strs_expr(acc, m.scrutinee);
      let cur: List<S1MatchArm> = m.arms;
      let out: List<Text> = a1;
      let done: Bool = false;
      while done == false {
        match cur {
          Nil => { done = true; 0 };
          Cons(c0) => { out = s1_cg_collect_strs_expr(out, c0.head.value); cur = c0.tail; 0 };
        }
      };
      out
    };
    RecordLit(r) => {
      let cur: List<S1RecordLitField> = r.fields;
      let out: List<Text> = acc;
      let done: Bool = false;
      while done == false {
        match cur {
          Nil => { done = true; 0 };
          Cons(c0) => { out = s1_cg_collect_strs_expr(out, c0.head.value); cur = c0.tail; 0 };
        }
      };
      out
    };
  }
};

fn s1_cg_collect_strs_block(acc: List<Text>, b: S1Block) -> List<Text> {
  let out: List<Text> = acc;
  let cur: List<S1Stmt> = b.stmts;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        match c0.head {
          Let(l) => { out = s1_cg_collect_strs_expr(out, l.value); 0 };
          Assign(a) => { out = s1_cg_collect_strs_expr(out, a.value); 0 };
          Return(r) => { out = s1_cg_collect_strs_expr(out, r.value); 0 };
          ExprStmt(e) => { out = s1_cg_collect_strs_expr(out, e); 0 };
          While(w) => {
            out = s1_cg_collect_strs_expr(out, w.cond);
            out = s1_cg_collect_strs_block(out, w.body);
            0
          };
        };
        cur = c0.tail;
        0
      };
    }
  };
  match b.result {
    None => out;
    Some(e2) => s1_cg_collect_strs_expr(out, e2);
  }
};

fn s1_cg_collect_strs_program(p: S1Program) -> List<Text> {
  let acc: List<Text> = Nil;
  let cur: List<S1Item> = p.items;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        match c0.head {
          Function(f) => {
            match f.body {
              None => 0;
              Some(b) => { acc = s1_cg_collect_strs_block(acc, b); 0 };
            };
            0
          };
          _ => 0;
        };
        cur = c0.tail;
        0
      };
    }
  };
  s1_cg_reverse_text_list(acc)
};

fn s1_cg_build_str_table(lits: List<Text>) -> List<S1CgStrConst> {
  let acc: List<S1CgStrConst> = Nil;
  let next_id: Int = 0;
  let cur: List<Text> = lits;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        let global: Text = text_concat("@.str.", int_to_text(next_id));
        let n: Int = text_len(c0.head) + 1;
        let sc: S1CgStrConst = S1CgStrConst { lit: c0.head; global: global; n: n; };
        acc = Cons(ListCons<S1CgStrConst> { head: sc; tail: acc; });
        next_id = next_id + 1;
        cur = c0.tail;
        0
      };
    }
  };
  s1_cg_reverse_str_const_list(acc)
};

fn s1_cg_llvm_i8_array_init(s: Text) -> Text {
  // Emit a numeric i8 array initializer to avoid relying on LLVM c"..." escaping.
  // Example: [i8 52, i8 50, i8 0]
  let pieces: Text = "";
  let out: Text = pieces;
  let first: Bool = true;

  let i: Int = 0;
  let n: Int = text_len(s);
  let done: Bool = false;
  while done == false {
    if i == n {
      done = true;
      0
    } else {
      match text_byte_at(s, i) {
        None => 0;
        Some(b) => {
          let piece: Text = text_concat("i8 ", int_to_text(b));
          if first == true {
            out = piece;
            first = false;
            0
          } else {
            out = text_concat(text_concat(out, ", "), piece);
            0
          };
          0
        };
      };
      i = i + 1;
      0
    };
  };

  // NUL terminator.
  if first == true {
    out = "i8 0";
    0
  } else {
    out = text_concat(out, ", i8 0");
    0
  };

  text_concat("[", text_concat(out, "]"))
};

fn s1_cg_llvm_escape_text_bytes(s: Text) -> Text {
  let out: Text = "";
  let i: Int = 0;
  let n: Int = text_len(s);
  let done: Bool = false;
  while done == false {
    if i == n {
      done = true;
      0
    } else {
      match text_byte_at(s, i) {
        None => 0;
        Some(b) => {
          if b == 10 { out = text_concat(out, "\\0A"); 0 } else { 0 };
          if b == 13 { out = text_concat(out, "\\0D"); 0 } else { 0 };
          if b == 9 { out = text_concat(out, "\\09"); 0 } else { 0 };
          if b == 34 { out = text_concat(out, "\\22"); 0 } else { 0 }; // "
          if b == 92 { out = text_concat(out, "\\5C"); 0 } else { 0 }; // \
          if b == 0 { out = text_concat(out, "\\00"); 0 } else { 0 };

          let special: Bool = false;
          if b == 10 { special = true; 0 } else { 0 };
          if b == 13 { special = true; 0 } else { 0 };
          if b == 9 { special = true; 0 } else { 0 };
          if b == 34 { special = true; 0 } else { 0 };
          if b == 92 { special = true; 0 } else { 0 };
          if b == 0 { special = true; 0 } else { 0 };

          if special == false {
            match text_slice(s, i, i + 1) {
              None => { out = text_concat(out, "?"); 0 };
              Some(ch) => { out = text_concat(out, ch); 0 };
            }
          } else { 0 };
          0
        };
      };
      i = i + 1;
      0
    };
  };
  out
};

fn s1_cg_emit_prelude(strs: List<S1CgStrConst>) -> Text {
  let out: Text = "";
  let ot: Text = out;

  ot = s1_cg_line(ot, "; ModuleID = 'kooix_stage1_v0'");
  ot = s1_cg_line(ot, "source_filename = \"kooix\"");
  ot = s1_cg_line(ot, "");

  // Minimal runtime + libc intrinsics used by Stage0 native backend.
  ot = s1_cg_line(ot, "declare i8* @malloc(i64)");
  ot = s1_cg_line(ot, "declare i64 @strlen(i8*)");
  ot = s1_cg_line(ot, "declare i32 @memcmp(i8*, i8*, i64)");
  ot = s1_cg_line(ot, "declare i8* @memcpy(i8*, i8*, i64)");
  ot = s1_cg_line(ot, "declare i32 @strcmp(i8*, i8*)");
  ot = s1_cg_line(ot, "");

  // Native host intrinsics (provided by crates/kooixc/native_runtime/runtime.c).
  ot = s1_cg_line(ot, "declare i8* @kx_host_load_source_map(i8*)");
  ot = s1_cg_line(ot, "declare void @kx_host_eprintln(i8*)");
  ot = s1_cg_line(ot, "declare i8* @kx_host_write_file(i8*, i8*)");
  ot = s1_cg_line(ot, "declare i8* @kx_text_concat(i8*, i8*)");
  ot = s1_cg_line(ot, "declare i8* @kx_int_to_text(i64)");
  ot = s1_cg_line(ot, "");

  // String constants used by StringLit.
  let cur: List<S1CgStrConst> = strs;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        let init: Text = s1_cg_llvm_i8_array_init(c0.head.lit);
        let n_txt: Text = int_to_text(c0.head.n);
        let head: Text = text_concat(text_concat(text_concat(text_concat(c0.head.global, " = private unnamed_addr constant ["), n_txt), " x i8] "), init);
        let line: Text = text_concat(head, ", align 1");
        ot = s1_cg_line(ot, line);
        cur = c0.tail;
        0
      };
    }
  };

  match strs {
    Nil => ot;
    _ => s1_cg_line(ot, "");
  }
};

fn s1_emit_llvm_ir_real(source: Text) -> Result<Text, S1Diagnostic>
intent "Stage1 LLVM IR emitter (v0 real): parse+check then emit minimal LLVM for Int-only functions"
evidence {
  trace "stage1.emit_llvm_real.v0";
  metrics [stage1_emit_llvm_real_calls];
}
{
  let tokens: Result<List<S1Token>, S1Diagnostic> = s1_lex(source);
  match tokens {
    Err(e) => s1_cg_text_err(e);
    Ok(ts) => {
      let ast_r: Result<S1Program, S1Diagnostic> = s1_parse(ts);
      match ast_r {
        Err(e2) => s1_cg_text_err(e2);
        Ok(p) => {
          let res_r: Result<S1Program, S1Diagnostic> = s1_resolve_program(p);
          match res_r {
            Err(e3) => s1_cg_text_err(e3);
            Ok(p2) => {
              let tc_r: Result<S1Program, S1Diagnostic> = s1_typecheck_program(p2);
              match tc_r {
                Err(e4) => s1_cg_text_err(e4);
                Ok(p3) => {
                  let lits: List<Text> = s1_cg_collect_strs_program(p3);
                  let strs: List<S1CgStrConst> = s1_cg_build_str_table(lits);
                  let out: Text = s1_cg_emit_prelude(strs);
                  let cur: List<S1Item> = p3.items;
                  let done: Bool = false;
                  let ot: Text = out;
                  let ok_cg: Bool = true;
                  let diag_cg: S1Diagnostic = s1_diag(Error, 0, 0, "codegen: failed");
                  let emitted_main: Bool = false;

                  while done == false {
                    match cur {
                      Nil => {
                        done = true;
                        0
                      };
                      Cons(c0) => {
                        match c0.head {
                          Function(f) => {
                            if s1_cg_function_supported(f) == true {
                              match s1_cg_emit_function_min(ot, strs, f) {
                                Err(e5) => {
                                  ok_cg = false;
                                  diag_cg = e5;
                                  done = true;
                                  0
                                };
                                Ok(t2) => {
                                  ot = t2;
                                  if f.name == "main" { emitted_main = true; 0 } else { 0 };
                                  0
                                };
                              };
                              0
                            } else {
                              0
                            };
                            0
                          };
                          _ => 0;
                        };
                        cur = c0.tail;
                        0
                      };
                    }
                  };

                  if ok_cg == false {
                    s1_cg_text_err(diag_cg)
                  } else {
                    if emitted_main == false {
                      s1_cg_text_err(s1_diag(Error, 0, 0, "codegen: no supported main() -> Int function found (v0 Int-only subset)"))
                    } else {
                      s1_cg_text_ok(ot)
                    }
                  }
                };
              }
            };
          }
        };
      }
    };
  }
};

fn s1_emit_llvm_ir(_source: Text) -> Result<Text, S1Diagnostic>
intent "Stage1 LLVM IR emitter (v0): parse+check then emit minimal LLVM IR subset"
evidence {
  trace "stage1.emit_llvm.v0";
  metrics [stage1_emit_llvm_calls];
}
{
  s1_emit_llvm_ir_real(_source)
};
