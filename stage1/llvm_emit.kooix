import "../stdlib/prelude";
import "diag";
import "ast";
import "lexer";
import "parser";
import "resolver";
import "typecheck";

record S1CgEnvBind { name: Text; llvm: Text; ty: Text; s1_ty: S1Type; };
record S1CgExprOut { text: Text; value: Text; ty: Text; s1_ty: Option<S1Type>; bb: Text; next_tmp: Int; };
record S1CgBlockOut { text: Text; env: List<S1CgEnvBind>; bb: Text; next_tmp: Int; };
record S1CgStrConst { lit: Text; global: Text; n: Int; };
record S1CgFnSig { name: Text; ret_llvm: Text; params_llvm: List<Text>; ret_s1: S1Type; };
record S1CgEnumVariantInfo { enum_name: Text; tag: Int; payload_ty: Option<S1Type>; };

fn s1_cg_s1_type_prim(name: Text) -> S1Type {
  let seg_tail: List<Text> = Nil;
  let segs: List<Text> = Cons(ListCons<Text> { head: name; tail: seg_tail; });
  let path: S1Path = S1Path { segments: segs; };
  let args: List<S1Type> = Nil;
  S1Type { path: path; args: args; }
};

fn s1_cg_s1_type_option_int() -> S1Type {
  s1_cg_s1_type_option(s1_cg_s1_type_prim("Int"))
};

fn s1_cg_s1_type_option_text() -> S1Type {
  s1_cg_s1_type_option(s1_cg_s1_type_prim("Text"))
};

fn s1_cg_s1_type_option(payload: S1Type) -> S1Type {
  let seg_tail: List<Text> = Nil;
  let segs: List<Text> = Cons(ListCons<Text> { head: "Option"; tail: seg_tail; });
  let path: S1Path = S1Path { segments: segs; };
  let args_tail: List<S1Type> = Nil;
  let args: List<S1Type> = Cons(ListCons<S1Type> { head: payload; tail: args_tail; });
  S1Type { path: path; args: args; }
};

fn s1_cg_s1_type_result(ok_ty: S1Type, err_ty: S1Type) -> S1Type {
  let seg_tail: List<Text> = Nil;
  let segs: List<Text> = Cons(ListCons<Text> { head: "Result"; tail: seg_tail; });
  let path: S1Path = S1Path { segments: segs; };
  let args0_tail: List<S1Type> = Nil;
  let args0: List<S1Type> = Cons(ListCons<S1Type> { head: ok_ty; tail: args0_tail; });
  let args: List<S1Type> = Cons(ListCons<S1Type> { head: err_ty; tail: args0; });
  // Note: we build args in reverse then fix order below (small lists, simple).
  let out: List<S1Type> = Nil;
  let cur: List<S1Type> = args;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => { out = Cons(ListCons<S1Type> { head: c0.head; tail: out; }); cur = c0.tail; 0 };
    }
  };
  S1Type { path: path; args: out; }
};

fn s1_cg_s1_type_list(elem_ty: S1Type) -> S1Type {
  let seg_tail: List<Text> = Nil;
  let segs: List<Text> = Cons(ListCons<Text> { head: "List"; tail: seg_tail; });
  let path: S1Path = S1Path { segments: segs; };
  let args_tail: List<S1Type> = Nil;
  let args: List<S1Type> = Cons(ListCons<S1Type> { head: elem_ty; tail: args_tail; });
  S1Type { path: path; args: args; }
};

fn s1_cg_s1_type_list_cons(elem_ty: S1Type) -> S1Type {
  let seg_tail: List<Text> = Nil;
  let segs: List<Text> = Cons(ListCons<Text> { head: "ListCons"; tail: seg_tail; });
  let path: S1Path = S1Path { segments: segs; };
  let args_tail: List<S1Type> = Nil;
  let args: List<S1Type> = Cons(ListCons<S1Type> { head: elem_ty; tail: args_tail; });
  S1Type { path: path; args: args; }
};

fn s1_cg_s1_ty_some(t: S1Type) -> Option<S1Type> {
  let out: Option<S1Type> = Some(t);
  out
};

fn s1_cg_s1_ty_none() -> Option<S1Type> {
  let out: Option<S1Type> = None;
  out
};

fn s1_cg_type_is_plain_int(ty: S1Type) -> Bool {
  let ok: Bool = false;
  match ty.args {
    Nil => {
      match s1_cg_path_single_name(ty.path) {
        Some(name) => {
          if name == "Int" { ok = true; 0 } else { 0 };
          0
        };
        _ => 0;
      };
      0
    };
    _ => 0;
  };
  ok
};

fn s1_cg_type_is_plain_bool(ty: S1Type) -> Bool {
  let ok: Bool = false;
  match ty.args {
    Nil => {
      match s1_cg_path_single_name(ty.path) {
        Some(name) => {
          if name == "Bool" { ok = true; 0 } else { 0 };
          0
        };
        _ => 0;
      };
      0
    };
    _ => 0;
  };
  ok
};

fn s1_cg_type_is_plain_text(ty: S1Type) -> Bool {
  let ok: Bool = false;
  match ty.args {
    Nil => {
      match s1_cg_path_single_name(ty.path) {
        Some(name) => {
          if name == "Text" { ok = true; 0 } else { 0 };
          0
        };
        _ => 0;
      };
      0
    };
    _ => 0;
  };
  ok
};

fn s1_cg_type_is_option_int(ty: S1Type) -> Bool {
  let ok: Bool = false;
  match s1_cg_path_single_name(ty.path) {
    Some(name) => {
      if name == "Option" {
        match ty.args {
          Cons(a0) => {
            match a0.tail {
              Nil => {
                if s1_cg_type_is_plain_int(a0.head) { ok = true; 0 } else { 0 };
                0
              };
              _ => 0;
            };
            0
          };
          _ => 0;
        };
        0
      } else { 0 };
      0
    };
    _ => 0;
  };
  ok
};

fn s1_cg_type_is_option(ty: S1Type) -> Bool {
  let ok: Bool = false;
  match s1_cg_path_single_name(ty.path) {
    Some(name) => {
      if name == "Option" {
        match ty.args {
          Cons(a0) => {
            match a0.tail {
              Nil => { ok = true; 0 };
              _ => 0;
            };
            0
          };
          _ => 0;
        };
        0
      } else { 0 };
      0
    };
    _ => 0;
  };
  ok
};

fn s1_cg_type_is_result(ty: S1Type) -> Bool {
  let ok: Bool = false;
  match s1_cg_path_single_name(ty.path) {
    Some(name) => {
      if name == "Result" {
        match ty.args {
          Cons(a0) => {
            match a0.tail {
              Cons(b0) => {
                match b0.tail {
                  Nil => { ok = true; 0 };
                  _ => 0;
                };
                0
              };
              _ => 0;
            };
            0
          };
          _ => 0;
        };
        0
      } else { 0 };
      0
    };
    _ => 0;
  };
  ok
};

fn s1_cg_type_is_list(ty: S1Type) -> Bool {
  let ok: Bool = false;
  match s1_cg_path_single_name(ty.path) {
    Some(name) => {
      if name == "List" {
        match ty.args {
          Cons(a0) => {
            match a0.tail {
              Nil => { ok = true; 0 };
              _ => 0;
            };
            0
          };
          _ => 0;
        };
        0
      } else { 0 };
      0
    };
    _ => 0;
  };
  ok
};

fn s1_cg_llvm_ty_of_s1(ty: S1Type) -> Option<Text> {
  let out: Option<Text> = None;
  if s1_cg_type_is_plain_int(ty) == true { out = Some("i64"); 0 } else { 0 };
  if s1_cg_type_is_plain_bool(ty) == true { out = Some("i1"); 0 } else { 0 };
  if s1_cg_type_is_plain_text(ty) == true { out = Some("i8*"); 0 } else { 0 };
  if s1_cg_type_is_option(ty) == true { out = Some("%Option*"); 0 } else { 0 };
  if s1_cg_type_is_result(ty) == true { out = Some("%Result*"); 0 } else { 0 };
  if s1_cg_type_is_list(ty) == true { out = Some("%List*"); 0 } else { 0 };
  // Any other record type: represent as opaque heap pointer.
  match out {
    None => { out = Some("i8*"); 0 };
    _ => 0;
  };
  out
};

fn s1_cg_llvm_tys_of_params(params: List<S1Param>) -> Option<List<Text>> {
  let out: List<Text> = Nil;
  let cur: List<S1Param> = params;
  let done: Bool = false;
  let ok: Bool = true;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        match s1_cg_llvm_ty_of_s1(c0.head.ty) {
          None => { ok = false; done = true; 0 };
          Some(t0) => { out = Cons(ListCons<Text> { head: t0; tail: out; }); cur = c0.tail; 0 };
        };
        0
      };
    }
  };
  if ok == true {
    let r: Option<List<Text>> = Some(s1_cg_reverse_text_list(out));
    r
  } else {
    let r: Option<List<Text>> = None;
    r
  }
};

fn s1_cg_lookup_fn_sig(fns: List<S1CgFnSig>, name: Text) -> Option<S1CgFnSig> {
  let out: Option<S1CgFnSig> = None;
  let cur: List<S1CgFnSig> = fns;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        if c0.head.name == name {
          out = Some(c0.head);
          done = true;
          0
        } else {
          cur = c0.tail;
          0
        };
        0
      };
    }
  };
  out
};

fn s1_cg_collect_fn_sigs_program(p: S1Program) -> List<S1CgFnSig> {
  let out: List<S1CgFnSig> = Nil;
  let cur: List<S1Item> = p.items;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        match c0.head {
          Function(f) => {
            match f.generics {
              Nil => {
                match s1_cg_llvm_ty_of_s1(f.return_type) {
                  None => 0;
                  Some(ret_llvm) => {
                    match s1_cg_llvm_tys_of_params(f.params) {
                      None => 0;
                      Some(ps) => {
                        let sig: S1CgFnSig = S1CgFnSig { name: f.name; ret_llvm: ret_llvm; params_llvm: ps; ret_s1: f.return_type; };
                        out = Cons(ListCons<S1CgFnSig> { head: sig; tail: out; });
                        0
                      };
                    };
                    0
                  };
                };
                0
              };
              _ => 0;
            };
            0
          };
          _ => 0;
        };
        cur = c0.tail;
        0
      };
    }
  };
  out
};

fn s1_cg_block_supported(b: S1Block) -> Bool {
  let ok: Bool = true;
  let cur: List<S1Stmt> = b.stmts;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        match c0.head {
          Let(_l) => { cur = c0.tail; 0 };
          Assign(_a) => { cur = c0.tail; 0 };
          ExprStmt(_e) => { cur = c0.tail; 0 };
          While(w) => {
            if s1_cg_block_supported(w.body) == true {
              cur = c0.tail;
              0
            } else {
              ok = false;
              done = true;
              0
            }
          };
          Return(_r) => { ok = false; done = true; 0 };
        };
        0
      };
    }
  };
  ok
};

fn s1_cg_function_supported(f: S1Function) -> Bool {
  // v0 subset: no generics; only a small set of first-order types for params/ret.
  // Body supports:
  // - zero or more: `let` / assignment / `while` and expression statements
  // - trailing `result` expression (no `return` in v0 subset)
  let ok: Bool = true;

  match f.generics {
    Nil => 0;
    _ => { ok = false; 0 };
  };

  if ok == true {
    match s1_cg_llvm_ty_of_s1(f.return_type) {
      None => { ok = false; 0 };
      Some(_t0) => 0;
    };
    0
  } else { 0 };

  if ok == true {
    let curp: List<S1Param> = f.params;
    let donep: Bool = false;
    while donep == false {
      match curp {
        Nil => { donep = true; 0 };
        Cons(c0) => {
          match s1_cg_llvm_ty_of_s1(c0.head.ty) {
            None => { ok = false; donep = true; 0 };
            Some(_t1) => 0;
          };
          curp = c0.tail;
          0
        };
      }
    };
    0
  } else { 0 };

  if ok == true {
    match f.body {
      None => { ok = false; 0 };
      Some(b) => {
        if s1_cg_block_supported(b) == true { 0 } else { ok = false; 0 };

        if ok == true {
          match b.result {
            Some(_e) => 0;
            _ => { ok = false; 0 };
          };
          0
        } else { 0 };
        0
      };
    };
    0
  } else { 0 };

  ok
};

fn s1_cg_text_err(diag: S1Diagnostic) -> Result<Text, S1Diagnostic> {
  let r: Result<Text, S1Diagnostic> = Err(diag);
  r
};

fn s1_cg_text_ok(value: Text) -> Result<Text, S1Diagnostic> {
  let r: Result<Text, S1Diagnostic> = Ok(value);
  r
};

fn s1_cg_expr_err(diag: S1Diagnostic) -> Result<S1CgExprOut, S1Diagnostic> {
  let r: Result<S1CgExprOut, S1Diagnostic> = Err(diag);
  r
};

fn s1_cg_expr_ok(value: S1CgExprOut) -> Result<S1CgExprOut, S1Diagnostic> {
  let r: Result<S1CgExprOut, S1Diagnostic> = Ok(value);
  r
};

fn s1_cg_block_err(diag: S1Diagnostic) -> Result<S1CgBlockOut, S1Diagnostic> {
  let r: Result<S1CgBlockOut, S1Diagnostic> = Err(diag);
  r
};

fn s1_cg_block_ok(value: S1CgBlockOut) -> Result<S1CgBlockOut, S1Diagnostic> {
  let r: Result<S1CgBlockOut, S1Diagnostic> = Ok(value);
  r
};

fn s1_cg_err(message: Text) -> Result<Text, S1Diagnostic> {
  s1_cg_text_err(s1_diag(Error, 0, 0, message))
};

fn s1_cg_text_append(out: Text, s: Text) -> Text {
  text_concat(out, s)
};

fn s1_cg_line(out: Text, s: Text) -> Text {
  text_concat(text_concat(out, s), "\n")
};

fn s1_cg_path_single_name(path: S1Path) -> Option<Text> {
  let out: Option<Text> = None;
  match path.segments {
    Nil => 0;
    Cons(c0) => {
      match c0.tail {
        Nil => { out = Some(c0.head); 0 };
        _ => 0;
      };
      0
    };
  };
  out
};

fn s1_cg_path_last_name(path: S1Path) -> Option<Text> {
  let out: Option<Text> = None;
  let cur: List<Text> = path.segments;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        match c0.tail {
          Nil => { out = Some(c0.head); done = true; 0 };
          _ => { cur = c0.tail; 0 };
        };
        0
      };
    }
  };
  out
};

fn s1_cg_lookup_env(env: List<S1CgEnvBind>, name: Text) -> Option<S1CgEnvBind> {
  let out: Option<S1CgEnvBind> = None;
  let cur: List<S1CgEnvBind> = env;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        if c0.head.name == name {
          out = Some(c0.head);
          done = true;
          0
        } else {
          cur = c0.tail;
          0
        };
        0
      };
    }
  };
  out
};

fn s1_cg_build_env(params: List<S1Param>) -> List<S1CgEnvBind> {
  let acc: List<S1CgEnvBind> = Nil;
  let cur: List<S1Param> = params;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        let llvm: Text = text_concat("%", c0.head.name);
        let bind: S1CgEnvBind = S1CgEnvBind { name: c0.head.name; llvm: llvm; ty: "i64"; s1_ty: c0.head.ty; };
        acc = Cons(ListCons<S1CgEnvBind> { head: bind; tail: acc; });
        cur = c0.tail;
        0
      };
    }
  };

  // Reverse to preserve param order (small lists; simple impl).
  let out: List<S1CgEnvBind> = Nil;
  let cur2: List<S1CgEnvBind> = acc;
  let done2: Bool = false;
  while done2 == false {
    match cur2 {
      Nil => { done2 = true; 0 };
      Cons(c0) => {
        out = Cons(ListCons<S1CgEnvBind> { head: c0.head; tail: out; });
        cur2 = c0.tail;
        0
      };
    }
  };
  out
};

fn s1_cg_lookup_str_const(strs: List<S1CgStrConst>, lit: Text) -> Option<S1CgStrConst> {
  let out: Option<S1CgStrConst> = None;
  let cur: List<S1CgStrConst> = strs;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        if c0.head.lit == lit {
          out = Some(c0.head);
          done = true;
          0
        } else {
          cur = c0.tail;
          0
        };
        0
      };
    }
  };
  out
};

fn s1_cg_reverse_s1_type_list(xs: List<S1Type>) -> List<S1Type> {
  let out: List<S1Type> = Nil;
  let cur: List<S1Type> = xs;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        out = Cons(ListCons<S1Type> { head: c0.head; tail: out; });
        cur = c0.tail;
        0
      };
    }
  };
  out
};

fn s1_cg_lookup_record(items: List<S1Item>, name: Text) -> Option<S1Record> {
  let out: Option<S1Record> = None;
  let cur: List<S1Item> = items;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        match c0.head {
          Record(r) => {
            if r.name == name { out = Some(r); done = true; 0 } else { 0 };
            0
          };
          _ => 0;
        };
        cur = c0.tail;
        0
      };
    }
  };
  out
};

fn s1_cg_lookup_enum(items: List<S1Item>, name: Text) -> Option<S1Enum> {
  let out: Option<S1Enum> = None;
  let cur: List<S1Item> = items;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        match c0.head {
          Enum(e) => {
            if e.name == name { out = Some(e); done = true; 0 } else { 0 };
            0
          };
          _ => 0;
        };
        cur = c0.tail;
        0
      };
    }
  };
  out
};

fn s1_cg_enum_variant_info_in_enum(e: S1Enum, vname: Text) -> Option<S1CgEnumVariantInfo> {
  let out: Option<S1CgEnumVariantInfo> = None;
  let cur: List<S1EnumVariant> = e.variants;
  let i: Int = 0;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        if c0.head.name == vname {
          out = Some(S1CgEnumVariantInfo { enum_name: e.name; tag: i; payload_ty: c0.head.payload_ty; });
          done = true;
          0
        } else {
          cur = c0.tail;
          i = i + 1;
          0
        };
        0
      };
    }
  };
  out
};

fn s1_cg_resolve_enum_variant(items: List<S1Item>, p: S1Path) -> Option<S1CgEnumVariantInfo> {
  let out: Option<S1CgEnumVariantInfo> = None;
  match p.segments {
    Nil => 0;
    Cons(a0) => {
      match a0.tail {
        Nil => {
          // Unqualified variant name; must be unique across all enums.
          let cur: List<S1Item> = items;
          let done: Bool = false;
          let found: Bool = false;
          while done == false {
            match cur {
              Nil => { done = true; 0 };
              Cons(c0) => {
                match c0.head {
                  Enum(e) => {
                    match s1_cg_enum_variant_info_in_enum(e, a0.head) {
                      None => 0;
                      Some(info) => {
                        if found == true {
                          // ambiguous
                          out = None;
                          done = true;
                          0
                        } else {
                          out = Some(info);
                          found = true;
                          0
                        };
                        0
                      };
                    };
                    0
                  };
                  _ => 0;
                };
                cur = c0.tail;
                0
              };
            }
          };
          0
        };
        Cons(b0) => {
          match b0.tail {
            Nil => {
              // Qualified: Enum::Variant
              match s1_cg_lookup_enum(items, a0.head) {
                None => 0;
                Some(e) => { out = s1_cg_enum_variant_info_in_enum(e, b0.head); 0 };
              };
              0
            };
            _ => 0;
          };
          0
        };
        _ => 0;
      };
      0
    };
  };
  out
};

fn s1_cg_collect_generic_names(gs: List<S1GenericParam>) -> List<Text> {
  let acc: List<Text> = Nil;
  let cur: List<S1GenericParam> = gs;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        acc = Cons(ListCons<Text> { head: c0.head.name; tail: acc; });
        cur = c0.tail;
        0
      };
    }
  };
  s1_cg_reverse_text_list(acc)
};

fn s1_cg_lookup_subst(subst: List<S1Subst>, name: Text) -> Option<S1Type> {
  let out: Option<S1Type> = None;
  let cur: List<S1Subst> = subst;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        if c0.head.name == name {
          out = Some(c0.head.ty);
          done = true;
          0
        } else {
          cur = c0.tail;
          0
        };
        0
      };
    }
  };
  out
};

fn s1_cg_apply_subst(ty: S1Type, gen_names: List<Text>, subst: List<S1Subst>) -> S1Type {
  // If `ty` is a generic var, substitute it (only when used as a bare type: `T`).
  match s1_cg_path_single_name(ty.path) {
    None => 0;
    Some(nm) => {
      if s1_cg_text_list_contains(gen_names, nm) == true {
        match ty.args {
          Nil => {
            match s1_cg_lookup_subst(subst, nm) {
              None => 0;
              Some(t2) => { ty = t2; 0 };
            };
            0
          };
          _ => 0;
        };
        0
      } else { 0 };
      0
    };
  };

  // Recurse into args.
  let acc: List<S1Type> = Nil;
  let cur: List<S1Type> = ty.args;
  let done: Bool = false;
	  while done == false {
	    match cur {
	      Nil => { done = true; 0 };
	      Cons(c0) => {
	        let a2: S1Type = s1_cg_apply_subst(c0.head, gen_names, subst);
	        acc = Cons(ListCons<S1Type> { head: a2; tail: acc; });
	        cur = c0.tail;
	        0
	      };
	    }
	  };
	  let args2: List<S1Type> = s1_cg_reverse_s1_type_list(acc);
	  S1Type { path: ty.path; args: args2; }
	};

fn s1_cg_build_subst(gen_names: List<Text>, args: List<S1Type>) -> List<S1Subst> {
  let out: List<S1Subst> = Nil;
  let gcur: List<Text> = gen_names;
  let acur: List<S1Type> = args;
  let done: Bool = false;
  while done == false {
    match gcur {
      Nil => { done = true; 0 };
      Cons(g0) => {
        match acur {
          Nil => { done = true; 0 };
          Cons(a0) => {
            let s: S1Subst = S1Subst { name: g0.head; ty: a0.head; };
            out = Cons(ListCons<S1Subst> { head: s; tail: out; });
            gcur = g0.tail;
            acur = a0.tail;
            0
          };
        };
        0
      };
    }
  };
  // Preserve parameter order (not required, but deterministic).
  let acc2: List<S1Subst> = Nil;
  let cur2: List<S1Subst> = out;
  let done2: Bool = false;
  while done2 == false {
    match cur2 {
      Nil => { done2 = true; 0 };
      Cons(c0) => { acc2 = Cons(ListCons<S1Subst> { head: c0.head; tail: acc2; }); cur2 = c0.tail; 0 };
    }
  };
  acc2
};

fn s1_cg_record_field_index(rec: S1Record, field: Text) -> Option<Int> {
  let out: Option<Int> = None;
  let cur: List<S1RecordField> = rec.fields;
  let i: Int = 0;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        if c0.head.name == field {
          out = Some(i);
          done = true;
          0
        } else {
          cur = c0.tail;
          i = i + 1;
          0
        };
        0
      };
    }
  };
  out
};

fn s1_cg_record_field_info(items: List<S1Item>, base_ty: S1Type, field: Text) -> Result<Pair<Int, S1Type>, S1Diagnostic> {
  let ok: Bool = true;
  let diag: S1Diagnostic = s1_diag(Error, 0, 0, "codegen: record field lookup failed");
  let out_idx: Int = 0;
  let out_ty: S1Type = s1_cg_s1_type_prim("Int");

  match s1_cg_path_single_name(base_ty.path) {
    None => { ok = false; diag = s1_diag(Error, 0, 0, "codegen: record type path not supported in v0"); 0 };
    Some(rname) => {
      match s1_cg_lookup_record(items, rname) {
        None => { ok = false; diag = s1_diag(Error, 0, 0, "codegen: unknown record type in v0"); 0 };
        Some(rec) => {
          let gen_names: List<Text> = s1_cg_collect_generic_names(rec.generics);
          let subst: List<S1Subst> = s1_cg_build_subst(gen_names, base_ty.args);

          let cur: List<S1RecordField> = rec.fields;
          let i: Int = 0;
          let done: Bool = false;
          while done == false {
            match cur {
              Nil => { ok = false; diag = s1_diag(Error, 0, 0, "codegen: unknown record field in v0"); done = true; 0 };
              Cons(c0) => {
                if c0.head.name == field {
                  out_idx = i;
                  out_ty = s1_cg_apply_subst(c0.head.ty, gen_names, subst);
                  done = true;
                  0
                } else {
                  cur = c0.tail;
                  i = i + 1;
                  0
                };
                0
              };
            }
          };
          0
        };
      };
      0
    };
  };

  let out: Result<Pair<Int, S1Type>, S1Diagnostic> = Err(diag);
  if ok == true {
    out = Ok(Pair<Int, S1Type> { a: out_idx; b: out_ty; });
  };
  out
};

fn s1_cg_record_field_count(rec: S1Record) -> Int {
  let n: Int = 0;
  let cur: List<S1RecordField> = rec.fields;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => { n = n + 1; cur = c0.tail; 0 };
    }
  };
  n
};

fn s1_cg_emit_record_lit_min(out: Text, env: List<S1CgEnvBind>, next_tmp: Int, bb: Text, items: List<S1Item>, strs: List<S1CgStrConst>, fns: List<S1CgFnSig>, r: S1RecordLit) -> Result<S1CgExprOut, S1Diagnostic> {
  match s1_cg_path_single_name(r.ty.path) {
    None => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: record type path not supported in v0"));
	    Some(rname) => {
	      match s1_cg_lookup_record(items, rname) {
	        None => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: unknown record type in v0"));
	        Some(rec) => {
	          // No `*` operator in stage1; compute bytes via repeated +8 per field.
	          let bytes: Int = 0;
	          let cur_fields: List<S1RecordField> = rec.fields;
	          let done_fields: Bool = false;
	          while done_fields == false {
	            match cur_fields {
	              Nil => { done_fields = true; 0 };
	              Cons(c0) => { bytes = bytes + 8; cur_fields = c0.tail; 0 };
	            }
	          };
	
	          let raw_id: Text = int_to_text(next_tmp);
	          let raw: Text = text_concat("%t", raw_id);
	          let out1: Text = s1_cg_line(out, text_concat(text_concat("  ", raw), text_concat(" = call i8* @malloc(i64 ", text_concat(int_to_text(bytes), ")"))));
	          let wptr_id: Text = int_to_text(next_tmp + 1);
          let wptr: Text = text_concat("%t", wptr_id);
          let out2: Text = s1_cg_line(out1, text_concat(text_concat(text_concat("  ", wptr), " = bitcast i8* "), text_concat(raw, " to i64*")));

          // Emit stores for fields (order-independent).
          let cur: List<S1RecordLitField> = r.fields;
          let done: Bool = false;
          let ok: Bool = true;
          let diag: S1Diagnostic = s1_diag(Error, 0, 0, "codegen: record literal failed in v0");
          let ot: Text = out2;
          let nt: Int = next_tmp + 2;
          let bt: Text = bb;
          while done == false {
            match cur {
              Nil => { done = true; 0 };
              Cons(c0) => {
                if ok == false {
                  done = true;
                  0
                } else {
                  let idx: Int = 0;
                  match s1_cg_record_field_index(rec, c0.head.name) {
                    None => { ok = false; diag = s1_diag(Error, 0, 0, "codegen: unknown record field in v0"); done = true; 0 };
                    Some(i2) => { idx = i2; 0 };
                  };

                  if ok == true {
                    let rr: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(ot, env, nt, bt, items, strs, fns, c0.head.value);
                    match rr {
                      Err(e1) => { ok = false; diag = e1; done = true; 0 };
                      Ok(v) => {
                        // Convert value to i64 word.
                        let word: Text = v.value;
                        let ot2: Text = v.text;
                        let nt2: Int = v.next_tmp;
                        let bt2: Text = v.bb;

                        let word_id: Text = int_to_text(nt2);
                        let word_tmp: Text = text_concat("%t", word_id);
                        let made_word: Bool = false;

                        if v.ty == "i64" {
                          word = v.value;
                          made_word = true;
                          0
                        } else {
                          if v.ty == "i1" {
                            ot2 = s1_cg_line(ot2, text_concat(text_concat(text_concat(text_concat("  ", word_tmp), " = zext i1 "), v.value), " to i64"));
                            word = word_tmp;
                            made_word = true;
                            0
                          } else { 0 };
                          0
                        };

                        if made_word == false {
                          // Assume pointer.
                          ot2 = s1_cg_line(ot2, text_concat(text_concat(text_concat(text_concat("  ", word_tmp), " = ptrtoint "), v.ty), text_concat(text_concat(" ", v.value), " to i64")));
                          word = word_tmp;
                          0
                        } else { 0 };

                        let nt3: Int = nt2 + 1;

                        // Compute field slot pointer and store the word.
                        let slotp_id: Text = int_to_text(nt3);
                        let slotp: Text = text_concat("%t", slotp_id);
                        let gep: Text = text_concat(text_concat(text_concat(text_concat("  ", slotp), " = getelementptr inbounds i64, i64* "), wptr), text_concat(", i64 ", int_to_text(idx)));
                        let ot3: Text = s1_cg_line(ot2, gep);
                        let ot4: Text = s1_cg_line(ot3, text_concat(text_concat("  store i64 ", word), text_concat(", i64* ", slotp)));

                        ot = ot4;
                        nt = nt3 + 1;
                        bt = bt2;
                        cur = c0.tail;
                        0
                      };
                    };
                    0
                  } else { 0 };
                  0
                };
                0
              };
            }
          };

          if ok == false {
            s1_cg_expr_err(diag)
          } else {
            s1_cg_expr_ok(S1CgExprOut { text: ot; value: raw; ty: "i8*"; s1_ty: s1_cg_s1_ty_some(r.ty); bb: bt; next_tmp: nt; })
          }
        };
      }
    };
  }
};

fn s1_cg_emit_member_min(out: Text, base_ptr: Text, base_s1_ty: S1Type, next_tmp: Int, bb: Text, items: List<S1Item>, field: Text) -> Result<S1CgExprOut, S1Diagnostic> {
  let info_r: Result<Pair<Int, S1Type>, S1Diagnostic> = s1_cg_record_field_info(items, base_s1_ty, field);
  match info_r {
    Err(e) => s1_cg_expr_err(e);
    Ok(pair) => {
      let idx: Int = pair.a;
      let field_s1: S1Type = pair.b;
      match s1_cg_llvm_ty_of_s1(field_s1) {
        None => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: member field type not supported in v0"));
        Some(field_llvm) => {
          let cast_id: Text = int_to_text(next_tmp);
          let cast: Text = text_concat("%t", cast_id);
          let out1: Text = s1_cg_line(out, text_concat(text_concat(text_concat(text_concat("  ", cast), " = bitcast i8* "), base_ptr), " to i64*"));

          let slotp_id: Text = int_to_text(next_tmp + 1);
          let slotp: Text = text_concat("%t", slotp_id);
          let gep: Text = text_concat(text_concat(text_concat(text_concat("  ", slotp), " = getelementptr inbounds i64, i64* "), cast), text_concat(", i64 ", int_to_text(idx)));
          let out2: Text = s1_cg_line(out1, gep);

          let word_id: Text = int_to_text(next_tmp + 2);
          let word: Text = text_concat("%t", word_id);
          let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat("  ", word), " = load i64, i64* "), slotp));

          if field_llvm == "i64" {
            s1_cg_expr_ok(S1CgExprOut { text: out3; value: word; ty: "i64"; s1_ty: s1_cg_s1_ty_some(field_s1); bb: bb; next_tmp: next_tmp + 3; })
          } else {
            if field_llvm == "i1" {
              let tr_id: Text = int_to_text(next_tmp + 3);
              let tr: Text = text_concat("%t", tr_id);
              let out4: Text = s1_cg_line(out3, text_concat(text_concat(text_concat(text_concat("  ", tr), " = trunc i64 "), word), " to i1"));
              s1_cg_expr_ok(S1CgExprOut { text: out4; value: tr; ty: "i1"; s1_ty: s1_cg_s1_ty_some(field_s1); bb: bb; next_tmp: next_tmp + 4; })
            } else {
              let cast2_id: Text = int_to_text(next_tmp + 3);
              let cast2: Text = text_concat("%t", cast2_id);
              let out4: Text = s1_cg_line(out3, text_concat(text_concat(text_concat(text_concat("  ", cast2), " = inttoptr i64 "), word), text_concat(" to ", field_llvm)));
              s1_cg_expr_ok(S1CgExprOut { text: out4; value: cast2; ty: field_llvm; s1_ty: s1_cg_s1_ty_some(field_s1); bb: bb; next_tmp: next_tmp + 4; })
            }
          }
        };
      }
    };
  }
};

fn s1_cg_emit_expr_min(out: Text, env: List<S1CgEnvBind>, next_tmp: Int, bb: Text, items: List<S1Item>, strs: List<S1CgStrConst>, fns: List<S1CgFnSig>, e: S1Expr) -> Result<S1CgExprOut, S1Diagnostic> {
  match e {
    IntLit(raw) => s1_cg_expr_ok(S1CgExprOut { text: out; value: raw; ty: "i64"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Int")); bb: bb; next_tmp: next_tmp; });
    BoolLit(v) => {
      let raw: Text = "0";
      if v == true { raw = "1"; 0 } else { 0 };
      s1_cg_expr_ok(S1CgExprOut { text: out; value: raw; ty: "i1"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Bool")); bb: bb; next_tmp: next_tmp; })
    };
    StringLit(raw) => {
      match s1_cg_lookup_str_const(strs, raw) {
        None => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: internal error: missing string literal constant"));
        Some(sc) => {
          let tmp_id: Text = int_to_text(next_tmp);
          let tmp: Text = text_concat("%t", tmp_id);
          let n_txt: Text = int_to_text(sc.n);
          let arr_ty: Text = text_concat(text_concat("[", n_txt), " x i8]");
          let head: Text = text_concat(text_concat(text_concat(text_concat("  ", tmp), " = getelementptr inbounds "), arr_ty), text_concat(text_concat(", ", arr_ty), "* "));
          let tail: Text = text_concat(text_concat(sc.global, ", i64 0"), ", i64 0");
          let out2: Text = s1_cg_line(out, text_concat(head, tail));
          s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: "i8*"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Text")); bb: bb; next_tmp: next_tmp + 1; })
        };
      }
    };
    RecordLit(r) => s1_cg_emit_record_lit_min(out, env, next_tmp, bb, items, strs, fns, r);
    Path(p) => {
      match s1_cg_path_single_name(p) {
        None => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: multi-segment path not supported"));
        Some(name) => {
          match s1_cg_lookup_env(env, name) {
            None => {
              // Support `Nil` as `List::Nil` constructor (0-arg enum variant).
              if name == "Nil" {
                let raw_id: Text = int_to_text(next_tmp);
                let raw: Text = text_concat("%t", raw_id);
                let out1: Text = s1_cg_line(out, text_concat(text_concat("  ", raw), " = call i8* @malloc(i64 16)"));
                let ptr_id: Text = int_to_text(next_tmp + 1);
                let ptr: Text = text_concat("%t", ptr_id);
                let out2: Text = s1_cg_line(out1, text_concat(text_concat(text_concat("  ", ptr), " = bitcast i8* "), text_concat(raw, " to %List*")));
                let tagp_id: Text = int_to_text(next_tmp + 2);
                let tagp: Text = text_concat("%t", tagp_id);
                let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat("  ", tagp), " = getelementptr inbounds %List, %List* "), text_concat(ptr, ", i32 0, i32 0")));
                let out4: Text = s1_cg_line(out3, text_concat("  store i8 0, i8* ", tagp));
                let payp_id: Text = int_to_text(next_tmp + 3);
                let payp: Text = text_concat("%t", payp_id);
                let out5: Text = s1_cg_line(out4, text_concat(text_concat(text_concat("  ", payp), " = getelementptr inbounds %List, %List* "), text_concat(ptr, ", i32 0, i32 1")));
                let out6: Text = s1_cg_line(out5, text_concat("  store i64 0, i64* ", payp));
                s1_cg_expr_ok(S1CgExprOut { text: out6; value: ptr; ty: "%List*"; s1_ty: s1_cg_s1_ty_none(); bb: bb; next_tmp: next_tmp + 4; })
              } else {
                // Try lowering as a unit enum variant (e.g. `KwFn`).
                match s1_cg_resolve_enum_variant(items, p) {
                  None => s1_cg_expr_err(s1_diag(Error, 0, 0, text_concat("codegen: unknown variable ", name)));
                  Some(info) => {
                    match info.payload_ty {
                      Some(_t0) => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: enum variant requires payload in v0"));
                      None => {
                        let raw_id: Text = int_to_text(next_tmp);
                        let raw: Text = text_concat("%t", raw_id);
                        let out1: Text = s1_cg_line(out, text_concat(text_concat("  ", raw), " = call i8* @malloc(i64 16)"));
                        let cast_id: Text = int_to_text(next_tmp + 1);
                        let cast: Text = text_concat("%t", cast_id);
                        let out2: Text = s1_cg_line(out1, text_concat(text_concat(text_concat("  ", cast), " = bitcast i8* "), text_concat(raw, " to %Option*")));
                        let tagp_id: Text = int_to_text(next_tmp + 2);
                        let tagp: Text = text_concat("%t", tagp_id);
                        let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat("  ", tagp), " = getelementptr inbounds %Option, %Option* "), text_concat(cast, ", i32 0, i32 0")));
                        let out4: Text = s1_cg_line(out3, text_concat(text_concat("  store i8 ", int_to_text(info.tag)), text_concat(", i8* ", tagp)));
                        let payp_id: Text = int_to_text(next_tmp + 3);
                        let payp: Text = text_concat("%t", payp_id);
                        let out5: Text = s1_cg_line(out4, text_concat(text_concat(text_concat("  ", payp), " = getelementptr inbounds %Option, %Option* "), text_concat(cast, ", i32 0, i32 1")));
                        let out6: Text = s1_cg_line(out5, text_concat("  store i64 0, i64* ", payp));
                        let st: S1Type = s1_cg_s1_type_prim(info.enum_name);
                        let ret_val: Text = raw;
                        let ret_ty: Text = "i8*";
                        if info.enum_name == "Option" { ret_val = cast; ret_ty = "%Option*"; 0 } else { 0 };
                        s1_cg_expr_ok(S1CgExprOut { text: out6; value: ret_val; ty: ret_ty; s1_ty: s1_cg_s1_ty_some(st); bb: bb; next_tmp: next_tmp + 4; })
                      };
                    }
                  };
                }
              }
            };
            Some(v) => {
              let tmp_id: Text = int_to_text(next_tmp);
              let tmp: Text = text_concat("%t", tmp_id);
              let inst1: Text = text_concat(text_concat(text_concat(text_concat("  ", tmp), " = load "), v.ty), text_concat(text_concat(", ", v.ty), text_concat("* ", v.llvm)));
              let out2: Text = s1_cg_line(out, inst1);
              s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: v.ty; s1_ty: s1_cg_s1_ty_some(v.s1_ty); bb: bb; next_tmp: next_tmp + 1; })
            };
          }
        };
      }
    };
    Member(m) => {
      // Enum variant access: `Enum.Variant` (unit variants only).
      // Stage1 sources use this for AST construction (e.g. `S1BinOp.Equals`).
      let out_enum: Result<S1CgExprOut, S1Diagnostic> =
        s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: member lowering failed"));
      let handled: Bool = false;

      match m.base {
        Path(bp) => {
          match s1_cg_path_single_name(bp) {
            None => 0;
            Some(enm) => {
              let seg_nil: List<Text> = Nil;
              let seg2: List<Text> = Cons(ListCons<Text> { head: m.name; tail: seg_nil; });
              let segs: List<Text> = Cons(ListCons<Text> { head: enm; tail: seg2; });
              let qp: S1Path = S1Path { segments: segs; };

              match s1_cg_resolve_enum_variant(items, qp) {
                None => 0;
                Some(info) => {
                  match info.payload_ty {
                    Some(_t0) => 0;
                    None => {
                      let layout: Text = "Option";
                      let ret_ty: Text = "i8*";
                      let out_s1: Option<S1Type> = s1_cg_s1_ty_some(s1_cg_s1_type_prim(info.enum_name));

                      if info.enum_name == "Option" { layout = "Option"; ret_ty = "%Option*"; 0 } else { 0 };
                      if info.enum_name == "List" { layout = "List"; ret_ty = "%List*"; out_s1 = s1_cg_s1_ty_none(); 0 } else { 0 };

                      let store_ty: Text = text_concat("%", layout);
                      let store_ptr_ty: Text = text_concat(store_ty, "*");

                      let raw_id: Text = int_to_text(next_tmp);
                      let raw: Text = text_concat("%t", raw_id);
                      let out1: Text = s1_cg_line(out, text_concat(text_concat("  ", raw), " = call i8* @malloc(i64 16)"));

                      let cast_id: Text = int_to_text(next_tmp + 1);
                      let cast: Text = text_concat("%t", cast_id);
                      let out2: Text = s1_cg_line(out1, text_concat(text_concat(text_concat("  ", cast), " = bitcast i8* "), text_concat(raw, text_concat(" to ", store_ptr_ty))));

                      let tagp_id: Text = int_to_text(next_tmp + 2);
                      let tagp: Text = text_concat("%t", tagp_id);
                      let out3: Text = s1_cg_line(
                        out2,
                        text_concat(
                          text_concat(text_concat(text_concat("  ", tagp), " = getelementptr inbounds "), text_concat(store_ty, ", ")),
                          text_concat(store_ptr_ty, text_concat(" ", text_concat(cast, ", i32 0, i32 0")))
                        )
                      );
                      let out4: Text = s1_cg_line(out3, text_concat(text_concat("  store i8 ", int_to_text(info.tag)), text_concat(", i8* ", tagp)));

                      let payp_id: Text = int_to_text(next_tmp + 3);
                      let payp: Text = text_concat("%t", payp_id);
                      let out5: Text = s1_cg_line(
                        out4,
                        text_concat(
                          text_concat(text_concat(text_concat("  ", payp), " = getelementptr inbounds "), text_concat(store_ty, ", ")),
                          text_concat(store_ptr_ty, text_concat(" ", text_concat(cast, ", i32 0, i32 1")))
                        )
                      );
                      let out6: Text = s1_cg_line(out5, text_concat("  store i64 0, i64* ", payp));

                      let ret_val: Text = raw;
                      if ret_ty != "i8*" { ret_val = cast; 0 } else { 0 };

                      out_enum = s1_cg_expr_ok(S1CgExprOut { text: out6; value: ret_val; ty: ret_ty; s1_ty: out_s1; bb: bb; next_tmp: next_tmp + 4; });
                      handled = true;
                      0
                    };
                  };
                  0
                };
              };
              0
            };
          };
          0
        };
        _ => 0;
      };

      if handled == true {
        out_enum
      } else {
        // Record field access for bootstrap.
        let br: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(out, env, next_tmp, bb, items, strs, fns, m.base);
        match br {
          Err(e1) => s1_cg_expr_err(e1);
          Ok(b0) => {
            if b0.ty != "i8*" {
              s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: member base must be record pointer (i8*) in v0"))
            } else {
              match b0.s1_ty {
                None => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: member access missing type info in v0"));
                Some(bt0) => {
                  match s1_cg_record_field_info(items, bt0, m.name) {
                    Err(ei) => s1_cg_expr_err(ei);
                    Ok(fi) => {
                      let idx: Int = fi.a;
                      let field_s1: S1Type = fi.b;
                      match s1_cg_llvm_ty_of_s1(field_s1) {
                        None => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: member field type not supported in v0"));
                        Some(field_llvm) => {
                          let cast_id: Text = int_to_text(b0.next_tmp);
                          let cast: Text = text_concat("%t", cast_id);
                          let out1: Text = s1_cg_line(b0.text, text_concat(text_concat(text_concat(text_concat("  ", cast), " = bitcast i8* "), b0.value), " to i64*"));

                          let slotp_id: Text = int_to_text(b0.next_tmp + 1);
                          let slotp: Text = text_concat("%t", slotp_id);
                          let gep: Text = text_concat(text_concat(text_concat(text_concat("  ", slotp), " = getelementptr inbounds i64, i64* "), cast), text_concat(", i64 ", int_to_text(idx)));
                          let out2: Text = s1_cg_line(out1, gep);

                          let word_id: Text = int_to_text(b0.next_tmp + 2);
                          let word: Text = text_concat("%t", word_id);
                          let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat("  ", word), " = load i64, i64* "), slotp));

                          if field_llvm == "i64" {
                            s1_cg_expr_ok(S1CgExprOut { text: out3; value: word; ty: "i64"; s1_ty: s1_cg_s1_ty_some(field_s1); bb: b0.bb; next_tmp: b0.next_tmp + 3; })
                          } else {
                            if field_llvm == "i1" {
                              let tr_id: Text = int_to_text(b0.next_tmp + 3);
                              let tr: Text = text_concat("%t", tr_id);
                              let out4: Text = s1_cg_line(out3, text_concat(text_concat(text_concat(text_concat("  ", tr), " = trunc i64 "), word), " to i1"));
                              s1_cg_expr_ok(S1CgExprOut { text: out4; value: tr; ty: "i1"; s1_ty: s1_cg_s1_ty_some(field_s1); bb: b0.bb; next_tmp: b0.next_tmp + 4; })
                            } else {
                              let cast2_id: Text = int_to_text(b0.next_tmp + 3);
                              let cast2: Text = text_concat("%t", cast2_id);
                              let out4: Text = s1_cg_line(out3, text_concat(text_concat(text_concat(text_concat("  ", cast2), " = inttoptr i64 "), word), text_concat(" to ", field_llvm)));
                              s1_cg_expr_ok(S1CgExprOut { text: out4; value: cast2; ty: field_llvm; s1_ty: s1_cg_s1_ty_some(field_s1); bb: b0.bb; next_tmp: b0.next_tmp + 4; })
                            }
                          }
                        };
                      }
                    };
                  }
                };
              }
            }
          };
        }
      }
    };
    Binary(b) => {
      match b.op {
        Add => {
          let l_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(out, env, next_tmp, bb, items, strs, fns, b.left);
          match l_r {
            Err(e1) => s1_cg_expr_err(e1);
            Ok(l) => {
              let r_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(l.text, env, l.next_tmp, l.bb, items, strs, fns, b.right);
              match r_r {
                Err(e2) => s1_cg_expr_err(e2);
                Ok(r) => {
                  if l.ty == "i64" {
                    if r.ty == "i64" {
                      let tmp_id: Text = int_to_text(r.next_tmp);
                      let tmp: Text = text_concat("%t", tmp_id);
                      let inst: Text = text_concat(text_concat(text_concat(text_concat("  ", tmp), " = add i64 "), l.value), text_concat(", ", r.value));
                      let out2: Text = s1_cg_line(r.text, inst);
                      s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: "i64"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Int")); bb: r.bb; next_tmp: r.next_tmp + 1; })
                    } else {
                      s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: add expects i64 operands"))
                    }
                  } else {
                    s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: add expects i64 operands"))
                  }
                };
              }
            };
          }
        };
        Equals => {
          let l_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(out, env, next_tmp, bb, items, strs, fns, b.left);
          match l_r {
            Err(e1) => s1_cg_expr_err(e1);
            Ok(l) => {
              let r_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(l.text, env, l.next_tmp, l.bb, items, strs, fns, b.right);
              match r_r {
                Err(e2) => s1_cg_expr_err(e2);
                Ok(r) => {
                  if l.ty == r.ty {
                    if l.ty == "i64" {
                      let tmp_id: Text = int_to_text(r.next_tmp);
                      let tmp: Text = text_concat("%t", tmp_id);
                      let inst: Text = text_concat(text_concat(text_concat(text_concat("  ", tmp), " = icmp eq i64 "), l.value), text_concat(", ", r.value));
                      let out2: Text = s1_cg_line(r.text, inst);
                      s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: "i1"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Bool")); bb: r.bb; next_tmp: r.next_tmp + 1; })
                    } else {
                      if l.ty == "i1" {
                        let tmp_id: Text = int_to_text(r.next_tmp);
                        let tmp: Text = text_concat("%t", tmp_id);
                        let inst: Text = text_concat(text_concat(text_concat(text_concat("  ", tmp), " = icmp eq i1 "), l.value), text_concat(", ", r.value));
                        let out2: Text = s1_cg_line(r.text, inst);
                        s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: "i1"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Bool")); bb: r.bb; next_tmp: r.next_tmp + 1; })
                      } else {
                        if l.ty == "i8*" {
                          let cmp_id: Text = int_to_text(r.next_tmp);
                          let cmp: Text = text_concat("%t", cmp_id);
                          let inst0: Text = text_concat(text_concat(text_concat("  ", cmp), " = call i32 @strcmp(i8* "), l.value);
                          let inst1: Text = text_concat(inst0, ", i8* ");
                          let inst2: Text = text_concat(inst1, r.value);
                          let inst_cmp: Text = text_concat(inst2, ")");
                          let out2: Text = s1_cg_line(r.text, inst_cmp);

                          let tmp_id: Text = int_to_text(r.next_tmp + 1);
                          let tmp: Text = text_concat("%t", tmp_id);
                          let inst_eq: Text = text_concat(text_concat(text_concat(text_concat("  ", tmp), " = icmp eq i32 "), cmp), ", 0");
                          let out3: Text = s1_cg_line(out2, inst_eq);
                          s1_cg_expr_ok(S1CgExprOut { text: out3; value: tmp; ty: "i1"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Bool")); bb: r.bb; next_tmp: r.next_tmp + 2; })
	                        } else {
	                          s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: == expects i64/i1/Text operands"))
	                        }
	                      }
	                    }
	                  } else {
	                    s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: == expects same-typed operands"))
	                  }
                };
              }
            };
          }
        };
        NotEquals => {
          let l_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(out, env, next_tmp, bb, items, strs, fns, b.left);
          match l_r {
            Err(e1) => s1_cg_expr_err(e1);
            Ok(l) => {
              let r_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(l.text, env, l.next_tmp, l.bb, items, strs, fns, b.right);
              match r_r {
                Err(e2) => s1_cg_expr_err(e2);
                Ok(r) => {
                  if l.ty == r.ty {
                    if l.ty == "i64" {
                      let tmp_id: Text = int_to_text(r.next_tmp);
                      let tmp: Text = text_concat("%t", tmp_id);
                      let inst: Text = text_concat(text_concat(text_concat(text_concat("  ", tmp), " = icmp ne i64 "), l.value), text_concat(", ", r.value));
                      let out2: Text = s1_cg_line(r.text, inst);
                      s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: "i1"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Bool")); bb: r.bb; next_tmp: r.next_tmp + 1; })
                    } else {
                      if l.ty == "i1" {
                        let tmp_id: Text = int_to_text(r.next_tmp);
                        let tmp: Text = text_concat("%t", tmp_id);
                        let inst: Text = text_concat(text_concat(text_concat(text_concat("  ", tmp), " = icmp ne i1 "), l.value), text_concat(", ", r.value));
                        let out2: Text = s1_cg_line(r.text, inst);
                        s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: "i1"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Bool")); bb: r.bb; next_tmp: r.next_tmp + 1; })
                      } else {
                        if l.ty == "i8*" {
                          let cmp_id: Text = int_to_text(r.next_tmp);
                          let cmp: Text = text_concat("%t", cmp_id);
                          let inst0: Text = text_concat(text_concat(text_concat("  ", cmp), " = call i32 @strcmp(i8* "), l.value);
                          let inst1: Text = text_concat(inst0, ", i8* ");
                          let inst2: Text = text_concat(inst1, r.value);
                          let inst_cmp: Text = text_concat(inst2, ")");
                          let out2: Text = s1_cg_line(r.text, inst_cmp);

                          let tmp_id: Text = int_to_text(r.next_tmp + 1);
                          let tmp: Text = text_concat("%t", tmp_id);
                          let inst_ne: Text = text_concat(text_concat(text_concat(text_concat("  ", tmp), " = icmp ne i32 "), cmp), ", 0");
                          let out3: Text = s1_cg_line(out2, inst_ne);
                          s1_cg_expr_ok(S1CgExprOut { text: out3; value: tmp; ty: "i1"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Bool")); bb: r.bb; next_tmp: r.next_tmp + 2; })
	                        } else {
	                          s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: != expects i64/i1/Text operands"))
	                        }
	                      }
	                    }
	                  } else {
	                    s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: != expects same-typed operands"))
	                  }
                };
              }
            };
          }
        };
      }
    };
    Call(c) => {
      // Only support `callee` as:
      // - single-segment path (direct function call)
      // - Option::Some/Option::None constructors (Option<Int> only)
      // - List::Cons constructor (List<T> only; payload as i8* record pointer)
      let p_opt: Option<S1Path> = None;
      match c.callee {
        Path(p0) => { p_opt = Some(p0); 0 };
        Member(m0) => {
          match m0.base {
            Path(bp) => {
              match s1_cg_path_single_name(bp) {
                None => 0;
                Some(enm) => {
                  let seg_nil: List<Text> = Nil;
                  let seg2: List<Text> = Cons(ListCons<Text> { head: m0.name; tail: seg_nil; });
                  let segs: List<Text> = Cons(ListCons<Text> { head: enm; tail: seg2; });
                  p_opt = Some(S1Path { segments: segs; });
                  0
                };
              };
              0
            };
            _ => 0;
          };
          0
        };
        _ => 0;
      };

      match p_opt {
        None => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: callee must be a path in v0"));
        Some(p) => {
          let is_option_ctor: Bool = false;
          let option_variant: Text = "";
          let is_list_ctor: Bool = false;
          let list_variant: Text = "";
          match p.segments {
            Cons(a0) => {
              // Accept either `Option::Some/Option::None` or unqualified `Some/None`.
              if a0.head == "Option" {
                match a0.tail {
                  Cons(b0) => {
                    match b0.tail {
                      Nil => { is_option_ctor = true; option_variant = b0.head; 0 };
                      _ => 0;
                    };
                    0
                  };
                  _ => 0;
                };
                0
              } else {
                match a0.tail {
                  Nil => {
                    if a0.head == "Some" { is_option_ctor = true; option_variant = "Some"; 0 } else { 0 };
                    if a0.head == "None" { is_option_ctor = true; option_variant = "None"; 0 } else { 0 };
                    0
                  };
                  _ => 0;
                };
                0
              };
              0
            };
            _ => 0;
          };

          let out_call: Result<S1CgExprOut, S1Diagnostic> = s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: call lowering failed"));
          let handled: Bool = false;

          // Generic enum payload constructor lowering (v0.12+):
          // - used by the Stage1 compiler itself (e.g. `Ok(x)`, `Err(e)`, `Ident(s)`).
          // - excludes Option/List which have dedicated LLVM pointer types in v0.
          match s1_cg_resolve_enum_variant(items, p) {
            None => 0;
            Some(info) => {
              if info.enum_name != "Option" {
                if info.enum_name != "List" {
                  match info.payload_ty {
                    None => 0;
                    Some(_payload_ty) => {
                      match c.args {
                        Cons(a0) => {
                          match a0.tail {
                            Nil => {
                              let ar: Result<S1CgExprOut, S1Diagnostic> =
                                s1_cg_emit_expr_min(out, env, next_tmp, bb, items, strs, fns, a0.head);
                              match ar {
                                Err(e1) => { out_call = s1_cg_expr_err(e1); handled = true; 0 };
                                Ok(av) => {
                                  let word: Text = av.value;
                                  let ot2: Text = av.text;
                                  let nt2: Int = av.next_tmp;
                                  let bt2: Text = av.bb;

                                  let word_id: Text = int_to_text(nt2);
                                  let word_tmp: Text = text_concat("%t", word_id);
                                  let used_tmp: Bool = false;

                                  if av.ty == "i1" {
                                    ot2 = s1_cg_line(ot2, text_concat(text_concat(text_concat(text_concat("  ", word_tmp), " = zext i1 "), av.value), " to i64"));
                                    word = word_tmp;
                                    used_tmp = true;
                                    0
                                  } else { 0 };

                                  if av.ty != "i64" {
                                    if used_tmp == false {
                                      ot2 = s1_cg_line(ot2, text_concat(text_concat(text_concat(text_concat("  ", word_tmp), " = ptrtoint "), av.ty), text_concat(text_concat(" ", av.value), " to i64")));
                                      word = word_tmp;
                                      used_tmp = true;
                                      0
                                    } else { 0 };
                                    0
                                  } else { 0 };

                                  let nt3: Int = nt2;
                                  if used_tmp == true { nt3 = nt2 + 1; 0 } else { 0 };

                                  let raw_id: Text = int_to_text(nt3);
                                  let raw: Text = text_concat("%t", raw_id);
                                  let out1: Text = s1_cg_line(ot2, text_concat(text_concat("  ", raw), " = call i8* @malloc(i64 16)"));
                                  let store_cast_id: Text = int_to_text(nt3 + 1);
                                  let store_cast: Text = text_concat("%t", store_cast_id);
                                  let out2a: Text = s1_cg_line(out1, text_concat(text_concat(text_concat("  ", store_cast), " = bitcast i8* "), text_concat(raw, " to %Option*")));
                                  let tagp_id: Text = int_to_text(nt3 + 2);
                                  let tagp: Text = text_concat("%t", tagp_id);
                                  let out3: Text = s1_cg_line(out2a, text_concat(text_concat(text_concat("  ", tagp), " = getelementptr inbounds %Option, %Option* "), text_concat(store_cast, ", i32 0, i32 0")));
                                  let out4: Text = s1_cg_line(out3, text_concat(text_concat("  store i8 ", int_to_text(info.tag)), text_concat(", i8* ", tagp)));
                                  let payp_id: Text = int_to_text(nt3 + 3);
                                  let payp: Text = text_concat("%t", payp_id);
                                  let out5: Text = s1_cg_line(out4, text_concat(text_concat(text_concat("  ", payp), " = getelementptr inbounds %Option, %Option* "), text_concat(store_cast, ", i32 0, i32 1")));
                                  let out6: Text = s1_cg_line(out5, text_concat(text_concat("  store i64 ", word), text_concat(", i64* ", payp)));

                                  let ret_ptr: Text = raw;
                                  let ret_ty: Text = "i8*";
                                  let out7: Text = out6;
                                  let nt4: Int = nt3 + 4;
                                  if info.enum_name == "Result" {
                                    let ret_id: Text = int_to_text(nt3 + 4);
                                    ret_ptr = text_concat("%t", ret_id);
                                    ret_ty = "%Result*";
                                    out7 = s1_cg_line(out6, text_concat(text_concat(text_concat("  ", ret_ptr), " = bitcast i8* "), text_concat(raw, " to %Result*")));
                                    nt4 = nt3 + 5;
                                    0
                                  } else {
                                    nt4 = nt3 + 4;
                                    0
                                  };

                                  let st: S1Type = s1_cg_s1_type_prim(info.enum_name);
                                  out_call = s1_cg_expr_ok(S1CgExprOut { text: out7; value: ret_ptr; ty: ret_ty; s1_ty: s1_cg_s1_ty_some(st); bb: bt2; next_tmp: nt4; });
                                  handled = true;
                                  0
                                };
                              };
                              0
                            };
                            _ => 0;
                          };
                          0
                        };
                        _ => 0;
                      };
                      0
                    };
                  };
                  0
                } else { 0 };
                0
              } else { 0 };
              0
            };
          };

          if handled == false { out_call = if is_option_ctor == true {
            if option_variant == "None" {
              match c.args {
                Nil => {
                  let raw_id: Text = int_to_text(next_tmp);
                  let raw: Text = text_concat("%t", raw_id);
                  let out1: Text = s1_cg_line(out, text_concat(text_concat("  ", raw), " = call i8* @malloc(i64 16)"));
                  let ptr_id: Text = int_to_text(next_tmp + 1);
                  let ptr: Text = text_concat("%t", ptr_id);
                  let out2: Text = s1_cg_line(out1, text_concat(text_concat(text_concat("  ", ptr), " = bitcast i8* "), text_concat(raw, " to %Option*")));
                  let tagp_id: Text = int_to_text(next_tmp + 2);
                  let tagp: Text = text_concat("%t", tagp_id);
                  let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat("  ", tagp), " = getelementptr inbounds %Option, %Option* "), text_concat(ptr, ", i32 0, i32 0")));
                  let out4: Text = s1_cg_line(out3, text_concat("  store i8 1, i8* ", tagp));
                  let payp_id: Text = int_to_text(next_tmp + 3);
                  let payp: Text = text_concat("%t", payp_id);
                  let out5: Text = s1_cg_line(out4, text_concat(text_concat(text_concat("  ", payp), " = getelementptr inbounds %Option, %Option* "), text_concat(ptr, ", i32 0, i32 1")));
                  let out6: Text = s1_cg_line(out5, text_concat("  store i64 0, i64* ", payp));
                  s1_cg_expr_ok(S1CgExprOut { text: out6; value: ptr; ty: "%Option*"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_option_int()); bb: bb; next_tmp: next_tmp + 4; })
                };
                _ => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: Option::None expects no args"));
              }
            } else {
              if option_variant == "Some" {
                match c.args {
                  Cons(a0) => {
                    match a0.tail {
                      Nil => {
                        let ar: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(out, env, next_tmp, bb, items, strs, fns, a0.head);
                        match ar {
                          Err(e1) => s1_cg_expr_err(e1);
                          Ok(av) => {
                            let out_s1: Option<S1Type> = s1_cg_s1_ty_none();
                            let have_out_s1: Bool = false;
                            match av.s1_ty {
                              None => 0;
                              Some(st0) => {
                                out_s1 = s1_cg_s1_ty_some(s1_cg_s1_type_option(st0));
                                have_out_s1 = true;
                                0
                              };
                            };
                            if have_out_s1 == false {
                              if av.ty == "i64" {
                                out_s1 = s1_cg_s1_ty_some(s1_cg_s1_type_option_int());
                                0
                              } else {
                                if av.ty == "i1" {
                                  out_s1 = s1_cg_s1_ty_some(s1_cg_s1_type_option(s1_cg_s1_type_prim("Bool")));
                                  0
                                } else {
                                  if av.ty == "i8*" {
                                    out_s1 = s1_cg_s1_ty_some(s1_cg_s1_type_option_text());
                                    0
                                  } else { 0 };
                                  0
                                }
                              };
                              0
                            } else { 0 };

                            if av.ty == "i64" {
                              let raw_id: Text = int_to_text(av.next_tmp);
                              let raw: Text = text_concat("%t", raw_id);
                              let out1: Text = s1_cg_line(av.text, text_concat(text_concat("  ", raw), " = call i8* @malloc(i64 16)"));
                              let ptr_id: Text = int_to_text(av.next_tmp + 1);
                              let ptr: Text = text_concat("%t", ptr_id);
                              let out2: Text = s1_cg_line(out1, text_concat(text_concat(text_concat("  ", ptr), " = bitcast i8* "), text_concat(raw, " to %Option*")));
                              let tagp_id: Text = int_to_text(av.next_tmp + 2);
                              let tagp: Text = text_concat("%t", tagp_id);
                              let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat("  ", tagp), " = getelementptr inbounds %Option, %Option* "), text_concat(ptr, ", i32 0, i32 0")));
                              let out4: Text = s1_cg_line(out3, text_concat("  store i8 0, i8* ", tagp));
                              let payp_id: Text = int_to_text(av.next_tmp + 3);
                              let payp: Text = text_concat("%t", payp_id);
                              let out5: Text = s1_cg_line(out4, text_concat(text_concat(text_concat("  ", payp), " = getelementptr inbounds %Option, %Option* "), text_concat(ptr, ", i32 0, i32 1")));
                              let out6: Text = s1_cg_line(out5, text_concat(text_concat("  store i64 ", av.value), text_concat(", i64* ", payp)));
                              s1_cg_expr_ok(S1CgExprOut { text: out6; value: ptr; ty: "%Option*"; s1_ty: out_s1; bb: bb; next_tmp: av.next_tmp + 4; })
                            } else {
                              if av.ty == "i1" {
                                let z_id: Text = int_to_text(av.next_tmp);
                                let z: Text = text_concat("%t", z_id);
                                let out0: Text = s1_cg_line(av.text, text_concat(text_concat(text_concat(text_concat("  ", z), " = zext i1 "), av.value), " to i64"));

                                let raw_id: Text = int_to_text(av.next_tmp + 1);
                                let raw: Text = text_concat("%t", raw_id);
                                let out1: Text = s1_cg_line(out0, text_concat(text_concat("  ", raw), " = call i8* @malloc(i64 16)"));
                                let ptr_id: Text = int_to_text(av.next_tmp + 2);
                                let ptr: Text = text_concat("%t", ptr_id);
                                let out2: Text = s1_cg_line(out1, text_concat(text_concat(text_concat("  ", ptr), " = bitcast i8* "), text_concat(raw, " to %Option*")));
                                let tagp_id: Text = int_to_text(av.next_tmp + 3);
                                let tagp: Text = text_concat("%t", tagp_id);
                                let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat("  ", tagp), " = getelementptr inbounds %Option, %Option* "), text_concat(ptr, ", i32 0, i32 0")));
                                let out4: Text = s1_cg_line(out3, text_concat("  store i8 0, i8* ", tagp));
                                let payp_id: Text = int_to_text(av.next_tmp + 4);
                                let payp: Text = text_concat("%t", payp_id);
                                let out5: Text = s1_cg_line(out4, text_concat(text_concat(text_concat("  ", payp), " = getelementptr inbounds %Option, %Option* "), text_concat(ptr, ", i32 0, i32 1")));
                                let out6: Text = s1_cg_line(out5, text_concat(text_concat("  store i64 ", z), text_concat(", i64* ", payp)));
                                s1_cg_expr_ok(S1CgExprOut { text: out6; value: ptr; ty: "%Option*"; s1_ty: out_s1; bb: bb; next_tmp: av.next_tmp + 5; })
                              } else {
                                if av.ty == "i8*" {
                                  let cast_id: Text = int_to_text(av.next_tmp);
                                  let cast: Text = text_concat("%t", cast_id);
                                  let out0: Text = s1_cg_line(av.text, text_concat(text_concat(text_concat(text_concat("  ", cast), " = ptrtoint i8* "), av.value), " to i64"));

                                  let raw_id: Text = int_to_text(av.next_tmp + 1);
                                  let raw: Text = text_concat("%t", raw_id);
                                  let out1: Text = s1_cg_line(out0, text_concat(text_concat("  ", raw), " = call i8* @malloc(i64 16)"));
                                  let ptr_id: Text = int_to_text(av.next_tmp + 2);
                                  let ptr: Text = text_concat("%t", ptr_id);
                                  let out2: Text = s1_cg_line(out1, text_concat(text_concat(text_concat("  ", ptr), " = bitcast i8* "), text_concat(raw, " to %Option*")));
                                  let tagp_id: Text = int_to_text(av.next_tmp + 3);
                                  let tagp: Text = text_concat("%t", tagp_id);
                                  let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat("  ", tagp), " = getelementptr inbounds %Option, %Option* "), text_concat(ptr, ", i32 0, i32 0")));
                                  let out4: Text = s1_cg_line(out3, text_concat("  store i8 0, i8* ", tagp));
                                  let payp_id: Text = int_to_text(av.next_tmp + 4);
                                  let payp: Text = text_concat("%t", payp_id);
                                  let out5: Text = s1_cg_line(out4, text_concat(text_concat(text_concat("  ", payp), " = getelementptr inbounds %Option, %Option* "), text_concat(ptr, ", i32 0, i32 1")));
                                  let out6: Text = s1_cg_line(out5, text_concat(text_concat("  store i64 ", cast), text_concat(", i64* ", payp)));
                                  s1_cg_expr_ok(S1CgExprOut { text: out6; value: ptr; ty: "%Option*"; s1_ty: out_s1; bb: bb; next_tmp: av.next_tmp + 5; })
                                } else {
                                  if av.ty == "%Option*" {
                                    let cast_id: Text = int_to_text(av.next_tmp);
                                    let cast: Text = text_concat("%t", cast_id);
                                    let out0: Text = s1_cg_line(av.text, text_concat(text_concat(text_concat(text_concat("  ", cast), " = ptrtoint %Option* "), av.value), " to i64"));

                                    let raw_id: Text = int_to_text(av.next_tmp + 1);
                                    let raw: Text = text_concat("%t", raw_id);
                                    let out1: Text = s1_cg_line(out0, text_concat(text_concat("  ", raw), " = call i8* @malloc(i64 16)"));
                                    let ptr_id: Text = int_to_text(av.next_tmp + 2);
                                    let ptr: Text = text_concat("%t", ptr_id);
                                    let out2: Text = s1_cg_line(out1, text_concat(text_concat(text_concat("  ", ptr), " = bitcast i8* "), text_concat(raw, " to %Option*")));
                                    let tagp_id: Text = int_to_text(av.next_tmp + 3);
                                    let tagp: Text = text_concat("%t", tagp_id);
                                    let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat("  ", tagp), " = getelementptr inbounds %Option, %Option* "), text_concat(ptr, ", i32 0, i32 0")));
                                    let out4: Text = s1_cg_line(out3, text_concat("  store i8 0, i8* ", tagp));
                                    let payp_id: Text = int_to_text(av.next_tmp + 4);
                                    let payp: Text = text_concat("%t", payp_id);
                                    let out5: Text = s1_cg_line(out4, text_concat(text_concat(text_concat("  ", payp), " = getelementptr inbounds %Option, %Option* "), text_concat(ptr, ", i32 0, i32 1")));
                                    let out6: Text = s1_cg_line(out5, text_concat(text_concat("  store i64 ", cast), text_concat(", i64* ", payp)));
                                    s1_cg_expr_ok(S1CgExprOut { text: out6; value: ptr; ty: "%Option*"; s1_ty: out_s1; bb: bb; next_tmp: av.next_tmp + 5; })
                                  } else {
                                    if av.ty == "%Result*" {
                                      let cast_id: Text = int_to_text(av.next_tmp);
                                      let cast: Text = text_concat("%t", cast_id);
                                      let out0: Text = s1_cg_line(av.text, text_concat(text_concat(text_concat(text_concat("  ", cast), " = ptrtoint %Result* "), av.value), " to i64"));

                                      let raw_id: Text = int_to_text(av.next_tmp + 1);
                                      let raw: Text = text_concat("%t", raw_id);
                                      let out1: Text = s1_cg_line(out0, text_concat(text_concat("  ", raw), " = call i8* @malloc(i64 16)"));
                                      let ptr_id: Text = int_to_text(av.next_tmp + 2);
                                      let ptr: Text = text_concat("%t", ptr_id);
                                      let out2: Text = s1_cg_line(out1, text_concat(text_concat(text_concat("  ", ptr), " = bitcast i8* "), text_concat(raw, " to %Option*")));
                                      let tagp_id: Text = int_to_text(av.next_tmp + 3);
                                      let tagp: Text = text_concat("%t", tagp_id);
                                      let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat("  ", tagp), " = getelementptr inbounds %Option, %Option* "), text_concat(ptr, ", i32 0, i32 0")));
                                      let out4: Text = s1_cg_line(out3, text_concat("  store i8 0, i8* ", tagp));
                                      let payp_id: Text = int_to_text(av.next_tmp + 4);
                                      let payp: Text = text_concat("%t", payp_id);
                                      let out5: Text = s1_cg_line(out4, text_concat(text_concat(text_concat("  ", payp), " = getelementptr inbounds %Option, %Option* "), text_concat(ptr, ", i32 0, i32 1")));
                                      let out6: Text = s1_cg_line(out5, text_concat(text_concat("  store i64 ", cast), text_concat(", i64* ", payp)));
                                      s1_cg_expr_ok(S1CgExprOut { text: out6; value: ptr; ty: "%Option*"; s1_ty: out_s1; bb: bb; next_tmp: av.next_tmp + 5; })
                                    } else {
                                      if av.ty == "%List*" {
                                        let cast_id: Text = int_to_text(av.next_tmp);
                                        let cast: Text = text_concat("%t", cast_id);
                                        let out0: Text = s1_cg_line(av.text, text_concat(text_concat(text_concat(text_concat("  ", cast), " = ptrtoint %List* "), av.value), " to i64"));

                                        let raw_id: Text = int_to_text(av.next_tmp + 1);
                                        let raw: Text = text_concat("%t", raw_id);
                                        let out1: Text = s1_cg_line(out0, text_concat(text_concat("  ", raw), " = call i8* @malloc(i64 16)"));
                                        let ptr_id: Text = int_to_text(av.next_tmp + 2);
                                        let ptr: Text = text_concat("%t", ptr_id);
                                        let out2: Text = s1_cg_line(out1, text_concat(text_concat(text_concat("  ", ptr), " = bitcast i8* "), text_concat(raw, " to %Option*")));
                                        let tagp_id: Text = int_to_text(av.next_tmp + 3);
                                        let tagp: Text = text_concat("%t", tagp_id);
                                        let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat("  ", tagp), " = getelementptr inbounds %Option, %Option* "), text_concat(ptr, ", i32 0, i32 0")));
                                        let out4: Text = s1_cg_line(out3, text_concat("  store i8 0, i8* ", tagp));
                                        let payp_id: Text = int_to_text(av.next_tmp + 4);
                                        let payp: Text = text_concat("%t", payp_id);
                                        let out5: Text = s1_cg_line(out4, text_concat(text_concat(text_concat("  ", payp), " = getelementptr inbounds %Option, %Option* "), text_concat(ptr, ", i32 0, i32 1")));
                                        let out6: Text = s1_cg_line(out5, text_concat(text_concat("  store i64 ", cast), text_concat(", i64* ", payp)));
                                        s1_cg_expr_ok(S1CgExprOut { text: out6; value: ptr; ty: "%Option*"; s1_ty: out_s1; bb: bb; next_tmp: av.next_tmp + 5; })
                                      } else {
                                        s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: Option::Some payload type not supported in v0.4"))
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          };
                        }
                      };
                      _ => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: Option::Some expects one arg"));
                    }
                  };
                  _ => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: Option::Some expects one arg"));
                }
              } else {
                s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: unsupported Option variant in v0.4"))
              }
            }
          } else {
            // List constructor: `Cons(payload)`
            match p.segments {
              Cons(a0) => {
                if a0.head == "List" {
                  match a0.tail {
                    Cons(b0) => {
                      match b0.tail {
                        Nil => { is_list_ctor = true; list_variant = b0.head; 0 };
                        _ => 0;
                      };
                      0
                    };
                    _ => 0;
                  };
                  0
                } else {
                  match a0.tail {
                    Nil => {
                      if a0.head == "Cons" { is_list_ctor = true; list_variant = "Cons"; 0 } else { 0 };
                      0
                    };
                    _ => 0;
                  };
                  0
                };
                0
              };
              _ => 0;
            };

            if is_list_ctor == true {
              if list_variant == "Cons" {
                match c.args {
                  Cons(a0) => {
                    match a0.tail {
                      Nil => {
                        let rr: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(out, env, next_tmp, bb, items, strs, fns, a0.head);
                        match rr {
                          Err(e1) => s1_cg_expr_err(e1);
                          Ok(av) => {
                            if av.ty == "i8*" {
                              let cast_id: Text = int_to_text(av.next_tmp);
                              let cast: Text = text_concat("%t", cast_id);
                              let out0: Text = s1_cg_line(av.text, text_concat(text_concat(text_concat(text_concat("  ", cast), " = ptrtoint i8* "), av.value), " to i64"));

                              let raw_id: Text = int_to_text(av.next_tmp + 1);
                              let raw: Text = text_concat("%t", raw_id);
                              let out1: Text = s1_cg_line(out0, text_concat(text_concat("  ", raw), " = call i8* @malloc(i64 16)"));
                              let ptr_id: Text = int_to_text(av.next_tmp + 2);
                              let ptr: Text = text_concat("%t", ptr_id);
                              let out2: Text = s1_cg_line(out1, text_concat(text_concat(text_concat("  ", ptr), " = bitcast i8* "), text_concat(raw, " to %List*")));
                              let tagp_id: Text = int_to_text(av.next_tmp + 3);
                              let tagp: Text = text_concat("%t", tagp_id);
                              let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat("  ", tagp), " = getelementptr inbounds %List, %List* "), text_concat(ptr, ", i32 0, i32 0")));
                              let out4: Text = s1_cg_line(out3, text_concat("  store i8 1, i8* ", tagp));
                              let payp_id: Text = int_to_text(av.next_tmp + 4);
                              let payp: Text = text_concat("%t", payp_id);
                              let out5: Text = s1_cg_line(out4, text_concat(text_concat(text_concat("  ", payp), " = getelementptr inbounds %List, %List* "), text_concat(ptr, ", i32 0, i32 1")));
                              let out6: Text = s1_cg_line(out5, text_concat(text_concat("  store i64 ", cast), text_concat(", i64* ", payp)));

                              // Best-effort type info: if payload is ListCons<T>, infer List<T>.
                              let s1: Option<S1Type> = s1_cg_s1_ty_none();
                              match av.s1_ty {
                                None => 0;
                                Some(rt) => {
                                  match s1_cg_path_single_name(rt.path) {
                                    Some(nm) => {
                                      if nm == "ListCons" {
                                        match rt.args {
                                          Cons(t0) => {
                                            match t0.tail {
                                              Nil => { s1 = s1_cg_s1_ty_some(s1_cg_s1_type_list(t0.head)); 0 };
                                              _ => 0;
                                            };
                                            0
                                          };
                                          _ => 0;
                                        };
                                        0
                                      } else { 0 };
                                      0
                                    };
                                    _ => 0;
                                  };
                                  0
                                };
                              };

                              s1_cg_expr_ok(S1CgExprOut { text: out6; value: ptr; ty: "%List*"; s1_ty: s1; bb: av.bb; next_tmp: av.next_tmp + 5; })
                            } else {
                              s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: List::Cons expects record payload as i8* in v0"))
                            }
                          };
                        }
                      };
                      _ => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: List::Cons expects one arg"));
                    }
                  };
                  _ => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: List::Cons expects one arg"));
                }
              } else {
                s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: unsupported List variant in v0"))
              }
            } else {
          match s1_cg_path_single_name(p) {
            None => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: callee path not supported"));
            Some(fname) => {
              // Evaluate args left-to-right.
              let args_text: Text = "";
              let out_acc: Text = out;
              let next_acc: Int = next_tmp;
              let cur: List<S1Expr> = c.args;
              let done: Bool = false;

              // Mutable accumulators.
              let at: Text = args_text;
              let ot: Text = out_acc;
              let nt: Int = next_acc;
              let bt: Text = bb;
              let first: Bool = true;
              let ok: Bool = true;
              let diag: S1Diagnostic = s1_diag(Error, 0, 0, "codegen: arg eval failed");
              let argc: Int = 0;
              let a_val: Text = "";
              let a_ty: Text = "";
              let b_val: Text = "";
              let b_ty: Text = "";
              let c_val: Text = "";
              let c_ty: Text = "";
              let arg_tys_rev: List<Text> = Nil;
              let arg_vals_rev: List<Text> = Nil;
              let all_i64: Bool = true;

              while done == false {
                match cur {
                  Nil => { done = true; 0 };
                  Cons(c0) => {
                    let rr: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(ot, env, nt, bt, items, strs, fns, c0.head);
                    match rr {
                      Err(e3) => {
                        ok = false;
                        diag = e3;
                        done = true;
                        0
                      };
                      Ok(r) => {
                        let piece: Text = text_concat(text_concat(r.ty, " "), r.value);
                        if first == true {
                          at = piece;
                          first = false;
                          0
                        } else {
                          at = text_concat(text_concat(at, ", "), piece);
                          0
                        };

                        arg_tys_rev = Cons(ListCons<Text> { head: r.ty; tail: arg_tys_rev; });
                        arg_vals_rev = Cons(ListCons<Text> { head: r.value; tail: arg_vals_rev; });

                        if argc == 0 { a_val = r.value; a_ty = r.ty; 0 } else { 0 };
                        if argc == 1 { b_val = r.value; b_ty = r.ty; 0 } else { 0 };
                        if argc == 2 { c_val = r.value; c_ty = r.ty; 0 } else { 0 };
                        argc = argc + 1;
                        if r.ty == "i64" { 0 } else { all_i64 = false; 0 };

                        ot = r.text;
                        nt = r.next_tmp;
                        bt = r.bb;
                        cur = c0.tail;
                        0
                      };
                    }
                    ;
                    0
                  };
                }
              };

              if ok == false {
                s1_cg_expr_err(diag)
              } else {
                if fname == "text_concat" {
                  if argc == 2 {
                    if a_ty == "i8*" {
                      if b_ty == "i8*" {
                        let tmp_id: Text = int_to_text(nt);
                        let tmp: Text = text_concat("%t", tmp_id);
                        let call_head: Text = text_concat(text_concat(text_concat("  ", tmp), " = call i8* @kx_text_concat"), "(");
                        let inst: Text = text_concat(call_head, text_concat(at, ")"));
                        let out2: Text = s1_cg_line(ot, inst);
                        s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: "i8*"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Text")); bb: bt; next_tmp: nt + 1; })
                      } else {
                        s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_concat expects (Text, Text)"))
                      }
                    } else {
                      s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_concat expects (Text, Text)"))
                    }
                  } else {
                    s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_concat expects (Text, Text)"))
                  }
                } else {
                  if fname == "int_to_text" {
                    if argc == 1 {
                      if a_ty == "i64" {
                        let tmp_id: Text = int_to_text(nt);
                        let tmp: Text = text_concat("%t", tmp_id);
                        let inst: Text = text_concat(
                          text_concat(text_concat(text_concat("  ", tmp), " = call i8* @kx_int_to_text(i64 "), a_val),
                          ")"
                        );
                        let out2: Text = s1_cg_line(ot, inst);
                        s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: "i8*"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Text")); bb: bt; next_tmp: nt + 1; })
                      } else {
                        s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: int_to_text expects (Int)"))
                      }
                    } else {
                      s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: int_to_text expects (Int)"))
                    }
                  } else {
                    if fname == "text_len" {
                      if argc == 1 {
                        if a_ty == "i8*" {
                          let tmp_id: Text = int_to_text(nt);
                          let tmp: Text = text_concat("%t", tmp_id);
                          let inst: Text = text_concat(
                            text_concat(text_concat(text_concat("  ", tmp), " = call i64 @strlen(i8* "), a_val),
                            ")"
                          );
                          let out2: Text = s1_cg_line(ot, inst);
                          s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: "i64"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Int")); bb: bt; next_tmp: nt + 1; })
                        } else {
                          s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_len expects (Text)"))
                        }
                      } else {
                        s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_len expects (Text)"))
                      }
                    } else {
                      if fname == "text_starts_with" {
                        if argc == 2 {
                          if a_ty == "i8*" {
                            if b_ty == "i8*" {
                          // Implemented in terms of strlen+memcmp; avoids out-of-bounds reads.
                          let plen_id: Text = int_to_text(nt);
                          let plen: Text = text_concat("%t", plen_id);
                          let inst_plen: Text = text_concat(
                            text_concat(text_concat(text_concat("  ", plen), " = call i64 @strlen(i8* "), b_val),
                            ")"
                          );
                          let out1: Text = s1_cg_line(ot, inst_plen);
	                          let slen_id: Text = int_to_text(nt + 1);
	                          let slen: Text = text_concat("%t", slen_id);
	                          let inst_slen: Text = text_concat(
	                            text_concat(text_concat(text_concat("  ", slen), " = call i64 @strlen(i8* "), a_val),
	                            ")"
	                          );
	                          let out2: Text = s1_cg_line(out1, inst_slen);
                          let ge_id: Text = int_to_text(nt + 2);
                          let ge: Text = text_concat("%t", ge_id);
                          let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat(text_concat("  ", ge), " = icmp uge i64 "), slen), text_concat(", ", plen)));

                          let slot_id: Text = int_to_text(nt + 3);
                          let slot: Text = text_concat("%t", slot_id);
                          let out4: Text = s1_cg_line(out3, text_concat(text_concat(text_concat("  ", slot), " = alloca "), "i1"));
                          let out5: Text = s1_cg_line(out4, text_concat("  store i1 0, i1* ", slot));

                          let ok_lbl: Text = text_concat("sw_ok", int_to_text(nt + 4));
                          let join_lbl: Text = text_concat("sw_join", int_to_text(nt + 5));
                          let br1: Text = text_concat(
                            text_concat(text_concat("  br i1 ", ge), text_concat(", label %", ok_lbl)),
                            text_concat(", label %", join_lbl)
                          );
                          let out6: Text = s1_cg_line(out5, br1);

	                          let out_ok_lbl: Text = s1_cg_line(out6, text_concat(ok_lbl, ":"));
	                          let cmp_id: Text = int_to_text(nt + 6);
	                          let cmp: Text = text_concat("%t", cmp_id);
	                          let inst_cmp0: Text = text_concat(text_concat("  ", cmp), " = call i32 @memcmp(i8* ");
	                          let inst_cmp1: Text = text_concat(inst_cmp0, a_val);
	                          let inst_cmp2: Text = text_concat(inst_cmp1, ", i8* ");
	                          let inst_cmp3: Text = text_concat(inst_cmp2, b_val);
	                          let inst_cmp4: Text = text_concat(inst_cmp3, ", i64 ");
	                          let inst_cmp5: Text = text_concat(inst_cmp4, plen);
	                          let inst_cmp: Text = text_concat(inst_cmp5, ")");
	                          let out7: Text = s1_cg_line(out_ok_lbl, inst_cmp);

                          let eq_id: Text = int_to_text(nt + 7);
                          let eq0: Text = text_concat("%t", eq_id);
                          let out8: Text = s1_cg_line(out7, text_concat(text_concat(text_concat(text_concat("  ", eq0), " = icmp eq i32 "), cmp), ", 0"));
                          let out9: Text = s1_cg_line(out8, text_concat("  store i1 ", text_concat(eq0, text_concat(", i1* ", slot))));
                          let out10: Text = s1_cg_line(out9, text_concat("  br label %", join_lbl));

                          let out_join_lbl: Text = s1_cg_line(out10, text_concat(join_lbl, ":"));
                          let outv_id: Text = int_to_text(nt + 8);
                          let outv: Text = text_concat("%t", outv_id);
                          let out11: Text = s1_cg_line(out_join_lbl, text_concat(text_concat(text_concat("  ", outv), " = load i1, i1* "), slot));

                          s1_cg_expr_ok(S1CgExprOut { text: out11; value: outv; ty: "i1"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Bool")); bb: join_lbl; next_tmp: nt + 9; })
                            } else {
                              s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_starts_with expects (Text, Text)"))
                            }
                          } else {
                            s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_starts_with expects (Text, Text)"))
                          }
                        } else {
                          s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_starts_with expects (Text, Text)"))
                        }
                      } else {
                        if fname == "text_byte_at" {
                          // Returns Option<Int>
                          if argc == 2 {
                            if a_ty == "i8*" {
                              if b_ty == "i64" {
                                let idx_neg_id: Text = int_to_text(nt);
                                let idx_neg: Text = text_concat("%t", idx_neg_id);
                                let out1: Text = s1_cg_line(ot, text_concat(text_concat(text_concat(text_concat("  ", idx_neg), " = icmp slt i64 "), b_val), ", 0"));
                                let len_id: Text = int_to_text(nt + 1);
                                let len: Text = text_concat("%t", len_id);
                                let out2: Text = s1_cg_line(out1, text_concat(text_concat(text_concat("  ", len), " = call i64 @strlen(i8* "), text_concat(a_val, ")")));
                                let idx_uge_id: Text = int_to_text(nt + 2);
                                let idx_uge: Text = text_concat("%t", idx_uge_id);
                                let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat(text_concat("  ", idx_uge), " = icmp uge i64 "), b_val), text_concat(", ", len)));
                                let oob_id: Text = int_to_text(nt + 3);
                                let oob: Text = text_concat("%t", oob_id);
                                let out4: Text = s1_cg_line(out3, text_concat(text_concat(text_concat(text_concat("  ", oob), " = or i1 "), idx_neg), text_concat(", ", idx_uge)));

                                let ok_lbl: Text = text_concat("tba_ok", int_to_text(nt + 5));
                                let none_lbl: Text = text_concat("tba_none", int_to_text(nt + 6));
                                let join_lbl: Text = text_concat("tba_join", int_to_text(nt + 7));

                                let slot_id: Text = int_to_text(nt + 4);
                                let slot: Text = text_concat("%t", slot_id);
                                let out5: Text = s1_cg_line(out4, text_concat(text_concat(text_concat("  ", slot), " = alloca "), "%Option*"));

                                let br0: Text = text_concat(
                                  text_concat(text_concat("  br i1 ", oob), text_concat(", label %", none_lbl)),
                                  text_concat(", label %", ok_lbl)
                                );
                                let out6: Text = s1_cg_line(out5, br0);

                                // ok: Some(byte)
                                let out_ok_lbl: Text = s1_cg_line(out6, text_concat(ok_lbl, ":"));
                                let gep_id: Text = int_to_text(nt + 5);
                                let gep: Text = text_concat("%t", gep_id);
                                let inst_gep: Text = text_concat(text_concat(text_concat("  ", gep), " = getelementptr inbounds i8, i8* "), text_concat(a_val, text_concat(", i64 ", b_val)));
                                let out7: Text = s1_cg_line(out_ok_lbl, inst_gep);
                                let b_id: Text = int_to_text(nt + 6);
                                let b: Text = text_concat("%t", b_id);
                                let out8: Text = s1_cg_line(out7, text_concat(text_concat(text_concat("  ", b), " = load i8, i8* "), gep));
                                let bz_id: Text = int_to_text(nt + 7);
                                let bz: Text = text_concat("%t", bz_id);
                                let out9: Text = s1_cg_line(out8, text_concat(text_concat(text_concat("  ", bz), " = zext i8 "), text_concat(b, " to i64")));

                                let raw_id: Text = int_to_text(nt + 8);
                                let raw: Text = text_concat("%t", raw_id);
                                let out10: Text = s1_cg_line(out9, text_concat(text_concat("  ", raw), " = call i8* @malloc(i64 16)"));
                                let ptr_id: Text = int_to_text(nt + 9);
                                let ptr: Text = text_concat("%t", ptr_id);
                                let out11: Text = s1_cg_line(out10, text_concat(text_concat(text_concat("  ", ptr), " = bitcast i8* "), text_concat(raw, " to %Option*")));
                                let tagp_id: Text = int_to_text(nt + 10);
                                let tagp: Text = text_concat("%t", tagp_id);
                                let out12: Text = s1_cg_line(out11, text_concat(text_concat(text_concat("  ", tagp), " = getelementptr inbounds %Option, %Option* "), text_concat(ptr, ", i32 0, i32 0")));
                                let out13: Text = s1_cg_line(out12, text_concat("  store i8 0, i8* ", tagp));
                                let payp_id: Text = int_to_text(nt + 11);
                                let payp: Text = text_concat("%t", payp_id);
                                let out14: Text = s1_cg_line(out13, text_concat(text_concat(text_concat("  ", payp), " = getelementptr inbounds %Option, %Option* "), text_concat(ptr, ", i32 0, i32 1")));
                                let out15: Text = s1_cg_line(out14, text_concat(text_concat("  store i64 ", bz), text_concat(", i64* ", payp)));
                                let out16: Text = s1_cg_line(out15, text_concat("  store %Option* ", text_concat(ptr, text_concat(", %Option** ", slot))));
                                let out17: Text = s1_cg_line(out16, text_concat("  br label %", join_lbl));

                                // none: None
                                let out_none_lbl: Text = s1_cg_line(out17, text_concat(none_lbl, ":"));
                                let raw2_id: Text = int_to_text(nt + 12);
                                let raw2: Text = text_concat("%t", raw2_id);
                                let out18: Text = s1_cg_line(out_none_lbl, text_concat(text_concat("  ", raw2), " = call i8* @malloc(i64 16)"));
                                let ptr2_id: Text = int_to_text(nt + 13);
                                let ptr2: Text = text_concat("%t", ptr2_id);
                                let out19: Text = s1_cg_line(out18, text_concat(text_concat(text_concat("  ", ptr2), " = bitcast i8* "), text_concat(raw2, " to %Option*")));
                                let tagp2_id: Text = int_to_text(nt + 14);
                                let tagp2: Text = text_concat("%t", tagp2_id);
                                let out20: Text = s1_cg_line(out19, text_concat(text_concat(text_concat("  ", tagp2), " = getelementptr inbounds %Option, %Option* "), text_concat(ptr2, ", i32 0, i32 0")));
                                let out21: Text = s1_cg_line(out20, text_concat("  store i8 1, i8* ", tagp2));
                                let payp2_id: Text = int_to_text(nt + 15);
                                let payp2: Text = text_concat("%t", payp2_id);
                                let out22: Text = s1_cg_line(out21, text_concat(text_concat(text_concat("  ", payp2), " = getelementptr inbounds %Option, %Option* "), text_concat(ptr2, ", i32 0, i32 1")));
                                let out23: Text = s1_cg_line(out22, text_concat("  store i64 0, i64* ", payp2));
                                let out24: Text = s1_cg_line(out23, text_concat("  store %Option* ", text_concat(ptr2, text_concat(", %Option** ", slot))));
                                let out25: Text = s1_cg_line(out24, text_concat("  br label %", join_lbl));

                                // join
                                let out_join_lbl: Text = s1_cg_line(out25, text_concat(join_lbl, ":"));
                                let outv_id: Text = int_to_text(nt + 16);
                                let outv: Text = text_concat("%t", outv_id);
                                let out26: Text = s1_cg_line(out_join_lbl, text_concat(text_concat(text_concat("  ", outv), " = load %Option*, %Option** "), slot));
                                s1_cg_expr_ok(S1CgExprOut { text: out26; value: outv; ty: "%Option*"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_option_int()); bb: join_lbl; next_tmp: nt + 17; })
                              } else {
                                s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_byte_at expects (Text, Int)"))
                              }
                            } else {
                              s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_byte_at expects (Text, Int)"))
                            }
                          } else {
                            s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_byte_at expects (Text, Int)"))
                          }
                        } else {
                        if fname == "text_slice" {
                          // Returns Option<Text>
                          if argc == 3 {
                            if a_ty == "i8*" {
                              if b_ty == "i64" {
                                if c_ty == "i64" {
                                  let start_neg_id: Text = int_to_text(nt);
                                  let start_neg: Text = text_concat("%t", start_neg_id);
                                  let out1: Text = s1_cg_line(ot, text_concat(text_concat(text_concat(text_concat("  ", start_neg), " = icmp slt i64 "), b_val), ", 0"));
                                  let end_neg_id: Text = int_to_text(nt + 1);
                                  let end_neg: Text = text_concat("%t", end_neg_id);
                                  let out2: Text = s1_cg_line(out1, text_concat(text_concat(text_concat(text_concat("  ", end_neg), " = icmp slt i64 "), c_val), ", 0"));
                                  let neg_id: Text = int_to_text(nt + 2);
                                  let neg: Text = text_concat("%t", neg_id);
                                  let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat(text_concat("  ", neg), " = or i1 "), start_neg), text_concat(", ", end_neg)));

                                  let slen_id: Text = int_to_text(nt + 3);
                                  let slen: Text = text_concat("%t", slen_id);
                                  let out4: Text = s1_cg_line(out3, text_concat(text_concat(text_concat("  ", slen), " = call i64 @strlen(i8* "), text_concat(a_val, ")")));
                                  let start_gt_end_id: Text = int_to_text(nt + 4);
                                  let start_gt_end: Text = text_concat("%t", start_gt_end_id);
                                  let out5: Text = s1_cg_line(out4, text_concat(text_concat(text_concat(text_concat("  ", start_gt_end), " = icmp sgt i64 "), b_val), text_concat(", ", c_val)));
                                  let end_gt_len_id: Text = int_to_text(nt + 5);
                                  let end_gt_len: Text = text_concat("%t", end_gt_len_id);
                                  let out6: Text = s1_cg_line(out5, text_concat(text_concat(text_concat(text_concat("  ", end_gt_len), " = icmp sgt i64 "), c_val), text_concat(", ", slen)));
                                  let gt_id: Text = int_to_text(nt + 6);
                                  let gt: Text = text_concat("%t", gt_id);
                                  let out7: Text = s1_cg_line(out6, text_concat(text_concat(text_concat(text_concat("  ", gt), " = or i1 "), start_gt_end), text_concat(", ", end_gt_len)));
                                  let invalid_id: Text = int_to_text(nt + 7);
                                  let invalid: Text = text_concat("%t", invalid_id);
                                  let out8: Text = s1_cg_line(out7, text_concat(text_concat(text_concat(text_concat("  ", invalid), " = or i1 "), neg), text_concat(", ", gt)));

                                  let slot_id: Text = int_to_text(nt + 8);
                                  let slot: Text = text_concat("%t", slot_id);
                                  let out9: Text = s1_cg_line(out8, text_concat(text_concat(text_concat("  ", slot), " = alloca "), "%Option*"));

                                  let ok_lbl: Text = text_concat("ts_ok", int_to_text(nt + 9));
                                  let none_lbl: Text = text_concat("ts_none", int_to_text(nt + 10));
                                  let join_lbl: Text = text_concat("ts_join", int_to_text(nt + 11));

                                  let br0: Text = text_concat(
                                    text_concat(text_concat("  br i1 ", invalid), text_concat(", label %", none_lbl)),
                                    text_concat(", label %", ok_lbl)
                                  );
                                  let out10: Text = s1_cg_line(out9, br0);

                                  // ok: Some(slice)
                                  let out_ok_lbl: Text = s1_cg_line(out10, text_concat(ok_lbl, ":"));
                                  let slice_len_id: Text = int_to_text(nt + 9);
                                  let slice_len: Text = text_concat("%t", slice_len_id);
                                  let out11: Text = s1_cg_line(out_ok_lbl, text_concat(text_concat(text_concat(text_concat("  ", slice_len), " = sub i64 "), c_val), text_concat(", ", b_val)));
                                  let lenp1_id: Text = int_to_text(nt + 10);
                                  let lenp1: Text = text_concat("%t", lenp1_id);
                                  let out12: Text = s1_cg_line(out11, text_concat(text_concat(text_concat(text_concat("  ", lenp1), " = add i64 "), slice_len), ", 1"));
                                  let buf_id: Text = int_to_text(nt + 11);
                                  let buf: Text = text_concat("%t", buf_id);
                                  let out13: Text = s1_cg_line(out12, text_concat(text_concat(text_concat("  ", buf), " = call i8* @malloc(i64 "), text_concat(lenp1, ")")));
                                  let src_id: Text = int_to_text(nt + 12);
                                  let src: Text = text_concat("%t", src_id);
                                  let out14: Text = s1_cg_line(out13, text_concat(text_concat(text_concat("  ", src), " = getelementptr inbounds i8, i8* "), text_concat(a_val, text_concat(", i64 ", b_val))));
                                  let cp_id: Text = int_to_text(nt + 13);
                                  let cp: Text = text_concat("%t", cp_id);
                                  let inst_cp0: Text = text_concat(text_concat(text_concat("  ", cp), " = call i8* @memcpy(i8* "), buf);
                                  let inst_cp1: Text = text_concat(inst_cp0, ", i8* ");
                                  let inst_cp2: Text = text_concat(inst_cp1, src);
                                  let inst_cp3: Text = text_concat(inst_cp2, ", i64 ");
                                  let inst_cp4: Text = text_concat(inst_cp3, slice_len);
                                  let inst_cp: Text = text_concat(inst_cp4, ")");
                                  let out15: Text = s1_cg_line(out14, inst_cp);
                                  let termp_id: Text = int_to_text(nt + 14);
                                  let termp: Text = text_concat("%t", termp_id);
                                  let out16: Text = s1_cg_line(out15, text_concat(text_concat(text_concat("  ", termp), " = getelementptr inbounds i8, i8* "), text_concat(buf, text_concat(", i64 ", slice_len))));
                                  let out17: Text = s1_cg_line(out16, text_concat("  store i8 0, i8* ", termp));

                                  // Allocate Option payload (ptr stored as i64).
                                  let raw_id: Text = int_to_text(nt + 15);
                                  let raw: Text = text_concat("%t", raw_id);
                                  let out18: Text = s1_cg_line(out17, text_concat(text_concat("  ", raw), " = call i8* @malloc(i64 16)"));
                                  let ptr_id: Text = int_to_text(nt + 16);
                                  let ptr: Text = text_concat("%t", ptr_id);
                                  let out19: Text = s1_cg_line(out18, text_concat(text_concat(text_concat("  ", ptr), " = bitcast i8* "), text_concat(raw, " to %Option*")));
                                  let tagp_id: Text = int_to_text(nt + 17);
                                  let tagp: Text = text_concat("%t", tagp_id);
                                  let out20: Text = s1_cg_line(out19, text_concat(text_concat(text_concat("  ", tagp), " = getelementptr inbounds %Option, %Option* "), text_concat(ptr, ", i32 0, i32 0")));
                                  let out21: Text = s1_cg_line(out20, text_concat("  store i8 0, i8* ", tagp));
                                  let payp_id: Text = int_to_text(nt + 18);
                                  let payp: Text = text_concat("%t", payp_id);
                                  let out22: Text = s1_cg_line(out21, text_concat(text_concat(text_concat("  ", payp), " = getelementptr inbounds %Option, %Option* "), text_concat(ptr, ", i32 0, i32 1")));
                                  let payw_id: Text = int_to_text(nt + 19);
                                  let payw: Text = text_concat("%t", payw_id);
                                  let out23: Text = s1_cg_line(out22, text_concat(text_concat(text_concat(text_concat("  ", payw), " = ptrtoint i8* "), buf), " to i64"));
                                  let out24: Text = s1_cg_line(out23, text_concat(text_concat("  store i64 ", payw), text_concat(", i64* ", payp)));
                                  let out25: Text = s1_cg_line(out24, text_concat("  store %Option* ", text_concat(ptr, text_concat(", %Option** ", slot))));
                                  let out26: Text = s1_cg_line(out25, text_concat("  br label %", join_lbl));

                                  // none: None
                                  let out_none_lbl: Text = s1_cg_line(out26, text_concat(none_lbl, ":"));
                                  let raw2_id: Text = int_to_text(nt + 20);
                                  let raw2: Text = text_concat("%t", raw2_id);
                                  let out27: Text = s1_cg_line(out_none_lbl, text_concat(text_concat("  ", raw2), " = call i8* @malloc(i64 16)"));
                                  let ptr2_id: Text = int_to_text(nt + 21);
                                  let ptr2: Text = text_concat("%t", ptr2_id);
                                  let out28: Text = s1_cg_line(out27, text_concat(text_concat(text_concat("  ", ptr2), " = bitcast i8* "), text_concat(raw2, " to %Option*")));
                                  let tagp2_id: Text = int_to_text(nt + 22);
                                  let tagp2: Text = text_concat("%t", tagp2_id);
                                  let out29: Text = s1_cg_line(out28, text_concat(text_concat(text_concat("  ", tagp2), " = getelementptr inbounds %Option, %Option* "), text_concat(ptr2, ", i32 0, i32 0")));
                                  let out30: Text = s1_cg_line(out29, text_concat("  store i8 1, i8* ", tagp2));
                                  let payp2_id: Text = int_to_text(nt + 23);
                                  let payp2: Text = text_concat("%t", payp2_id);
                                  let out31: Text = s1_cg_line(out30, text_concat(text_concat(text_concat("  ", payp2), " = getelementptr inbounds %Option, %Option* "), text_concat(ptr2, ", i32 0, i32 1")));
                                  let out32: Text = s1_cg_line(out31, text_concat("  store i64 0, i64* ", payp2));
                                  let out33: Text = s1_cg_line(out32, text_concat("  store %Option* ", text_concat(ptr2, text_concat(", %Option** ", slot))));
                                  let out34: Text = s1_cg_line(out33, text_concat("  br label %", join_lbl));

                                  // join
                                  let out_join_lbl: Text = s1_cg_line(out34, text_concat(join_lbl, ":"));
                                  let outv_id: Text = int_to_text(nt + 24);
                                  let outv: Text = text_concat("%t", outv_id);
                                  let out35: Text = s1_cg_line(out_join_lbl, text_concat(text_concat(text_concat("  ", outv), " = load %Option*, %Option** "), slot));
                                  s1_cg_expr_ok(S1CgExprOut { text: out35; value: outv; ty: "%Option*"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_option_text()); bb: join_lbl; next_tmp: nt + 25; })
                                } else {
                                  s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_slice expects (Text, Int, Int)"))
                                }
                              } else {
                                s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_slice expects (Text, Int, Int)"))
                              }
                            } else {
                              s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_slice expects (Text, Int, Int)"))
                            }
                          } else {
                            s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_slice expects (Text, Int, Int)"))
                          }
                        } else {
                        if fname == "host_load_source_map" {
                          if argc == 1 {
                            if a_ty == "i8*" {
                              let raw_id: Text = int_to_text(nt);
                              let raw: Text = text_concat("%t", raw_id);
                              let inst: Text = text_concat(text_concat("  ", raw), text_concat(" = call i8* @kx_host_load_source_map(i8* ", text_concat(a_val, ")")));
                              let out2: Text = s1_cg_line(ot, inst);
                              let cast_id: Text = int_to_text(nt + 1);
                              let cast: Text = text_concat("%t", cast_id);
                              let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat("  ", cast), " = bitcast i8* "), text_concat(raw, " to %Result*")));
                              let st: S1Type = s1_cg_s1_type_result(s1_cg_s1_type_prim("Text"), s1_cg_s1_type_prim("Text"));
                              s1_cg_expr_ok(S1CgExprOut { text: out3; value: cast; ty: "%Result*"; s1_ty: s1_cg_s1_ty_some(st); bb: bt; next_tmp: nt + 2; })
                            } else {
                              s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: host_load_source_map expects (Text)"))
                            }
                          } else {
                            s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: host_load_source_map expects (Text)"))
                          }
                        } else {
                          if fname == "host_write_file" {
                            if argc == 2 {
                              if a_ty == "i8*" {
                                if b_ty == "i8*" {
                                  let raw_id: Text = int_to_text(nt);
                                  let raw: Text = text_concat("%t", raw_id);
                                  let inst: Text = text_concat(text_concat("  ", raw), text_concat(" = call i8* @kx_host_write_file(i8* ", text_concat(a_val, text_concat(", i8* ", text_concat(b_val, ")")))));
                                  let out2: Text = s1_cg_line(ot, inst);
                                  let cast_id: Text = int_to_text(nt + 1);
                                  let cast: Text = text_concat("%t", cast_id);
                                  let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat("  ", cast), " = bitcast i8* "), text_concat(raw, " to %Result*")));
                                  let st: S1Type = s1_cg_s1_type_result(s1_cg_s1_type_prim("Int"), s1_cg_s1_type_prim("Text"));
                                  s1_cg_expr_ok(S1CgExprOut { text: out3; value: cast; ty: "%Result*"; s1_ty: s1_cg_s1_ty_some(st); bb: bt; next_tmp: nt + 2; })
                                } else {
                                  s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: host_write_file expects (Text, Text)"))
                                }
                              } else {
                                s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: host_write_file expects (Text, Text)"))
                              }
                            } else {
                              s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: host_write_file expects (Text, Text)"))
                            }
                          } else {
                            if fname == "host_eprintln" {
                              if argc == 1 {
                                if a_ty == "i8*" {
                                  let inst: Text = text_concat(text_concat("  call void @kx_host_eprintln(i8* ", a_val), ")");
                                  let out2: Text = s1_cg_line(ot, inst);
                                  s1_cg_expr_ok(S1CgExprOut { text: out2; value: "0"; ty: "void"; s1_ty: s1_cg_s1_ty_none(); bb: bt; next_tmp: nt; })
                                } else {
                                  s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: host_eprintln expects (Text)"))
                                }
                              } else {
                                s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: host_eprintln expects (Text)"))
                              }
                            } else {
                              if fname == "byte_is_ascii_whitespace" {
                                if argc == 1 {
                                  if a_ty == "i64" {
                                    let eq9_id: Text = int_to_text(nt);
                                    let eq9: Text = text_concat("%t", eq9_id);
                                    let out1: Text = s1_cg_line(ot, text_concat(text_concat(text_concat(text_concat("  ", eq9), " = icmp eq i64 "), a_val), ", 9"));
                                    let eq10_id: Text = int_to_text(nt + 1);
                                    let eq10: Text = text_concat("%t", eq10_id);
                                    let out2: Text = s1_cg_line(out1, text_concat(text_concat(text_concat(text_concat("  ", eq10), " = icmp eq i64 "), a_val), ", 10"));
                                    let eq13_id: Text = int_to_text(nt + 2);
                                    let eq13: Text = text_concat("%t", eq13_id);
                                    let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat(text_concat("  ", eq13), " = icmp eq i64 "), a_val), ", 13"));
                                    let eq32_id: Text = int_to_text(nt + 3);
                                    let eq32: Text = text_concat("%t", eq32_id);
                                    let out4: Text = s1_cg_line(out3, text_concat(text_concat(text_concat(text_concat("  ", eq32), " = icmp eq i64 "), a_val), ", 32"));
                                    let or0_id: Text = int_to_text(nt + 4);
                                    let or0: Text = text_concat("%t", or0_id);
                                    let out5: Text = s1_cg_line(out4, text_concat(text_concat(text_concat(text_concat("  ", or0), " = or i1 "), eq9), text_concat(", ", eq10)));
                                    let or1_id: Text = int_to_text(nt + 5);
                                    let or1: Text = text_concat("%t", or1_id);
                                    let out6: Text = s1_cg_line(out5, text_concat(text_concat(text_concat(text_concat("  ", or1), " = or i1 "), or0), text_concat(", ", eq13)));
                                    let outv_id: Text = int_to_text(nt + 6);
                                    let outv: Text = text_concat("%t", outv_id);
                                    let out7: Text = s1_cg_line(out6, text_concat(text_concat(text_concat(text_concat("  ", outv), " = or i1 "), or1), text_concat(", ", eq32)));
                                    s1_cg_expr_ok(S1CgExprOut { text: out7; value: outv; ty: "i1"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Bool")); bb: bt; next_tmp: nt + 7; })
                                  } else {
                                    s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: byte_is_ascii_whitespace expects (Int)"))
                                  }
                                } else {
                                  s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: byte_is_ascii_whitespace expects (Int)"))
                                }
                              } else {
                                if fname == "byte_is_ascii_digit" {
                                  if argc == 1 {
                                    if a_ty == "i64" {
                                      let ge_id: Text = int_to_text(nt);
                                      let ge: Text = text_concat("%t", ge_id);
                                      let out1: Text = s1_cg_line(ot, text_concat(text_concat(text_concat(text_concat("  ", ge), " = icmp sge i64 "), a_val), ", 48"));
                                      let le_id: Text = int_to_text(nt + 1);
                                      let le: Text = text_concat("%t", le_id);
                                      let out2: Text = s1_cg_line(out1, text_concat(text_concat(text_concat(text_concat("  ", le), " = icmp sle i64 "), a_val), ", 57"));
                                      let outv_id: Text = int_to_text(nt + 2);
                                      let outv: Text = text_concat("%t", outv_id);
                                      let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat(text_concat("  ", outv), " = and i1 "), ge), text_concat(", ", le)));
                                      s1_cg_expr_ok(S1CgExprOut { text: out3; value: outv; ty: "i1"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Bool")); bb: bt; next_tmp: nt + 3; })
                                    } else {
                                      s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: byte_is_ascii_digit expects (Int)"))
                                    }
                                  } else {
                                    s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: byte_is_ascii_digit expects (Int)"))
                                  }
                                } else {
                                  if fname == "byte_is_ascii_alpha" {
                                    if argc == 1 {
                                      if a_ty == "i64" {
                                        let uge_id: Text = int_to_text(nt);
                                        let uge: Text = text_concat("%t", uge_id);
                                        let out1: Text = s1_cg_line(ot, text_concat(text_concat(text_concat(text_concat("  ", uge), " = icmp sge i64 "), a_val), ", 65"));
                                        let ule_id: Text = int_to_text(nt + 1);
                                        let ule: Text = text_concat("%t", ule_id);
                                        let out2: Text = s1_cg_line(out1, text_concat(text_concat(text_concat(text_concat("  ", ule), " = icmp sle i64 "), a_val), ", 90"));
                                        let up_id: Text = int_to_text(nt + 2);
                                        let up: Text = text_concat("%t", up_id);
                                        let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat(text_concat("  ", up), " = and i1 "), uge), text_concat(", ", ule)));

                                        let lge_id: Text = int_to_text(nt + 3);
                                        let lge: Text = text_concat("%t", lge_id);
                                        let out4: Text = s1_cg_line(out3, text_concat(text_concat(text_concat(text_concat("  ", lge), " = icmp sge i64 "), a_val), ", 97"));
                                        let lle_id: Text = int_to_text(nt + 4);
                                        let lle: Text = text_concat("%t", lle_id);
                                        let out5: Text = s1_cg_line(out4, text_concat(text_concat(text_concat(text_concat("  ", lle), " = icmp sle i64 "), a_val), ", 122"));
                                        let low_id: Text = int_to_text(nt + 5);
                                        let low: Text = text_concat("%t", low_id);
                                        let out6: Text = s1_cg_line(out5, text_concat(text_concat(text_concat(text_concat("  ", low), " = and i1 "), lge), text_concat(", ", lle)));

                                        let outv_id: Text = int_to_text(nt + 6);
                                        let outv: Text = text_concat("%t", outv_id);
                                        let out7: Text = s1_cg_line(out6, text_concat(text_concat(text_concat(text_concat("  ", outv), " = or i1 "), up), text_concat(", ", low)));
                                        s1_cg_expr_ok(S1CgExprOut { text: out7; value: outv; ty: "i1"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Bool")); bb: bt; next_tmp: nt + 7; })
                                      } else {
                                        s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: byte_is_ascii_alpha expects (Int)"))
                                      }
                                    } else {
                                      s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: byte_is_ascii_alpha expects (Int)"))
                                    }
                                  } else {
                                    if fname == "byte_is_ascii_alnum" {
                                      if argc == 1 {
                                        if a_ty == "i64" {
                                          let dge_id: Text = int_to_text(nt);
                                          let dge: Text = text_concat("%t", dge_id);
                                          let out1: Text = s1_cg_line(ot, text_concat(text_concat(text_concat(text_concat("  ", dge), " = icmp sge i64 "), a_val), ", 48"));
                                          let dle_id: Text = int_to_text(nt + 1);
                                          let dle: Text = text_concat("%t", dle_id);
                                          let out2: Text = s1_cg_line(out1, text_concat(text_concat(text_concat(text_concat("  ", dle), " = icmp sle i64 "), a_val), ", 57"));
                                          let dig_id: Text = int_to_text(nt + 2);
                                          let dig: Text = text_concat("%t", dig_id);
                                          let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat(text_concat("  ", dig), " = and i1 "), dge), text_concat(", ", dle)));

                                          let uge_id: Text = int_to_text(nt + 3);
                                          let uge: Text = text_concat("%t", uge_id);
                                          let out4: Text = s1_cg_line(out3, text_concat(text_concat(text_concat(text_concat("  ", uge), " = icmp sge i64 "), a_val), ", 65"));
                                          let ule_id: Text = int_to_text(nt + 4);
                                          let ule: Text = text_concat("%t", ule_id);
                                          let out5: Text = s1_cg_line(out4, text_concat(text_concat(text_concat(text_concat("  ", ule), " = icmp sle i64 "), a_val), ", 90"));
                                          let up_id: Text = int_to_text(nt + 5);
                                          let up: Text = text_concat("%t", up_id);
                                          let out6: Text = s1_cg_line(out5, text_concat(text_concat(text_concat(text_concat("  ", up), " = and i1 "), uge), text_concat(", ", ule)));

                                          let lge_id: Text = int_to_text(nt + 6);
                                          let lge: Text = text_concat("%t", lge_id);
                                          let out7: Text = s1_cg_line(out6, text_concat(text_concat(text_concat(text_concat("  ", lge), " = icmp sge i64 "), a_val), ", 97"));
                                          let lle_id: Text = int_to_text(nt + 7);
                                          let lle: Text = text_concat("%t", lle_id);
                                          let out8: Text = s1_cg_line(out7, text_concat(text_concat(text_concat(text_concat("  ", lle), " = icmp sle i64 "), a_val), ", 122"));
                                          let low_id: Text = int_to_text(nt + 8);
                                          let low: Text = text_concat("%t", low_id);
                                          let out9: Text = s1_cg_line(out8, text_concat(text_concat(text_concat(text_concat("  ", low), " = and i1 "), lge), text_concat(", ", lle)));

                                          let alp_id: Text = int_to_text(nt + 9);
                                          let alp: Text = text_concat("%t", alp_id);
                                          let out10: Text = s1_cg_line(out9, text_concat(text_concat(text_concat(text_concat("  ", alp), " = or i1 "), up), text_concat(", ", low)));
                                          let outv_id: Text = int_to_text(nt + 10);
                                          let outv: Text = text_concat("%t", outv_id);
                                          let out11: Text = s1_cg_line(out10, text_concat(text_concat(text_concat(text_concat("  ", outv), " = or i1 "), dig), text_concat(", ", alp)));
                                          s1_cg_expr_ok(S1CgExprOut { text: out11; value: outv; ty: "i1"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Bool")); bb: bt; next_tmp: nt + 11; })
                                        } else {
                                          s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: byte_is_ascii_alnum expects (Int)"))
                                        }
                                      } else {
                                        s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: byte_is_ascii_alnum expects (Int)"))
                                      }
                                    } else {
                                      if fname == "byte_is_ascii_ident_start" {
                                        if argc == 1 {
                                          if a_ty == "i64" {
                                            let uge_id: Text = int_to_text(nt);
                                            let uge: Text = text_concat("%t", uge_id);
                                            let out1: Text = s1_cg_line(ot, text_concat(text_concat(text_concat(text_concat("  ", uge), " = icmp sge i64 "), a_val), ", 65"));
                                            let ule_id: Text = int_to_text(nt + 1);
                                            let ule: Text = text_concat("%t", ule_id);
                                            let out2: Text = s1_cg_line(out1, text_concat(text_concat(text_concat(text_concat("  ", ule), " = icmp sle i64 "), a_val), ", 90"));
                                            let up_id: Text = int_to_text(nt + 2);
                                            let up: Text = text_concat("%t", up_id);
                                            let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat(text_concat("  ", up), " = and i1 "), uge), text_concat(", ", ule)));

                                            let lge_id: Text = int_to_text(nt + 3);
                                            let lge: Text = text_concat("%t", lge_id);
                                            let out4: Text = s1_cg_line(out3, text_concat(text_concat(text_concat(text_concat("  ", lge), " = icmp sge i64 "), a_val), ", 97"));
                                            let lle_id: Text = int_to_text(nt + 4);
                                            let lle: Text = text_concat("%t", lle_id);
                                            let out5: Text = s1_cg_line(out4, text_concat(text_concat(text_concat(text_concat("  ", lle), " = icmp sle i64 "), a_val), ", 122"));
                                            let low_id: Text = int_to_text(nt + 5);
                                            let low: Text = text_concat("%t", low_id);
                                            let out6: Text = s1_cg_line(out5, text_concat(text_concat(text_concat(text_concat("  ", low), " = and i1 "), lge), text_concat(", ", lle)));

                                            let alp_id: Text = int_to_text(nt + 6);
                                            let alp: Text = text_concat("%t", alp_id);
                                            let out7: Text = s1_cg_line(out6, text_concat(text_concat(text_concat(text_concat("  ", alp), " = or i1 "), up), text_concat(", ", low)));
                                            let us_id: Text = int_to_text(nt + 7);
                                            let us: Text = text_concat("%t", us_id);
                                            let out8: Text = s1_cg_line(out7, text_concat(text_concat(text_concat(text_concat("  ", us), " = icmp eq i64 "), a_val), ", 95"));
                                            let outv_id: Text = int_to_text(nt + 8);
                                            let outv: Text = text_concat("%t", outv_id);
                                            let out9: Text = s1_cg_line(out8, text_concat(text_concat(text_concat(text_concat("  ", outv), " = or i1 "), alp), text_concat(", ", us)));
                                            s1_cg_expr_ok(S1CgExprOut { text: out9; value: outv; ty: "i1"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Bool")); bb: bt; next_tmp: nt + 9; })
                                          } else {
                                            s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: byte_is_ascii_ident_start expects (Int)"))
                                          }
                                        } else {
                                          s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: byte_is_ascii_ident_start expects (Int)"))
                                        }
                                      } else {
                                        if fname == "byte_is_ascii_ident_continue" {
                                          if argc == 1 {
                                            if a_ty == "i64" {
                                              let dge_id: Text = int_to_text(nt);
                                              let dge: Text = text_concat("%t", dge_id);
                                              let out1: Text = s1_cg_line(ot, text_concat(text_concat(text_concat(text_concat("  ", dge), " = icmp sge i64 "), a_val), ", 48"));
                                              let dle_id: Text = int_to_text(nt + 1);
                                              let dle: Text = text_concat("%t", dle_id);
                                              let out2: Text = s1_cg_line(out1, text_concat(text_concat(text_concat(text_concat("  ", dle), " = icmp sle i64 "), a_val), ", 57"));
                                              let dig_id: Text = int_to_text(nt + 2);
                                              let dig: Text = text_concat("%t", dig_id);
                                              let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat(text_concat("  ", dig), " = and i1 "), dge), text_concat(", ", dle)));

                                              let uge_id: Text = int_to_text(nt + 3);
                                              let uge: Text = text_concat("%t", uge_id);
                                              let out4: Text = s1_cg_line(out3, text_concat(text_concat(text_concat(text_concat("  ", uge), " = icmp sge i64 "), a_val), ", 65"));
                                              let ule_id: Text = int_to_text(nt + 4);
                                              let ule: Text = text_concat("%t", ule_id);
                                              let out5: Text = s1_cg_line(out4, text_concat(text_concat(text_concat(text_concat("  ", ule), " = icmp sle i64 "), a_val), ", 90"));
                                              let up_id: Text = int_to_text(nt + 5);
                                              let up: Text = text_concat("%t", up_id);
                                              let out6: Text = s1_cg_line(out5, text_concat(text_concat(text_concat(text_concat("  ", up), " = and i1 "), uge), text_concat(", ", ule)));

                                              let lge_id: Text = int_to_text(nt + 6);
                                              let lge: Text = text_concat("%t", lge_id);
                                              let out7: Text = s1_cg_line(out6, text_concat(text_concat(text_concat(text_concat("  ", lge), " = icmp sge i64 "), a_val), ", 97"));
                                              let lle_id: Text = int_to_text(nt + 7);
                                              let lle: Text = text_concat("%t", lle_id);
                                              let out8: Text = s1_cg_line(out7, text_concat(text_concat(text_concat(text_concat("  ", lle), " = icmp sle i64 "), a_val), ", 122"));
                                              let low_id: Text = int_to_text(nt + 8);
                                              let low: Text = text_concat("%t", low_id);
                                              let out9: Text = s1_cg_line(out8, text_concat(text_concat(text_concat(text_concat("  ", low), " = and i1 "), lge), text_concat(", ", lle)));

                                              let alp_id: Text = int_to_text(nt + 9);
                                              let alp: Text = text_concat("%t", alp_id);
                                              let out10: Text = s1_cg_line(out9, text_concat(text_concat(text_concat(text_concat("  ", alp), " = or i1 "), up), text_concat(", ", low)));
                                              let us_id: Text = int_to_text(nt + 10);
                                              let us: Text = text_concat("%t", us_id);
                                              let out11: Text = s1_cg_line(out10, text_concat(text_concat(text_concat(text_concat("  ", us), " = icmp eq i64 "), a_val), ", 95"));
                                              let is_id: Text = int_to_text(nt + 11);
                                              let is: Text = text_concat("%t", is_id);
                                              let out12: Text = s1_cg_line(out11, text_concat(text_concat(text_concat(text_concat("  ", is), " = or i1 "), alp), text_concat(", ", us)));
                                              let outv_id: Text = int_to_text(nt + 12);
                                              let outv: Text = text_concat("%t", outv_id);
                                              let out13: Text = s1_cg_line(out12, text_concat(text_concat(text_concat(text_concat("  ", outv), " = or i1 "), is), text_concat(", ", dig)));
                                              s1_cg_expr_ok(S1CgExprOut { text: out13; value: outv; ty: "i1"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Bool")); bb: bt; next_tmp: nt + 13; })
                                            } else {
                                              s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: byte_is_ascii_ident_continue expects (Int)"))
                                            }
                                          } else {
                                            s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: byte_is_ascii_ident_continue expects (Int)"))
                                          }
                                        } else {
                                          let arg_tys: List<Text> = s1_cg_reverse_text_list(arg_tys_rev);
                                          match s1_cg_lookup_fn_sig(fns, fname) {
                                            None => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: unknown function in v0 subset"));
                                            Some(sig) => {
                                              // Validate arity + argument LLVM types against the signature.
                                              let cur_a: List<Text> = arg_tys;
                                              let cur_p: List<Text> = sig.params_llvm;
                                              let done_sig: Bool = false;
                                              let ok_sig: Bool = true;
                                              while done_sig == false {
                                                match cur_p {
                                                  Nil => {
                                                    match cur_a {
                                                      Nil => { done_sig = true; 0 };
                                                      _ => { ok_sig = false; done_sig = true; 0 };
                                                    };
                                                    0
                                                  };
                                                  Cons(p0) => {
                                                    match cur_a {
                                                      Cons(a0) => {
                                                        if a0.head == p0.head {
                                                          cur_a = a0.tail;
                                                          cur_p = p0.tail;
                                                          0
                                                        } else {
                                                          ok_sig = false;
                                                          done_sig = true;
                                                          0
                                                        };
                                                        0
                                                      };
                                                      _ => { ok_sig = false; done_sig = true; 0 };
                                                    };
                                                    0
                                                  };
                                                }
                                              };

                                              if ok_sig == true {
                                                let tmp_id: Text = int_to_text(nt);
                                                let tmp: Text = text_concat("%t", tmp_id);
                                                let call0: Text = text_concat(text_concat(text_concat(text_concat("  ", tmp), " = call "), sig.ret_llvm), " @");
                                                let call_head: Text = text_concat(call0, fname);
                                                let inst: Text = text_concat(text_concat(call_head, "("), text_concat(at, ")"));
                                                let out2: Text = s1_cg_line(ot, inst);
                                                s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: sig.ret_llvm; s1_ty: s1_cg_s1_ty_some(sig.ret_s1); bb: bt; next_tmp: nt + 1; })
                                              } else {
                                                s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: call arg types mismatch in v0 subset"))
                                              }
                                            };
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                        }
                        }
                      }
                    }
                  }
                }
              }
            };
          }
            }
          }
          ;
          };
          out_call
        };
      }
    };
    If(i) => {
      let c_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(out, env, next_tmp, bb, items, strs, fns, i.cond);
      match c_r {
        Err(e1) => s1_cg_expr_err(e1);
        Ok(c0) => {
          if c0.ty == "i1" {
            match i.else_block {
              None => {
                // Statement-like if in expression position: execute then-branch, return 0.
                let then_id: Text = int_to_text(c0.next_tmp);
                let then_lbl: Text = text_concat("then", then_id);
                let join_id: Text = int_to_text(c0.next_tmp + 1);
                let join_lbl: Text = text_concat("join", join_id);
                let nt0: Int = c0.next_tmp + 2;

                let br1: Text =
                  text_concat(
                    text_concat("  br i1 ", c0.value),
                    text_concat(text_concat(", label %", then_lbl), text_concat(", label %", join_lbl))
                  );
                let out_br: Text = s1_cg_line(c0.text, br1);

                // then:
                let out_then_lbl: Text = s1_cg_line(out_br, text_concat(then_lbl, ":"));
                let tr: Result<S1CgBlockOut, S1Diagnostic> =
                  s1_cg_emit_stmt_list_min(out_then_lbl, env, nt0, then_lbl, items, strs, fns, i.then_block.stmts);
                match tr {
                  Err(e2) => s1_cg_expr_err(e2);
                  Ok(tb) => {
                    let tail_e: S1Expr =
                      match i.then_block.result {
                        None => IntLit("0");
                        Some(te) => te;
                      };
                    let tail_r: Result<S1CgExprOut, S1Diagnostic> =
                      s1_cg_emit_expr_min(tb.text, tb.env, tb.next_tmp, tb.bb, items, strs, fns, tail_e);
                    match tail_r {
                      Err(e3) => s1_cg_expr_err(e3);
                      Ok(tail0) => {
                        let out_then_end: Text = s1_cg_line(tail0.text, text_concat("  br label %", join_lbl));
                        let out_join_lbl: Text = s1_cg_line(out_then_end, text_concat(join_lbl, ":"));
                        s1_cg_expr_ok(S1CgExprOut { text: out_join_lbl; value: "0"; ty: "i64"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Int")); bb: join_lbl; next_tmp: tail0.next_tmp; })
                      };
                    }
                  };
                }
              };
              Some(else_b) => {
                // Default missing branch values to `0` to support statement-like control flow.
                let then_e: S1Expr =
                  match i.then_block.result {
                    None => IntLit("0");
                    Some(te) => te;
                  };
                let else_e: S1Expr =
                  match else_b.result {
                    None => IntLit("0");
                    Some(ee) => ee;
                  };

                // Allocate labels.
                let then_id: Text = int_to_text(c0.next_tmp);
                let then_lbl: Text = text_concat("then", then_id);
                let else_id: Text = int_to_text(c0.next_tmp + 1);
                let else_lbl: Text = text_concat("else", else_id);
                let join_id: Text = int_to_text(c0.next_tmp + 2);
                let join_lbl: Text = text_concat("join", join_id);
                let nt0: Int = c0.next_tmp + 3;

                let br1: Text =
                  text_concat(
                    text_concat("  br i1 ", c0.value),
                    text_concat(text_concat(", label %", then_lbl), text_concat(", label %", else_lbl))
                  );
                let out_br: Text = s1_cg_line(c0.text, br1);

                // then:
                let out_then_lbl: Text = s1_cg_line(out_br, text_concat(then_lbl, ":"));
                let tr: Result<S1CgBlockOut, S1Diagnostic> =
                  s1_cg_emit_stmt_list_min(out_then_lbl, env, nt0, then_lbl, items, strs, fns, i.then_block.stmts);
                match tr {
                  Err(e2) => s1_cg_expr_err(e2);
                  Ok(tb) => {
                    let t_r: Result<S1CgExprOut, S1Diagnostic> =
                      s1_cg_emit_expr_min(tb.text, tb.env, tb.next_tmp, tb.bb, items, strs, fns, then_e);
                    match t_r {
                      Err(e3) => s1_cg_expr_err(e3);
                      Ok(t0) => {
                        let out_then_end: Text = s1_cg_line(t0.text, text_concat("  br label %", join_lbl));

                        // else:
                        let out_else_lbl: Text = s1_cg_line(out_then_end, text_concat(else_lbl, ":"));
                        let er: Result<S1CgBlockOut, S1Diagnostic> =
                          s1_cg_emit_stmt_list_min(out_else_lbl, env, t0.next_tmp, else_lbl, items, strs, fns, else_b.stmts);
                        match er {
                          Err(e4) => s1_cg_expr_err(e4);
                          Ok(eb) => {
                            let e_r: Result<S1CgExprOut, S1Diagnostic> =
                              s1_cg_emit_expr_min(eb.text, eb.env, eb.next_tmp, eb.bb, items, strs, fns, else_e);
                            match e_r {
                              Err(e5) => s1_cg_expr_err(e5);
                              Ok(e0) => {
                                if e0.ty == t0.ty {
                                  let out_else_end: Text = s1_cg_line(e0.text, text_concat("  br label %", join_lbl));
                                  let out_join_lbl: Text = s1_cg_line(out_else_end, text_concat(join_lbl, ":"));
                                  let phi_id: Text = int_to_text(e0.next_tmp);
                                  let phi_tmp: Text = text_concat("%t", phi_id);
                                  let p1: Text = text_concat(text_concat(text_concat("  ", phi_tmp), " = phi "), text_concat(t0.ty, " "));
                                  let in1: Text = text_concat(text_concat("[ ", t0.value), text_concat(text_concat(", %", t0.bb), " ]"));
                                  let in2: Text = text_concat(text_concat("[ ", e0.value), text_concat(text_concat(", %", e0.bb), " ]"));
                                  let inst: Text = text_concat(text_concat(p1, in1), text_concat(", ", in2));
                                  let out_phi: Text = s1_cg_line(out_join_lbl, inst);

                                  if t0.ty == "i64" {
                                    s1_cg_expr_ok(S1CgExprOut { text: out_phi; value: phi_tmp; ty: "i64"; s1_ty: t0.s1_ty; bb: join_lbl; next_tmp: e0.next_tmp + 1; })
                                  } else {
                                    if t0.ty == "i1" {
                                      s1_cg_expr_ok(S1CgExprOut { text: out_phi; value: phi_tmp; ty: "i1"; s1_ty: t0.s1_ty; bb: join_lbl; next_tmp: e0.next_tmp + 1; })
                                    } else {
                                      if t0.ty == "i8*" {
                                        s1_cg_expr_ok(S1CgExprOut { text: out_phi; value: phi_tmp; ty: "i8*"; s1_ty: t0.s1_ty; bb: join_lbl; next_tmp: e0.next_tmp + 1; })
                                      } else {
                                        if t0.ty == "%Option*" {
                                          s1_cg_expr_ok(S1CgExprOut { text: out_phi; value: phi_tmp; ty: "%Option*"; s1_ty: t0.s1_ty; bb: join_lbl; next_tmp: e0.next_tmp + 1; })
                                        } else {
                                          if t0.ty == "%Result*" {
                                            s1_cg_expr_ok(S1CgExprOut { text: out_phi; value: phi_tmp; ty: "%Result*"; s1_ty: t0.s1_ty; bb: join_lbl; next_tmp: e0.next_tmp + 1; })
                                          } else {
                                            if t0.ty == "%List*" {
                                              s1_cg_expr_ok(S1CgExprOut { text: out_phi; value: phi_tmp; ty: "%List*"; s1_ty: t0.s1_ty; bb: join_lbl; next_tmp: e0.next_tmp + 1; })
                                            } else {
                                              s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: if branch type not supported in v0"))
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                } else {
                                  s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: if branches must return same type in v0"))
                                }
                              };
                            }
                          };
                        }
                      };
                    }
                  };
                }
              };
            }
          } else {
            s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: if condition must be Bool (i1)"))
          }
        };
      }
    };
    Block(b) => {
      match b.result {
        None => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: block has no value"));
        Some(e2) => {
          let br: Result<S1CgBlockOut, S1Diagnostic> = s1_cg_emit_stmt_list_min(out, env, next_tmp, bb, items, strs, fns, b.stmts);
          match br {
            Err(e3) => s1_cg_expr_err(e3);
            Ok(b0) => {
              // Block scope: use the extended env for the tail expression, but do not leak it to callers.
              let rr: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(b0.text, b0.env, b0.next_tmp, b0.bb, items, strs, fns, e2);
              match rr {
                Err(e4) => s1_cg_expr_err(e4);
                Ok(r0) => {
                  s1_cg_expr_ok(S1CgExprOut { text: r0.text; value: r0.value; ty: r0.ty; s1_ty: r0.s1_ty; bb: r0.bb; next_tmp: r0.next_tmp; })
                };
              }
            };
          }
        };
      }
    };
    Match(m) => {
      // v0.4: minimal enum match lowering for Option<Int> and Result<T, E>.
      // Current limitation: only supports exactly 2 arms.
      let scr_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(out, env, next_tmp, bb, items, strs, fns, m.scrutinee);
      match scr_r {
        Err(e0) => s1_cg_expr_err(e0);
        Ok(s0) => {
          match m.arms {
            Nil => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: match has no arms"));
            Cons(a0) => {
              match a0.tail {
                Nil => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: match must have 2 arms in v0.4"));
                Cons(a1) => {
                  match a1.tail {
                    Nil => {
                      let arm0: S1MatchArm = a0.head;
                      let arm1: S1MatchArm = a1.head;

                      // Determine enum kind + payload types from scrutinee's S1Type.
                      // v0.12+: also supports user-defined enums (lowered as `{ tag: i8, payload_word: i64 }` via `%Option` layout).
                      let enum_name: Text = "";
                      let ok_payload_s1: S1Type = s1_cg_s1_type_prim("Int");
                      let err_payload_s1: S1Type = s1_cg_s1_type_prim("Int");
                      let have_enum: Bool = false;
                      let generic_enum: Bool = false;
                      let scrut_s1: S1Type = s1_cg_s1_type_prim("Int");

                      match s0.s1_ty {
                        None => 0;
                        Some(st0) => {
                          scrut_s1 = st0;
                          if s1_cg_type_is_option(st0) == true {
                            enum_name = "Option";
                            match st0.args {
                              Cons(o0) => {
                                match o0.tail {
                                  Nil => { ok_payload_s1 = o0.head; have_enum = true; 0 };
                                  _ => 0;
                                };
                                0
                              };
                              _ => 0;
                            };
                            err_payload_s1 = s1_cg_s1_type_prim("Int");
                            0
                          } else {
                            if s1_cg_type_is_result(st0) == true {
                              enum_name = "Result";
                              // Extract Result<T, E> args.
                              match st0.args {
                                Cons(r0) => {
                                  match r0.tail {
                                    Cons(r1) => {
                                      match r1.tail {
                                        Nil => { ok_payload_s1 = r0.head; err_payload_s1 = r1.head; have_enum = true; 0 };
                                        _ => 0;
                                      };
                                      0
                                    };
                                    _ => 0;
                                  };
                                  0
                                };
                                _ => 0;
                              };
                              0
                            } else {
                              if s1_cg_type_is_list(st0) == true {
                                enum_name = "List";
                                match st0.args {
                                  Cons(l0) => {
                                    match l0.tail {
                                      Nil => { ok_payload_s1 = s1_cg_s1_type_list_cons(l0.head); have_enum = true; 0 };
                                      _ => 0;
                                    };
                                    0
                                  };
                                  _ => 0;
                                };
                                err_payload_s1 = s1_cg_s1_type_prim("Int");
                                0
                              } else {
                                // User-defined enum.
                                match s1_cg_path_single_name(st0.path) {
                                  None => 0;
                                  Some(enm) => {
                                    match s1_cg_lookup_enum(items, enm) {
                                      None => 0;
                                      Some(_e0) => { enum_name = enm; have_enum = true; generic_enum = true; 0 };
                                    };
                                    0
                                  };
                                };
                                0
                              };
                              0
                            };
                            0
                          };
                          0
                        };
                      };

                      if have_enum == false {
                        s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: match scrutinee must be an enum in v0.4"))
                      } else {
                        // For user enums, cast the opaque `i8*` pointer to `%Option*` for tag/payload GEP.
                        let scrut_ptr: Text = s0.value;
                        let scrut_text: Text = s0.text;
                        let scrut_next_tmp: Int = s0.next_tmp;
                        if generic_enum == true {
                          let cast_id: Text = int_to_text(scrut_next_tmp);
                          let cast: Text = text_concat("%t", cast_id);
                          scrut_text = s1_cg_line(scrut_text, text_concat(text_concat(text_concat(text_concat("  ", cast), " = bitcast i8* "), scrut_ptr), " to %Option*"));
                          scrut_ptr = cast;
                          scrut_next_tmp = scrut_next_tmp + 1;
                          0
                        } else { 0 };

                        let en_layout_name: Text = enum_name;
                        if generic_enum == true { en_layout_name = "Option"; 0 } else { 0 };

                        // Parse patterns.
                        let a0_wild: Bool = false;
                        let a0_vname: Text = "";
                        let a0_bind_kind: Text = "none"; // none | wild | bind
                        let a0_bind_name: Text = "";
                        match arm0.pat {
                          Wildcard => { a0_wild = true; 0 };
                          Path(p0) => {
                            match s1_cg_path_last_name(p0) {
                              None => 0;
                              Some(n0) => { a0_vname = n0; 0 };
                            };
                            0
                          };
                          Variant(vp0) => {
                            match s1_cg_path_last_name(vp0.path) {
                              None => 0;
                              Some(n0) => { a0_vname = n0; 0 };
                            };
                            match vp0.payload {
                              None => 0;
                              Some(pl0) => {
                                match pl0 {
                                  Bind(nm) => { a0_bind_kind = "bind"; a0_bind_name = nm; 0 };
                                  Wildcard => { a0_bind_kind = "wild"; 0 };
                                };
                                0
                              };
                            };
                            0
                          };
                        };

                        let a1_wild: Bool = false;
                        let a1_vname: Text = "";
                        let a1_bind_kind: Text = "none";
                        let a1_bind_name: Text = "";
                        match arm1.pat {
                          Wildcard => { a1_wild = true; 0 };
                          Path(p1) => {
                            match s1_cg_path_last_name(p1) {
                              None => 0;
                              Some(n1) => { a1_vname = n1; 0 };
                            };
                            0
                          };
                          Variant(vp1) => {
                            match s1_cg_path_last_name(vp1.path) {
                              None => 0;
                              Some(n1) => { a1_vname = n1; 0 };
                            };
                            match vp1.payload {
                              None => 0;
                              Some(pl1) => {
                                match pl1 {
                                  Bind(nm) => { a1_bind_kind = "bind"; a1_bind_name = nm; 0 };
                                  Wildcard => { a1_bind_kind = "wild"; 0 };
                                };
                                0
                              };
                            };
                            0
                          };
                        };

                        // Map variant names to tags.
                        let a0_has_tag: Bool = false;
                        let a0_tag: Text = "0";
                        if a0_wild == false {
                          if generic_enum == true {
                            match s1_cg_lookup_enum(items, enum_name) {
                              None => 0;
                              Some(e0) => {
                                match s1_cg_enum_variant_info_in_enum(e0, a0_vname) {
                                  None => 0;
                                  Some(info) => { a0_has_tag = true; a0_tag = int_to_text(info.tag); 0 };
                                };
                                0
                              };
                            };
                            0
                          } else {
                            if enum_name == "Option" {
                              if a0_vname == "Some" { a0_has_tag = true; a0_tag = "0"; 0 } else { 0 };
                              if a0_vname == "None" { a0_has_tag = true; a0_tag = "1"; 0 } else { 0 };
                              0
                            } else {
                              if enum_name == "Result" {
                                if a0_vname == "Ok" { a0_has_tag = true; a0_tag = "0"; 0 } else { 0 };
                                if a0_vname == "Err" { a0_has_tag = true; a0_tag = "1"; 0 } else { 0 };
                                0
                              } else {
                                // List
                                if a0_vname == "Nil" { a0_has_tag = true; a0_tag = "0"; 0 } else { 0 };
                                if a0_vname == "Cons" { a0_has_tag = true; a0_tag = "1"; 0 } else { 0 };
                                0
                              };
                              0
                            };
                            0
                          };
                          0
                        } else { 0 };

                        let a1_has_tag: Bool = false;
                        let a1_tag: Text = "0";
                        if a1_wild == false {
                          if generic_enum == true {
                            match s1_cg_lookup_enum(items, enum_name) {
                              None => 0;
                              Some(e0) => {
                                match s1_cg_enum_variant_info_in_enum(e0, a1_vname) {
                                  None => 0;
                                  Some(info) => { a1_has_tag = true; a1_tag = int_to_text(info.tag); 0 };
                                };
                                0
                              };
                            };
                            0
                          } else {
                            if enum_name == "Option" {
                              if a1_vname == "Some" { a1_has_tag = true; a1_tag = "0"; 0 } else { 0 };
                              if a1_vname == "None" { a1_has_tag = true; a1_tag = "1"; 0 } else { 0 };
                              0
                            } else {
                              if enum_name == "Result" {
                                if a1_vname == "Ok" { a1_has_tag = true; a1_tag = "0"; 0 } else { 0 };
                                if a1_vname == "Err" { a1_has_tag = true; a1_tag = "1"; 0 } else { 0 };
                                0
                              } else {
                                // List
                                if a1_vname == "Nil" { a1_has_tag = true; a1_tag = "0"; 0 } else { 0 };
                                if a1_vname == "Cons" { a1_has_tag = true; a1_tag = "1"; 0 } else { 0 };
                                0
                              };
                              0
                            };
                            0
                          };
                          0
                        } else { 0 };

                        if a0_wild == false {
                          if a0_has_tag == false {
                            s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: unsupported match arm pattern in v0.4"))
                          } else {
                            if a1_wild == false {
                              if a1_has_tag == false {
                                s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: unsupported match arm pattern in v0.4"))
                              } else {
                                // ok
                                let arm0_lbl: Text = text_concat("match_a0", int_to_text(scrut_next_tmp));
                                let arm1_lbl: Text = text_concat("match_a1", int_to_text(scrut_next_tmp + 1));
                                let join_lbl: Text = text_concat("match_join", int_to_text(scrut_next_tmp + 2));
                                let nt0: Int = scrut_next_tmp + 3;

                                let en_ty: Text = text_concat("%", en_layout_name);
                                let en_ptr_ty: Text = text_concat(en_ty, "*");

                                // Load tag.
                                let tagp_id: Text = int_to_text(nt0);
                                let tagp: Text = text_concat("%t", tagp_id);
                                let out1: Text = s1_cg_line(scrut_text, text_concat(text_concat(text_concat("  ", tagp), " = getelementptr inbounds "), text_concat(text_concat(en_ty, ", "), text_concat(en_ptr_ty, text_concat(" ", text_concat(scrut_ptr, ", i32 0, i32 0"))))));
                                let tag8_id: Text = int_to_text(nt0 + 1);
                                let tag8: Text = text_concat("%t", tag8_id);
                                let out2: Text = s1_cg_line(out1, text_concat(text_concat(text_concat("  ", tag8), " = load i8, i8* "), tagp));
                                let is_a0_id: Text = int_to_text(nt0 + 2);
                                let is_a0: Text = text_concat("%t", is_a0_id);
                                let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat(text_concat("  ", is_a0), " = icmp eq i8 "), tag8), text_concat(", ", a0_tag)));
                                let br0: Text = text_concat(
                                  text_concat(text_concat("  br i1 ", is_a0), text_concat(", label %", arm0_lbl)),
                                  text_concat(", label %", arm1_lbl)
                                );
                                let out4: Text = s1_cg_line(out3, br0);

                                // arm0:
                                let out5: Text = s1_cg_line(out4, text_concat(arm0_lbl, ":"));
                                let env0: List<S1CgEnvBind> = env;
                                let ot0: Text = out5;
                                let nt_arm0: Int = nt0 + 3;
                                let env_arm0: List<S1CgEnvBind> = env0;
                                let ot_arm0: Text = ot0;
                                let nt0a: Int = nt_arm0;

                                if a0_bind_kind == "bind" {
                                  // Load payload word.
                                  let payp_id: Text = int_to_text(nt0a);
                                  let payp: Text = text_concat("%t", payp_id);
                                  ot_arm0 = s1_cg_line(ot_arm0, text_concat(text_concat(text_concat("  ", payp), " = getelementptr inbounds "), text_concat(text_concat(en_ty, ", "), text_concat(en_ptr_ty, text_concat(" ", text_concat(scrut_ptr, ", i32 0, i32 1"))))));
                                  let payw_id: Text = int_to_text(nt0a + 1);
                                  let payw: Text = text_concat("%t", payw_id);
                                  ot_arm0 = s1_cg_line(ot_arm0, text_concat(text_concat(text_concat("  ", payw), " = load i64, i64* "), payp));

                                  // Determine binder LLVM type.
                                  let bind_payload_s1: S1Type = ok_payload_s1;
                                  if enum_name == "Result" {
                                    if a0_tag == "1" { bind_payload_s1 = err_payload_s1; 0 } else { 0 };
                                    0
                                  } else { 0 };
                                  if generic_enum == true {
                                    match s1_cg_lookup_enum(items, enum_name) {
                                      None => 0;
                                      Some(e0) => {
                                        let gen_names: List<Text> = s1_cg_collect_generic_names(e0.generics);
                                        let subst: List<S1Subst> = s1_cg_build_subst(gen_names, scrut_s1.args);
                                        match s1_cg_enum_variant_info_in_enum(e0, a0_vname) {
                                          None => 0;
                                          Some(info) => {
                                            match info.payload_ty {
                                              None => 0;
                                              Some(pt0) => { bind_payload_s1 = s1_cg_apply_subst(pt0, gen_names, subst); 0 };
                                            };
                                            0
                                          };
                                        };
                                        0
                                      };
                                    };
                                    0
                                  } else { 0 };

                                  let bind_s1_ty: S1Type = bind_payload_s1;
                                  let bind_llvm_ty: Text = "i64";
                                  match s1_cg_llvm_ty_of_s1(bind_payload_s1) {
                                    None => 0;
                                    Some(t0) => { bind_llvm_ty = t0; 0 };
                                  };

                                  let bind_val: Text = payw;
                                  let nt_adj: Int = nt0a;
                                  if bind_llvm_ty == "i1" {
                                    let tr_id: Text = int_to_text(nt0a + 2);
                                    let tr: Text = text_concat("%t", tr_id);
                                    ot_arm0 = s1_cg_line(ot_arm0, text_concat(text_concat(text_concat(text_concat("  ", tr), " = trunc i64 "), payw), " to i1"));
                                    bind_val = tr;
                                    nt_adj = nt0a + 1;
                                    0
                                  } else { 0 };
                                  if bind_llvm_ty != "i64" {
                                    if bind_llvm_ty != "i1" {
                                      let cast_id: Text = int_to_text(nt0a + 2);
                                      let cast: Text = text_concat("%t", cast_id);
                                      ot_arm0 = s1_cg_line(ot_arm0, text_concat(text_concat(text_concat(text_concat("  ", cast), " = inttoptr i64 "), payw), text_concat(" to ", bind_llvm_ty)));
                                      bind_val = cast;
                                      nt_adj = nt0a + 1;
                                      0
                                    } else { 0 };
                                    0
                                  } else { 0 };

                                  let slot_id: Text = int_to_text(nt_adj + 2);
                                  let slot: Text = text_concat("%t", slot_id);
                                  ot_arm0 = s1_cg_line(ot_arm0, text_concat(text_concat(text_concat("  ", slot), " = alloca "), bind_llvm_ty));
                                  ot_arm0 = s1_cg_line(ot_arm0, text_concat(text_concat(text_concat("  store ", bind_llvm_ty), text_concat(" ", bind_val)), text_concat(text_concat(", ", bind_llvm_ty), text_concat("* ", slot))));
                                  let bind0: S1CgEnvBind = S1CgEnvBind { name: a0_bind_name; llvm: slot; ty: bind_llvm_ty; s1_ty: bind_s1_ty; };
                                  env_arm0 = Cons(ListCons<S1CgEnvBind> { head: bind0; tail: env_arm0; });
                                  nt0a = nt_adj + 3;
                                  0
                                } else { 0 };

                          let e0_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(ot_arm0, env_arm0, nt0a, arm0_lbl, items, strs, fns, arm0.value);
                                match e0_r {
                                  Err(ea0) => s1_cg_expr_err(ea0);
                                  Ok(v0) => {
                                    let out_arm0_end: Text = s1_cg_line(v0.text, text_concat("  br label %", join_lbl));

                                    // arm1:
                                    let out6: Text = s1_cg_line(out_arm0_end, text_concat(arm1_lbl, ":"));
                                    let nt1a: Int = v0.next_tmp;
                                    let env_arm1: List<S1CgEnvBind> = env;
                                    let ot_arm1: Text = out6;
                                    let nt1: Int = nt1a;

                                    if a1_bind_kind == "bind" {
                                      let payp_id: Text = int_to_text(nt1);
                                      let payp: Text = text_concat("%t", payp_id);
                                      ot_arm1 = s1_cg_line(ot_arm1, text_concat(text_concat(text_concat("  ", payp), " = getelementptr inbounds "), text_concat(text_concat(en_ty, ", "), text_concat(en_ptr_ty, text_concat(" ", text_concat(scrut_ptr, ", i32 0, i32 1"))))));
                                      let payw_id: Text = int_to_text(nt1 + 1);
                                      let payw: Text = text_concat("%t", payw_id);
                                      ot_arm1 = s1_cg_line(ot_arm1, text_concat(text_concat(text_concat("  ", payw), " = load i64, i64* "), payp));

                                      let bind_payload_s1: S1Type = ok_payload_s1;
                                      if enum_name == "Result" {
                                        if a1_tag == "1" { bind_payload_s1 = err_payload_s1; 0 } else { 0 };
                                        0
                                      } else { 0 };
                                      if generic_enum == true {
                                        match s1_cg_lookup_enum(items, enum_name) {
                                          None => 0;
                                          Some(e0) => {
                                            let gen_names: List<Text> = s1_cg_collect_generic_names(e0.generics);
                                            let subst: List<S1Subst> = s1_cg_build_subst(gen_names, scrut_s1.args);
                                            match s1_cg_enum_variant_info_in_enum(e0, a1_vname) {
                                              None => 0;
                                              Some(info) => {
                                                match info.payload_ty {
                                                  None => 0;
                                                  Some(pt0) => { bind_payload_s1 = s1_cg_apply_subst(pt0, gen_names, subst); 0 };
                                                };
                                                0
                                              };
                                            };
                                            0
                                          };
                                        };
                                        0
                                      } else { 0 };

                                      let bind_s1_ty: S1Type = bind_payload_s1;
                                      let bind_llvm_ty: Text = "i64";
                                      match s1_cg_llvm_ty_of_s1(bind_payload_s1) {
                                        None => 0;
                                        Some(t0) => { bind_llvm_ty = t0; 0 };
                                      };

                                      let bind_val: Text = payw;
                                      let nt_adj: Int = nt1;
                                      if bind_llvm_ty == "i1" {
                                        let tr_id: Text = int_to_text(nt1 + 2);
                                        let tr: Text = text_concat("%t", tr_id);
                                        ot_arm1 = s1_cg_line(ot_arm1, text_concat(text_concat(text_concat(text_concat("  ", tr), " = trunc i64 "), payw), " to i1"));
                                        bind_val = tr;
                                        nt_adj = nt1 + 1;
                                        0
                                      } else { 0 };
                                      if bind_llvm_ty != "i64" {
                                        if bind_llvm_ty != "i1" {
                                          let cast_id: Text = int_to_text(nt1 + 2);
                                          let cast: Text = text_concat("%t", cast_id);
                                          ot_arm1 = s1_cg_line(ot_arm1, text_concat(text_concat(text_concat(text_concat("  ", cast), " = inttoptr i64 "), payw), text_concat(" to ", bind_llvm_ty)));
                                          bind_val = cast;
                                          nt_adj = nt1 + 1;
                                          0
                                        } else { 0 };
                                        0
                                      } else { 0 };

                                      let slot_id: Text = int_to_text(nt_adj + 2);
                                      let slot: Text = text_concat("%t", slot_id);
                                      ot_arm1 = s1_cg_line(ot_arm1, text_concat(text_concat(text_concat("  ", slot), " = alloca "), bind_llvm_ty));
                                      ot_arm1 = s1_cg_line(ot_arm1, text_concat(text_concat(text_concat("  store ", bind_llvm_ty), text_concat(" ", bind_val)), text_concat(text_concat(", ", bind_llvm_ty), text_concat("* ", slot))));
                                      let bind1: S1CgEnvBind = S1CgEnvBind { name: a1_bind_name; llvm: slot; ty: bind_llvm_ty; s1_ty: bind_s1_ty; };
                                      env_arm1 = Cons(ListCons<S1CgEnvBind> { head: bind1; tail: env_arm1; });
                                      nt1 = nt_adj + 3;
                                      0
                                    } else { 0 };

                                    let e1_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(ot_arm1, env_arm1, nt1, arm1_lbl, items, strs, fns, arm1.value);
                                    match e1_r {
                                      Err(ea1) => s1_cg_expr_err(ea1);
                                      Ok(v1) => {
                                        if v1.ty == v0.ty {
                                          let out_arm1_end: Text = s1_cg_line(v1.text, text_concat("  br label %", join_lbl));
                                          let out_join: Text = s1_cg_line(out_arm1_end, text_concat(join_lbl, ":"));
                                          let phi_id: Text = int_to_text(v1.next_tmp);
                                          let phi: Text = text_concat("%t", phi_id);
                                          if v0.ty == "i64" {
                                            let p1: Text = text_concat(text_concat(text_concat("  ", phi), " = phi i64 "), "");
                                            let in0: Text = text_concat(text_concat("[ ", v0.value), text_concat(text_concat(", %", v0.bb), " ]"));
                                            let in1: Text = text_concat(text_concat("[ ", v1.value), text_concat(text_concat(", %", v1.bb), " ]"));
                                            let inst: Text = text_concat(text_concat(p1, in0), text_concat(", ", in1));
                                            let out_phi: Text = s1_cg_line(out_join, inst);
                                            s1_cg_expr_ok(S1CgExprOut { text: out_phi; value: phi; ty: "i64"; s1_ty: v0.s1_ty; bb: join_lbl; next_tmp: v1.next_tmp + 1; })
                                          } else {
                                            if v0.ty == "i1" {
                                              let p1: Text = text_concat(text_concat(text_concat("  ", phi), " = phi i1 "), "");
                                              let in0: Text = text_concat(text_concat("[ ", v0.value), text_concat(text_concat(", %", v0.bb), " ]"));
                                              let in1: Text = text_concat(text_concat("[ ", v1.value), text_concat(text_concat(", %", v1.bb), " ]"));
                                              let inst: Text = text_concat(text_concat(p1, in0), text_concat(", ", in1));
                                              let out_phi: Text = s1_cg_line(out_join, inst);
                                              s1_cg_expr_ok(S1CgExprOut { text: out_phi; value: phi; ty: "i1"; s1_ty: v0.s1_ty; bb: join_lbl; next_tmp: v1.next_tmp + 1; })
                                            } else {
                                              if v0.ty == "i8*" {
                                                let p1: Text = text_concat(text_concat(text_concat("  ", phi), " = phi i8* "), "");
                                                let in0: Text = text_concat(text_concat("[ ", v0.value), text_concat(text_concat(", %", v0.bb), " ]"));
                                                let in1: Text = text_concat(text_concat("[ ", v1.value), text_concat(text_concat(", %", v1.bb), " ]"));
                                                let inst: Text = text_concat(text_concat(p1, in0), text_concat(", ", in1));
                                                let out_phi: Text = s1_cg_line(out_join, inst);
                                                s1_cg_expr_ok(S1CgExprOut { text: out_phi; value: phi; ty: "i8*"; s1_ty: v0.s1_ty; bb: join_lbl; next_tmp: v1.next_tmp + 1; })
                                              } else {
                                                if v0.ty == "%Option*" {
                                                  let p1: Text = text_concat(text_concat(text_concat("  ", phi), " = phi %Option* "), "");
                                                  let in0: Text = text_concat(text_concat("[ ", v0.value), text_concat(text_concat(", %", v0.bb), " ]"));
                                                  let in1: Text = text_concat(text_concat("[ ", v1.value), text_concat(text_concat(", %", v1.bb), " ]"));
                                                  let inst: Text = text_concat(text_concat(p1, in0), text_concat(", ", in1));
                                                  let out_phi: Text = s1_cg_line(out_join, inst);
                                                  s1_cg_expr_ok(S1CgExprOut { text: out_phi; value: phi; ty: "%Option*"; s1_ty: v0.s1_ty; bb: join_lbl; next_tmp: v1.next_tmp + 1; })
                                                } else {
                                                  if v0.ty == "%Result*" {
                                                    let p1: Text = text_concat(text_concat(text_concat("  ", phi), " = phi %Result* "), "");
                                                    let in0: Text = text_concat(text_concat("[ ", v0.value), text_concat(text_concat(", %", v0.bb), " ]"));
                                                    let in1: Text = text_concat(text_concat("[ ", v1.value), text_concat(text_concat(", %", v1.bb), " ]"));
                                                    let inst: Text = text_concat(text_concat(p1, in0), text_concat(", ", in1));
                                                    let out_phi: Text = s1_cg_line(out_join, inst);
                                                    s1_cg_expr_ok(S1CgExprOut { text: out_phi; value: phi; ty: "%Result*"; s1_ty: v0.s1_ty; bb: join_lbl; next_tmp: v1.next_tmp + 1; })
                                                  } else {
                                                    if v0.ty == "%List*" {
                                                      let p1: Text = text_concat(text_concat(text_concat("  ", phi), " = phi %List* "), "");
                                                      let in0: Text = text_concat(text_concat("[ ", v0.value), text_concat(text_concat(", %", v0.bb), " ]"));
                                                      let in1: Text = text_concat(text_concat("[ ", v1.value), text_concat(text_concat(", %", v1.bb), " ]"));
                                                      let inst: Text = text_concat(text_concat(p1, in0), text_concat(", ", in1));
                                                      let out_phi: Text = s1_cg_line(out_join, inst);
                                                      s1_cg_expr_ok(S1CgExprOut { text: out_phi; value: phi; ty: "%List*"; s1_ty: v0.s1_ty; bb: join_lbl; next_tmp: v1.next_tmp + 1; })
                                                    } else {
                                                      s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: match result type not supported in v0.4"))
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        } else {
                                          s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: match arms must return same type in v0.4"))
                                        }
                                      };
                                    }
                                  };
                                }
                              }
                            } else {
                              // a1 is wildcard, still ok.
                              let arm0_lbl: Text = text_concat("match_a0", int_to_text(scrut_next_tmp));
                              let arm1_lbl: Text = text_concat("match_a1", int_to_text(scrut_next_tmp + 1));
                              let join_lbl: Text = text_concat("match_join", int_to_text(scrut_next_tmp + 2));
                              let nt0: Int = scrut_next_tmp + 3;

                              let en_ty: Text = text_concat("%", en_layout_name);
                              let en_ptr_ty: Text = text_concat(en_ty, "*");

                              let tagp_id: Text = int_to_text(nt0);
                              let tagp: Text = text_concat("%t", tagp_id);
                              let out1: Text = s1_cg_line(scrut_text, text_concat(text_concat(text_concat("  ", tagp), " = getelementptr inbounds "), text_concat(text_concat(en_ty, ", "), text_concat(en_ptr_ty, text_concat(" ", text_concat(scrut_ptr, ", i32 0, i32 0"))))));
                              let tag8_id: Text = int_to_text(nt0 + 1);
                              let tag8: Text = text_concat("%t", tag8_id);
                              let out2: Text = s1_cg_line(out1, text_concat(text_concat(text_concat("  ", tag8), " = load i8, i8* "), tagp));
                              let is_a0_id: Text = int_to_text(nt0 + 2);
                              let is_a0: Text = text_concat("%t", is_a0_id);
                              let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat(text_concat("  ", is_a0), " = icmp eq i8 "), tag8), text_concat(", ", a0_tag)));
                              let br0: Text = text_concat(
                                text_concat(text_concat("  br i1 ", is_a0), text_concat(", label %", arm0_lbl)),
                                text_concat(", label %", arm1_lbl)
                              );
                              let out4: Text = s1_cg_line(out3, br0);

                              let out5: Text = s1_cg_line(out4, text_concat(arm0_lbl, ":"));
                              let env_arm0: List<S1CgEnvBind> = env;
                              let ot_arm0: Text = out5;
                              let nt0a: Int = nt0 + 3;

                              if a0_bind_kind == "bind" {
                                // Load payload word.
                                let payp_id: Text = int_to_text(nt0a);
                                let payp: Text = text_concat("%t", payp_id);
                                ot_arm0 = s1_cg_line(ot_arm0, text_concat(text_concat(text_concat("  ", payp), " = getelementptr inbounds "), text_concat(text_concat(en_ty, ", "), text_concat(en_ptr_ty, text_concat(" ", text_concat(scrut_ptr, ", i32 0, i32 1"))))));
                                let payw_id: Text = int_to_text(nt0a + 1);
                                let payw: Text = text_concat("%t", payw_id);
                                ot_arm0 = s1_cg_line(ot_arm0, text_concat(text_concat(text_concat("  ", payw), " = load i64, i64* "), payp));

                                // Determine binder LLVM type.
                                let bind_payload_s1: S1Type = ok_payload_s1;
                                if enum_name == "Result" {
                                  if a0_tag == "1" { bind_payload_s1 = err_payload_s1; 0 } else { 0 };
                                  0
                                } else { 0 };
                                if generic_enum == true {
                                  match s1_cg_lookup_enum(items, enum_name) {
                                    None => 0;
                                    Some(e0) => {
                                      let gen_names: List<Text> = s1_cg_collect_generic_names(e0.generics);
                                      let subst: List<S1Subst> = s1_cg_build_subst(gen_names, scrut_s1.args);
                                      match s1_cg_enum_variant_info_in_enum(e0, a0_vname) {
                                        None => 0;
                                        Some(info) => {
                                          match info.payload_ty {
                                            None => 0;
                                            Some(pt0) => { bind_payload_s1 = s1_cg_apply_subst(pt0, gen_names, subst); 0 };
                                          };
                                          0
                                        };
                                      };
                                      0
                                    };
                                  };
                                  0
                                } else { 0 };

                                let bind_s1_ty: S1Type = bind_payload_s1;
                                let bind_llvm_ty: Text = "i64";
                                match s1_cg_llvm_ty_of_s1(bind_payload_s1) {
                                  None => 0;
                                  Some(t0) => { bind_llvm_ty = t0; 0 };
                                };

                                let bind_val: Text = payw;
                                let nt_adj: Int = nt0a;
                                if bind_llvm_ty == "i1" {
                                  let tr_id: Text = int_to_text(nt0a + 2);
                                  let tr: Text = text_concat("%t", tr_id);
                                  ot_arm0 = s1_cg_line(ot_arm0, text_concat(text_concat(text_concat(text_concat("  ", tr), " = trunc i64 "), payw), " to i1"));
                                  bind_val = tr;
                                  nt_adj = nt0a + 1;
                                  0
                                } else { 0 };
                                if bind_llvm_ty != "i64" {
                                  if bind_llvm_ty != "i1" {
                                    let cast_id: Text = int_to_text(nt0a + 2);
                                    let cast: Text = text_concat("%t", cast_id);
                                    ot_arm0 = s1_cg_line(ot_arm0, text_concat(text_concat(text_concat(text_concat("  ", cast), " = inttoptr i64 "), payw), text_concat(" to ", bind_llvm_ty)));
                                    bind_val = cast;
                                    nt_adj = nt0a + 1;
                                    0
                                  } else { 0 };
                                  0
                                } else { 0 };

                                let slot_id: Text = int_to_text(nt_adj + 2);
                                let slot: Text = text_concat("%t", slot_id);
                                ot_arm0 = s1_cg_line(ot_arm0, text_concat(text_concat(text_concat("  ", slot), " = alloca "), bind_llvm_ty));
                                ot_arm0 = s1_cg_line(ot_arm0, text_concat(text_concat(text_concat("  store ", bind_llvm_ty), text_concat(" ", bind_val)), text_concat(text_concat(", ", bind_llvm_ty), text_concat("* ", slot))));
                                let bind0: S1CgEnvBind = S1CgEnvBind { name: a0_bind_name; llvm: slot; ty: bind_llvm_ty; s1_ty: bind_s1_ty; };
                                env_arm0 = Cons(ListCons<S1CgEnvBind> { head: bind0; tail: env_arm0; });
                                nt0a = nt_adj + 3;
                                0
                              } else { 0 };

                              let e0_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(ot_arm0, env_arm0, nt0a, arm0_lbl, items, strs, fns, arm0.value);
                              match e0_r {
                                Err(ea0) => s1_cg_expr_err(ea0);
                                Ok(v0) => {
                                  let out_arm0_end: Text = s1_cg_line(v0.text, text_concat("  br label %", join_lbl));
                                  let out6: Text = s1_cg_line(out_arm0_end, text_concat(arm1_lbl, ":"));
                                  let e1_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(out6, env, v0.next_tmp, arm1_lbl, items, strs, fns, arm1.value);
                                  match e1_r {
                                    Err(ea1) => s1_cg_expr_err(ea1);
                                    Ok(v1) => {
                                      if v1.ty == v0.ty {
                                        let out_arm1_end: Text = s1_cg_line(v1.text, text_concat("  br label %", join_lbl));
                                        let out_join: Text = s1_cg_line(out_arm1_end, text_concat(join_lbl, ":"));
                                        let phi_id: Text = int_to_text(v1.next_tmp);
                                        let phi: Text = text_concat("%t", phi_id);
                                        if v0.ty == "i64" {
                                          let p1: Text = text_concat(text_concat(text_concat("  ", phi), " = phi i64 "), "");
                                          let in0: Text = text_concat(text_concat("[ ", v0.value), text_concat(text_concat(", %", v0.bb), " ]"));
                                          let in1: Text = text_concat(text_concat("[ ", v1.value), text_concat(text_concat(", %", v1.bb), " ]"));
                                          let inst: Text = text_concat(text_concat(p1, in0), text_concat(", ", in1));
                                          let out_phi: Text = s1_cg_line(out_join, inst);
                                          s1_cg_expr_ok(S1CgExprOut { text: out_phi; value: phi; ty: "i64"; s1_ty: v0.s1_ty; bb: join_lbl; next_tmp: v1.next_tmp + 1; })
                                        } else {
                                          if v0.ty == "i1" {
                                            let p1: Text = text_concat(text_concat(text_concat("  ", phi), " = phi i1 "), "");
                                            let in0: Text = text_concat(text_concat("[ ", v0.value), text_concat(text_concat(", %", v0.bb), " ]"));
                                            let in1: Text = text_concat(text_concat("[ ", v1.value), text_concat(text_concat(", %", v1.bb), " ]"));
                                            let inst: Text = text_concat(text_concat(p1, in0), text_concat(", ", in1));
                                            let out_phi: Text = s1_cg_line(out_join, inst);
                                            s1_cg_expr_ok(S1CgExprOut { text: out_phi; value: phi; ty: "i1"; s1_ty: v0.s1_ty; bb: join_lbl; next_tmp: v1.next_tmp + 1; })
                                          } else {
                                            if v0.ty == "i8*" {
                                              let p1: Text = text_concat(text_concat(text_concat("  ", phi), " = phi i8* "), "");
                                              let in0: Text = text_concat(text_concat("[ ", v0.value), text_concat(text_concat(", %", v0.bb), " ]"));
                                              let in1: Text = text_concat(text_concat("[ ", v1.value), text_concat(text_concat(", %", v1.bb), " ]"));
                                              let inst: Text = text_concat(text_concat(p1, in0), text_concat(", ", in1));
                                              let out_phi: Text = s1_cg_line(out_join, inst);
                                              s1_cg_expr_ok(S1CgExprOut { text: out_phi; value: phi; ty: "i8*"; s1_ty: v0.s1_ty; bb: join_lbl; next_tmp: v1.next_tmp + 1; })
                                            } else {
                                              if v0.ty == "%Option*" {
                                                let p1: Text = text_concat(text_concat(text_concat("  ", phi), " = phi %Option* "), "");
                                                let in0: Text = text_concat(text_concat("[ ", v0.value), text_concat(text_concat(", %", v0.bb), " ]"));
                                                let in1: Text = text_concat(text_concat("[ ", v1.value), text_concat(text_concat(", %", v1.bb), " ]"));
                                                let inst: Text = text_concat(text_concat(p1, in0), text_concat(", ", in1));
                                                let out_phi: Text = s1_cg_line(out_join, inst);
                                                s1_cg_expr_ok(S1CgExprOut { text: out_phi; value: phi; ty: "%Option*"; s1_ty: v0.s1_ty; bb: join_lbl; next_tmp: v1.next_tmp + 1; })
                                              } else {
                                                if v0.ty == "%Result*" {
                                                  let p1: Text = text_concat(text_concat(text_concat("  ", phi), " = phi %Result* "), "");
                                                  let in0: Text = text_concat(text_concat("[ ", v0.value), text_concat(text_concat(", %", v0.bb), " ]"));
                                                  let in1: Text = text_concat(text_concat("[ ", v1.value), text_concat(text_concat(", %", v1.bb), " ]"));
                                                  let inst: Text = text_concat(text_concat(p1, in0), text_concat(", ", in1));
                                                  let out_phi: Text = s1_cg_line(out_join, inst);
                                                  s1_cg_expr_ok(S1CgExprOut { text: out_phi; value: phi; ty: "%Result*"; s1_ty: v0.s1_ty; bb: join_lbl; next_tmp: v1.next_tmp + 1; })
                                                } else {
                                                  if v0.ty == "%List*" {
                                                    let p1: Text = text_concat(text_concat(text_concat("  ", phi), " = phi %List* "), "");
                                                    let in0: Text = text_concat(text_concat("[ ", v0.value), text_concat(text_concat(", %", v0.bb), " ]"));
                                                    let in1: Text = text_concat(text_concat("[ ", v1.value), text_concat(text_concat(", %", v1.bb), " ]"));
                                                    let inst: Text = text_concat(text_concat(p1, in0), text_concat(", ", in1));
                                                    let out_phi: Text = s1_cg_line(out_join, inst);
                                                    s1_cg_expr_ok(S1CgExprOut { text: out_phi; value: phi; ty: "%List*"; s1_ty: v0.s1_ty; bb: join_lbl; next_tmp: v1.next_tmp + 1; })
                                                  } else {
                                                    s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: match result type not supported in v0.4"))
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      } else {
                                        s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: match arms must return same type in v0.4"))
                                      }
                                    };
                                  }
                                };
                              }
                            }
                          }
                        } else {
                          // First arm wildcard: just emit arm0.
                          s1_cg_emit_expr_min(scrut_text, env, scrut_next_tmp, bb, items, strs, fns, arm0.value)
                        }
                      }
                    };
                    Cons(_a2) => {
                      // Desugar N-arm match into nested 2-arm matches (v0.12+).
                      // Evaluate scrutinee once (already in `s0`), bind it to a temp, then build:
                      //   match scrut { arm0 => ...; _ => match scrut { arm1 => ...; ... } }
                      let scrut_name: Text = text_concat("__match_scrut", int_to_text(s0.next_tmp));

                      let slot_id: Text = int_to_text(s0.next_tmp);
                      let slot: Text = text_concat("%t", slot_id);
                      let out1: Text = s1_cg_line(s0.text, text_concat(text_concat(text_concat("  ", slot), " = alloca "), s0.ty));
                      let st_head: Text = text_concat(text_concat("  store ", s0.ty), text_concat(" ", s0.value));
                      let st_tail: Text = text_concat(text_concat(", ", s0.ty), text_concat("* ", slot));
                      let out2: Text = s1_cg_line(out1, text_concat(st_head, st_tail));

                      let scrut_s1_ty: S1Type = s1_cg_s1_type_prim("Int");
                      match s0.s1_ty { None => 0; Some(st0) => { scrut_s1_ty = st0; 0 }; };
                      let bind: S1CgEnvBind = S1CgEnvBind { name: scrut_name; llvm: slot; ty: s0.ty; s1_ty: scrut_s1_ty; };
                      let env2: List<S1CgEnvBind> = Cons(ListCons<S1CgEnvBind> { head: bind; tail: env; });

                      let segs_nil: List<Text> = Nil;
                      let segs: List<Text> = Cons(ListCons<Text> { head: scrut_name; tail: segs_nil; });
                      let sp: S1Path = S1Path { segments: segs; };
                      let scrut_expr: S1Expr = S1Expr.Path(sp);

                      let nested_expr: S1Expr = S1Expr.Match(S1Match { scrutinee: scrut_expr; arms: a0.tail; });
                      let default_arm: S1MatchArm = S1MatchArm { pat: S1Pattern.Wildcard; value: nested_expr; };
                      let arms_nil: List<S1MatchArm> = Nil;
                      let arms2_tail: List<S1MatchArm> = Cons(ListCons<S1MatchArm> { head: default_arm; tail: arms_nil; });
                      let arms2: List<S1MatchArm> = Cons(ListCons<S1MatchArm> { head: a0.head; tail: arms2_tail; });
                      let top_expr: S1Expr = S1Expr.Match(S1Match { scrutinee: scrut_expr; arms: arms2; });

                      s1_cg_emit_expr_min(out2, env2, s0.next_tmp + 1, s0.bb, items, strs, fns, top_expr)
                    };
                    _ => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: match must have 2 arms in v0.4"));
                  }
                };
              }
            };
          }
        };
      }
    };
    _ => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: expr kind not supported in v0"));
  }
};

fn s1_cg_emit_while_stmt_min(out: Text, env: List<S1CgEnvBind>, next_tmp: Int, items: List<S1Item>, strs: List<S1CgStrConst>, fns: List<S1CgFnSig>, w: S1While) -> Result<S1CgBlockOut, S1Diagnostic> {
  let cond_id: Text = int_to_text(next_tmp);
  let cond_lbl: Text = text_concat("while_cond", cond_id);
  let body_id: Text = int_to_text(next_tmp + 1);
  let body_lbl: Text = text_concat("while_body", body_id);
  let end_id: Text = int_to_text(next_tmp + 2);
  let end_lbl: Text = text_concat("while_end", end_id);
  let nt0: Int = next_tmp + 3;

  let out1: Text = s1_cg_line(out, text_concat("  br label %", cond_lbl));
  let out2: Text = s1_cg_line(out1, text_concat(cond_lbl, ":"));
  let cond_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(out2, env, nt0, cond_lbl, items, strs, fns, w.cond);
  match cond_r {
    Err(e) => s1_cg_block_err(e);
    Ok(c0) => {
      if c0.ty == "i1" {
        let br2: Text =
          text_concat(
            text_concat(text_concat("  br i1 ", c0.value), text_concat(", label %", body_lbl)),
            text_concat(", label %", end_lbl)
          );
        let out3: Text = s1_cg_line(c0.text, br2);
        let out4: Text = s1_cg_line(out3, text_concat(body_lbl, ":"));

        let body_env: List<S1CgEnvBind> = env;
        let body_r: Result<S1CgBlockOut, S1Diagnostic> =
          s1_cg_emit_stmt_list_min(out4, body_env, c0.next_tmp, body_lbl, items, strs, fns, w.body.stmts);
        match body_r {
          Err(e2) => s1_cg_block_err(e2);
          Ok(b0) => {
            let ot: Text = b0.text;
            let nt: Int = b0.next_tmp;
            let env2: List<S1CgEnvBind> = b0.env;

            // Evaluate (and drop) tail expr if present.
            match w.body.result {
              None => {
                let out_back: Text = s1_cg_line(ot, text_concat("  br label %", cond_lbl));
                let out_end: Text = s1_cg_line(out_back, text_concat(end_lbl, ":"));
                s1_cg_block_ok(S1CgBlockOut { text: out_end; env: env; bb: end_lbl; next_tmp: nt; })
              };
              Some(expr) => {
                let rr: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(ot, env2, nt, b0.bb, items, strs, fns, expr);
                match rr {
                  Err(e3) => s1_cg_block_err(e3);
                  Ok(r0) => {
                    let out_back: Text = s1_cg_line(r0.text, text_concat("  br label %", cond_lbl));
                    let out_end: Text = s1_cg_line(out_back, text_concat(end_lbl, ":"));
                    s1_cg_block_ok(S1CgBlockOut { text: out_end; env: env; bb: end_lbl; next_tmp: r0.next_tmp; })
                  };
                }
              };
            }
          };
        }
      } else {
        s1_cg_block_err(s1_diag(Error, 0, 0, "codegen: while condition must be Bool (i1)"))
      }
    };
  }
};

fn s1_cg_emit_stmt_list_min(out: Text, env: List<S1CgEnvBind>, next_tmp: Int, bb: Text, items: List<S1Item>, strs: List<S1CgStrConst>, fns: List<S1CgFnSig>, stmts: List<S1Stmt>) -> Result<S1CgBlockOut, S1Diagnostic> {
  let ot: Text = out;
  let envt: List<S1CgEnvBind> = env;
  let bbt: Text = bb;
  let nt: Int = next_tmp;
  let ok: Bool = true;
  let diag: S1Diagnostic = s1_diag(Error, 0, 0, "codegen: stmt list failed");

  let cur: List<S1Stmt> = stmts;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        if ok == false {
          done = true;
          0
        } else {
          match c0.head {
            Let(l0) => {
              let rr: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(ot, envt, nt, bbt, items, strs, fns, l0.value);
              match rr {
                Err(e) => { ok = false; diag = e; done = true; 0 };
                Ok(r) => {
                  // v0 subset: Int/Bool/Text locals.
                  // v0.4: allow Option<Int> and Result<_, _> pointers (enum layout { i8 tag, i64 payload }).
                  let expected: Text = "i64";
                  if s1_cg_type_is_plain_int(l0.ty) == true {
                    expected = "i64";
                    0
                  } else {
                    if s1_cg_type_is_plain_bool(l0.ty) == true {
                      expected = "i1";
                      0
                    } else {
                      if s1_cg_type_is_plain_text(l0.ty) == true {
                        expected = "i8*";
                        0
                      } else {
                        if s1_cg_type_is_option(l0.ty) == true {
                          expected = "%Option*";
                          0
                        } else {
                          if s1_cg_type_is_result(l0.ty) == true {
                            expected = "%Result*";
                            0
                          } else {
                            if s1_cg_type_is_list(l0.ty) == true {
                              expected = "%List*";
                              0
                            } else {
                              // Any record type is represented as an opaque heap pointer.
                              expected = "i8*";
                              0
                            }
                          }
                        }
                      }
                    }
                  };

                  if ok == true {
                    if r.ty == expected {
                      let slot_id: Text = int_to_text(r.next_tmp);
                      let slot: Text = text_concat("%t", slot_id);
                      let alloca_inst: Text = text_concat(text_concat(text_concat("  ", slot), " = alloca "), expected);
                      let out1: Text = s1_cg_line(r.text, alloca_inst);
                      let store_head: Text = text_concat(text_concat("  store ", expected), text_concat(" ", r.value));
                      let store_tail: Text = text_concat(text_concat(", ", expected), text_concat("* ", slot));
                      let out2: Text = s1_cg_line(out1, text_concat(store_head, store_tail));

                      let bind: S1CgEnvBind = S1CgEnvBind { name: l0.name; llvm: slot; ty: expected; s1_ty: l0.ty; };
                      envt = Cons(ListCons<S1CgEnvBind> { head: bind; tail: envt; });
                      ot = out2;
                      bbt = r.bb;
                      nt = r.next_tmp + 1;
                      cur = c0.tail;
                      0
                    } else {
                      ok = false;
                      diag = s1_diag(Error, 0, 0, "codegen: let value type mismatch in v0");
                      done = true;
                      0
                    }
                  } else { 0 };
                  0
                };
              }
            };
            Assign(a0) => {
              match s1_cg_lookup_env(envt, a0.name) {
                None => {
                  ok = false;
                  diag = s1_diag(Error, 0, 0, text_concat("codegen: assignment to unknown variable ", a0.name));
                  done = true;
                  0
                };
                Some(v) => {
                  let rr: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(ot, envt, nt, bbt, items, strs, fns, a0.value);
                  match rr {
                    Err(e) => { ok = false; diag = e; done = true; 0 };
                    Ok(r) => {
                      if r.ty == v.ty {
                        let store_head: Text = text_concat(text_concat("  store ", v.ty), text_concat(" ", r.value));
                        let store_tail: Text = text_concat(text_concat(", ", v.ty), text_concat("* ", v.llvm));
                        ot = s1_cg_line(r.text, text_concat(store_head, store_tail));
                        bbt = r.bb;
                        nt = r.next_tmp;
                        cur = c0.tail;
                        0
                      } else {
                        ok = false;
                        diag = s1_diag(Error, 0, 0, "codegen: assignment type mismatch in v0");
                        done = true;
                        0
                      }
                    };
                  }
                };
              }
            };
            While(w0) => {
              let wr: Result<S1CgBlockOut, S1Diagnostic> = s1_cg_emit_while_stmt_min(ot, envt, nt, items, strs, fns, w0);
              match wr {
                Err(e) => { ok = false; diag = e; done = true; 0 };
                Ok(b) => {
                  ot = b.text;
                  bbt = b.bb;
                  nt = b.next_tmp;
                  cur = c0.tail;
                  0
                };
              }
            };
            ExprStmt(e0) => {
              let handled_if_stmt: Bool = false;

              // Special-case: `if cond { ... };` as a statement (no else).
              match e0 {
                If(i0) => {
                  match i0.else_block {
                    Some(else_b) => {
                      let c_r: Result<S1CgExprOut, S1Diagnostic> =
                        s1_cg_emit_expr_min(ot, envt, nt, bbt, items, strs, fns, i0.cond);
                      match c_r {
                        Err(e) => { ok = false; diag = e; done = true; 0 };
                        Ok(cond0) => {
                          if cond0.ty != "i1" {
                            ok = false;
                            diag = s1_diag(Error, 0, 0, "codegen: if condition must be Bool (i1)");
                            done = true;
                            0
                          } else {
                            let then_lbl: Text = text_concat("if_then", int_to_text(cond0.next_tmp));
                            let else_lbl: Text = text_concat("if_else", int_to_text(cond0.next_tmp + 1));
                            let end_lbl: Text = text_concat("if_end", int_to_text(cond0.next_tmp + 2));
                            let nt0: Int = cond0.next_tmp + 3;
                            let br: Text = text_concat(
                              text_concat(text_concat("  br i1 ", cond0.value), text_concat(", label %", then_lbl)),
                              text_concat(", label %", else_lbl)
                            );
                            let out_br: Text = s1_cg_line(cond0.text, br);

                            // then:
                            let out_then_lbl: Text = s1_cg_line(out_br, text_concat(then_lbl, ":"));
                            let tr: Result<S1CgBlockOut, S1Diagnostic> =
                              s1_cg_emit_stmt_list_min(out_then_lbl, envt, nt0, then_lbl, items, strs, fns, i0.then_block.stmts);
                            match tr {
                              Err(e2) => { ok = false; diag = e2; done = true; 0 };
                              Ok(tb) => {
                                // Optional tail expr inside then-block (discard value).
                                let ot_then: Text = tb.text;
                                let nt_then: Int = tb.next_tmp;
                                let bb_then: Text = tb.bb;
                                match i0.then_block.result {
                                  None => 0;
                                  Some(te) => {
                                    let rr: Result<S1CgExprOut, S1Diagnostic> =
                                      s1_cg_emit_expr_min(ot_then, tb.env, nt_then, bb_then, items, strs, fns, te);
                                    match rr {
                                      Err(e3) => { ok = false; diag = e3; done = true; 0 };
                                      Ok(r0) => { ot_then = r0.text; nt_then = r0.next_tmp; bb_then = r0.bb; 0 };
                                    };
                                    0
                                  };
                                };

                                let out_then_end: Text = s1_cg_line(ot_then, text_concat("  br label %", end_lbl));

                                // else:
                                let out_else_lbl: Text = s1_cg_line(out_then_end, text_concat(else_lbl, ":"));
                                let er: Result<S1CgBlockOut, S1Diagnostic> =
                                  s1_cg_emit_stmt_list_min(out_else_lbl, envt, nt_then, else_lbl, items, strs, fns, else_b.stmts);
                                match er {
                                  Err(e4) => { ok = false; diag = e4; done = true; 0 };
                                  Ok(eb) => {
                                    // Optional tail expr inside else-block (discard value).
                                    let ot_else: Text = eb.text;
                                    let nt_else: Int = eb.next_tmp;
                                    let bb_else: Text = eb.bb;
                                    match else_b.result {
                                      None => 0;
                                      Some(ee) => {
                                        let rr2: Result<S1CgExprOut, S1Diagnostic> =
                                          s1_cg_emit_expr_min(ot_else, eb.env, nt_else, bb_else, items, strs, fns, ee);
                                        match rr2 {
                                          Err(e5) => { ok = false; diag = e5; done = true; 0 };
                                          Ok(r1) => { ot_else = r1.text; nt_else = r1.next_tmp; bb_else = r1.bb; 0 };
                                        };
                                        0
                                      };
                                    };

                                    let out_else_end: Text = s1_cg_line(ot_else, text_concat("  br label %", end_lbl));
                                    let out_end: Text = s1_cg_line(out_else_end, text_concat(end_lbl, ":"));
                                    ot = out_end;
                                    bbt = end_lbl;
                                    nt = nt_else;
                                    cur = c0.tail;
                                    handled_if_stmt = true;
                                    0
                                  };
                                };
                                0
                              };
                            };
                            0
                          }
                        };
                      };
                      0
                    };
                    None => {
                      let c_r: Result<S1CgExprOut, S1Diagnostic> =
                        s1_cg_emit_expr_min(ot, envt, nt, bbt, items, strs, fns, i0.cond);
                      match c_r {
                        Err(e) => { ok = false; diag = e; done = true; 0 };
                        Ok(cond0) => {
                          if cond0.ty != "i1" {
                            ok = false;
                            diag = s1_diag(Error, 0, 0, "codegen: if condition must be Bool (i1)");
                            done = true;
                            0
                          } else {
                            let then_lbl: Text = text_concat("if_then", int_to_text(cond0.next_tmp));
                            let end_lbl: Text = text_concat("if_end", int_to_text(cond0.next_tmp + 1));
                            let nt0: Int = cond0.next_tmp + 2;
                            let br: Text = text_concat(
                              text_concat(text_concat("  br i1 ", cond0.value), text_concat(", label %", then_lbl)),
                              text_concat(", label %", end_lbl)
                            );
                            let out_br: Text = s1_cg_line(cond0.text, br);

                            // then:
                            let out_then_lbl: Text = s1_cg_line(out_br, text_concat(then_lbl, ":"));
                            let tr: Result<S1CgBlockOut, S1Diagnostic> =
                              s1_cg_emit_stmt_list_min(out_then_lbl, envt, nt0, then_lbl, items, strs, fns, i0.then_block.stmts);
                            match tr {
                              Err(e2) => { ok = false; diag = e2; done = true; 0 };
                              Ok(tb) => {
                                // Optional tail expr inside then-block (discard value).
                                let ot_then: Text = tb.text;
                                let nt_then: Int = tb.next_tmp;
                                let bb_then: Text = tb.bb;
                                match i0.then_block.result {
                                  None => 0;
                                  Some(te) => {
                                    let rr: Result<S1CgExprOut, S1Diagnostic> =
                                      s1_cg_emit_expr_min(ot_then, tb.env, nt_then, bb_then, items, strs, fns, te);
                                    match rr {
                                      Err(e3) => { ok = false; diag = e3; done = true; 0 };
                                      Ok(r0) => { ot_then = r0.text; nt_then = r0.next_tmp; bb_then = r0.bb; 0 };
                                    };
                                    0
                                  };
                                };

                                let out_then_end: Text = s1_cg_line(ot_then, text_concat("  br label %", end_lbl));
                                let out_end: Text = s1_cg_line(out_then_end, text_concat(end_lbl, ":"));
                                ot = out_end;
                                bbt = end_lbl;
                                nt = nt_then;
                                cur = c0.tail;
                                handled_if_stmt = true;
                                0
                              };
                            };
                            0
                          }
                        };
                      };
                      0
                    };
                  };
                  0
                };
                _ => 0;
              };

              if handled_if_stmt == false {
                let rr: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(ot, envt, nt, bbt, items, strs, fns, e0);
                match rr {
                  Err(e) => { ok = false; diag = e; done = true; 0 };
                  Ok(r) => {
                    ot = r.text;
                    bbt = r.bb;
                    nt = r.next_tmp;
                    cur = c0.tail;
                    0
                  };
                }
              } else { 0 };
              0
            };
            Return(_r0) => {
              ok = false;
              diag = s1_diag(Error, 0, 0, "codegen: return statement not supported in v0 subset");
              done = true;
              0
            };
          };
          0
        };
        0
      };
    }
  };

  if ok == false {
    s1_cg_block_err(diag)
  } else {
    s1_cg_block_ok(S1CgBlockOut { text: ot; env: envt; bb: bbt; next_tmp: nt; })
  }
};

fn s1_cg_emit_function_min(out: Text, items: List<S1Item>, strs: List<S1CgStrConst>, f: S1Function, fns: List<S1CgFnSig>) -> Result<Text, S1Diagnostic> {
  // Caller must ensure `s1_cg_function_supported(f) == true`.
  let ret_llvm: Text = "i64";
  match s1_cg_llvm_ty_of_s1(f.return_type) {
    None => { ret_llvm = "i64"; 0 };
    Some(t0) => { ret_llvm = t0; 0 };
  };

  let params_str: Text = "";
  let curp: List<S1Param> = f.params;
  let donep: Bool = false;
  let ps: Text = params_str;
  let first: Bool = true;
  while donep == false {
    match curp {
      Nil => { donep = true; 0 };
      Cons(c0) => {
        let pty: Text = "i64";
        match s1_cg_llvm_ty_of_s1(c0.head.ty) {
          None => { pty = "i64"; 0 };
          Some(t1) => { pty = t1; 0 };
        };
        let seg: Text = text_concat(text_concat(pty, " %"), c0.head.name);
        if first == true {
          ps = seg;
          first = false;
          0
        } else {
          ps = text_concat(text_concat(ps, ", "), seg);
          0
        };
        curp = c0.tail;
        0
      };
    }
  };

  match f.body {
    None => s1_cg_text_ok(out);
    Some(body) => {
      let head: Text = text_concat(text_concat("define ", ret_llvm), text_concat(" @", f.name));
      let out1: Text = s1_cg_line(out, text_concat(head, text_concat("(", text_concat(ps, ") {"))));
      let out2: Text = s1_cg_line(out1, "entry:");
      let entry_out: Text = out2;
      if f.name == "main" {
        entry_out = s1_cg_line(entry_out, "  call void @kx_runtime_init()");
        0
      } else { 0 };

      // Parameters become stack slots so assignment works without SSA/phi complexity.
      let env: List<S1CgEnvBind> = Nil;
      let ot: Text = entry_out;
      let nt: Int = 0;
      let pcur: List<S1Param> = f.params;
      let pdone: Bool = false;
      while pdone == false {
        match pcur {
          Nil => { pdone = true; 0 };
          Cons(pc0) => {
            let slot_id: Text = int_to_text(nt);
            let slot: Text = text_concat("%t", slot_id);
            let pty: Text = "i64";
            match s1_cg_llvm_ty_of_s1(pc0.head.ty) {
              None => { pty = "i64"; 0 };
              Some(t2) => { pty = t2; 0 };
            };
            let alloca_inst: Text = text_concat(text_concat(text_concat("  ", slot), " = alloca "), pty);
            let out3: Text = s1_cg_line(ot, alloca_inst);
            let store_head: Text = text_concat(text_concat(text_concat("  store ", pty), text_concat(" %", pc0.head.name)), "");
            let store_tail: Text = text_concat(text_concat(", ", pty), text_concat("* ", slot));
            let out4: Text = s1_cg_line(out3, text_concat(store_head, store_tail));

            let bind: S1CgEnvBind = S1CgEnvBind { name: pc0.head.name; llvm: slot; ty: pty; s1_ty: pc0.head.ty; };
            env = Cons(ListCons<S1CgEnvBind> { head: bind; tail: env; });
            ot = out4;
            nt = nt + 1;
            pcur = pc0.tail;
            0
          };
        }
      };

      let stmts_r: Result<S1CgBlockOut, S1Diagnostic> = s1_cg_emit_stmt_list_min(ot, env, nt, "entry", items, strs, fns, body.stmts);
      match stmts_r {
        Err(e) => s1_cg_text_err(e);
        Ok(s0) => {
          match body.result {
            None => s1_cg_text_err(s1_diag(Error, 0, 0, "codegen: function body has no result"));
            Some(expr) => {
              let rr: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(s0.text, s0.env, s0.next_tmp, s0.bb, items, strs, fns, expr);
              match rr {
                Err(e2) => s1_cg_text_err(e2);
                Ok(r0) => {
                  if r0.ty == ret_llvm {
                    let out3: Text = s1_cg_line(r0.text, text_concat(text_concat("  ret ", ret_llvm), text_concat(" ", r0.value)));
                    let out4: Text = s1_cg_line(out3, "}");
                    let out5: Text = s1_cg_line(out4, "");
                    s1_cg_text_ok(out5)
                  } else {
                    s1_cg_text_err(s1_diag(Error, 0, 0, "codegen: function result type mismatch in v0 subset"))
                  }
                };
              }
            };
          }
        };
      }
    };
  }
};

fn s1_cg_text_list_contains(xs: List<Text>, value: Text) -> Bool {
  let ok: Bool = false;
  let cur: List<Text> = xs;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        if c0.head == value { ok = true; done = true; 0 } else { cur = c0.tail; 0 };
        0
      };
    }
  };
  ok
};

fn s1_cg_add_str_lit(acc: List<Text>, lit: Text) -> List<Text> {
  if s1_cg_text_list_contains(acc, lit) == true {
    acc
  } else {
    let out: List<Text> = Cons(ListCons<Text> { head: lit; tail: acc; });
    out
  }
};

fn s1_cg_reverse_text_list(xs: List<Text>) -> List<Text> {
  let out: List<Text> = Nil;
  let cur: List<Text> = xs;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        out = Cons(ListCons<Text> { head: c0.head; tail: out; });
        cur = c0.tail;
        0
      };
    }
  };
  out
};

fn s1_cg_join_text_chunks(chunks: List<Text>) -> Text {
  // Pairwise concatenation in rounds to avoid O(n^2) growth when building large outputs.
  // This is still not zero-copy, but reduces peak copying to roughly O(total_size * log n).
  let cur: List<Text> = chunks;
  let done: Bool = false;
  let out: Text = "";

  while done == false {
    match cur {
      Nil => { out = ""; done = true; 0 };
      Cons(c0) => {
        match c0.tail {
          Nil => { out = c0.head; done = true; 0 };
          _ => {
            // Merge adjacent pairs into a new list.
            let merged_rev: List<Text> = Nil;
            let c2: List<Text> = cur;
            let done2: Bool = false;
            while done2 == false {
              match c2 {
                Nil => { done2 = true; 0 };
                Cons(a0) => {
                  match a0.tail {
                    Nil => {
                      merged_rev = Cons(ListCons<Text> { head: a0.head; tail: merged_rev; });
                      done2 = true;
                      0
                    };
                    Cons(b0) => {
                      let m: Text = text_concat(a0.head, b0.head);
                      merged_rev = Cons(ListCons<Text> { head: m; tail: merged_rev; });
                      c2 = b0.tail;
                      0
                    };
                  };
                  0
                };
              }
            };
            cur = s1_cg_reverse_text_list(merged_rev);
            0
          };
        };
        0
      };
    }
  };

  out
};

fn s1_cg_reverse_str_const_list(xs: List<S1CgStrConst>) -> List<S1CgStrConst> {
  let out: List<S1CgStrConst> = Nil;
  let cur: List<S1CgStrConst> = xs;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        out = Cons(ListCons<S1CgStrConst> { head: c0.head; tail: out; });
        cur = c0.tail;
        0
      };
    }
  };
  out
};

fn s1_cg_collect_strs_expr(acc: List<Text>, e: S1Expr) -> List<Text> {
  match e {
    IntLit(_n) => acc;
    BoolLit(_b) => acc;
    Path(_p) => acc;
    StringLit(s) => s1_cg_add_str_lit(acc, s);
    Member(m) => s1_cg_collect_strs_expr(acc, m.base);
    Binary(b) => {
      let a1: List<Text> = s1_cg_collect_strs_expr(acc, b.left);
      s1_cg_collect_strs_expr(a1, b.right)
    };
    Call(c) => {
      let a1: List<Text> = s1_cg_collect_strs_expr(acc, c.callee);
      let cur: List<S1Expr> = c.args;
      let out: List<Text> = a1;
      let done: Bool = false;
      while done == false {
        match cur {
          Nil => { done = true; 0 };
          Cons(c0) => { out = s1_cg_collect_strs_expr(out, c0.head); cur = c0.tail; 0 };
        }
      };
      out
    };
    Block(b) => s1_cg_collect_strs_block(acc, b);
    If(i) => {
      let a1: List<Text> = s1_cg_collect_strs_expr(acc, i.cond);
      let a2: List<Text> = s1_cg_collect_strs_block(a1, i.then_block);
      match i.else_block {
        None => a2;
        Some(eb) => s1_cg_collect_strs_block(a2, eb);
      }
    };
    Match(m) => {
      let a1: List<Text> = s1_cg_collect_strs_expr(acc, m.scrutinee);
      let cur: List<S1MatchArm> = m.arms;
      let out: List<Text> = a1;
      let done: Bool = false;
      while done == false {
        match cur {
          Nil => { done = true; 0 };
          Cons(c0) => { out = s1_cg_collect_strs_expr(out, c0.head.value); cur = c0.tail; 0 };
        }
      };
      out
    };
    RecordLit(r) => {
      let cur: List<S1RecordLitField> = r.fields;
      let out: List<Text> = acc;
      let done: Bool = false;
      while done == false {
        match cur {
          Nil => { done = true; 0 };
          Cons(c0) => { out = s1_cg_collect_strs_expr(out, c0.head.value); cur = c0.tail; 0 };
        }
      };
      out
    };
  }
};

fn s1_cg_collect_strs_block(acc: List<Text>, b: S1Block) -> List<Text> {
  let out: List<Text> = acc;
  let cur: List<S1Stmt> = b.stmts;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        match c0.head {
          Let(l) => { out = s1_cg_collect_strs_expr(out, l.value); 0 };
          Assign(a) => { out = s1_cg_collect_strs_expr(out, a.value); 0 };
          Return(r) => { out = s1_cg_collect_strs_expr(out, r.value); 0 };
          ExprStmt(e) => { out = s1_cg_collect_strs_expr(out, e); 0 };
          While(w) => {
            out = s1_cg_collect_strs_expr(out, w.cond);
            out = s1_cg_collect_strs_block(out, w.body);
            0
          };
        };
        cur = c0.tail;
        0
      };
    }
  };
  match b.result {
    None => out;
    Some(e2) => s1_cg_collect_strs_expr(out, e2);
  }
};

fn s1_cg_collect_strs_program(p: S1Program) -> List<Text> {
  let acc: List<Text> = Nil;
  let cur: List<S1Item> = p.items;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        match c0.head {
          Function(f) => {
            match f.body {
              None => 0;
              Some(b) => { acc = s1_cg_collect_strs_block(acc, b); 0 };
            };
            0
          };
          _ => 0;
        };
        cur = c0.tail;
        0
      };
    }
  };
  s1_cg_reverse_text_list(acc)
};

fn s1_cg_build_str_table(lits: List<Text>) -> List<S1CgStrConst> {
  let acc: List<S1CgStrConst> = Nil;
  let next_id: Int = 0;
  let cur: List<Text> = lits;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        let global: Text = text_concat("@.str.", int_to_text(next_id));
        let n: Int = text_len(c0.head) + 1;
        let sc: S1CgStrConst = S1CgStrConst { lit: c0.head; global: global; n: n; };
        acc = Cons(ListCons<S1CgStrConst> { head: sc; tail: acc; });
        next_id = next_id + 1;
        cur = c0.tail;
        0
      };
    }
  };
  s1_cg_reverse_str_const_list(acc)
};

fn s1_cg_llvm_i8_array_init(s: Text) -> Text {
  // Emit a numeric i8 array initializer to avoid relying on LLVM c"..." escaping.
  // Example: [i8 52, i8 50, i8 0]
  let pieces: Text = "";
  let out: Text = pieces;
  let first: Bool = true;

  let i: Int = 0;
  let n: Int = text_len(s);
  let done: Bool = false;
  while done == false {
    if i == n {
      done = true;
      0
    } else {
      match text_byte_at(s, i) {
        None => 0;
        Some(b) => {
          let piece: Text = text_concat("i8 ", int_to_text(b));
          if first == true {
            out = piece;
            first = false;
            0
          } else {
            out = text_concat(text_concat(out, ", "), piece);
            0
          };
          0
        };
      };
      i = i + 1;
      0
    };
  };

  // NUL terminator.
  if first == true {
    out = "i8 0";
    0
  } else {
    out = text_concat(out, ", i8 0");
    0
  };

  text_concat("[", text_concat(out, "]"))
};

fn s1_cg_llvm_escape_text_bytes(s: Text) -> Text {
  let out: Text = "";
  let i: Int = 0;
  let n: Int = text_len(s);
  let done: Bool = false;
  while done == false {
    if i == n {
      done = true;
      0
    } else {
      match text_byte_at(s, i) {
        None => 0;
        Some(b) => {
          if b == 10 { out = text_concat(out, "\\0A"); 0 } else { 0 };
          if b == 13 { out = text_concat(out, "\\0D"); 0 } else { 0 };
          if b == 9 { out = text_concat(out, "\\09"); 0 } else { 0 };
          if b == 34 { out = text_concat(out, "\\22"); 0 } else { 0 }; // "
          if b == 92 { out = text_concat(out, "\\5C"); 0 } else { 0 }; // \
          if b == 0 { out = text_concat(out, "\\00"); 0 } else { 0 };

          let special: Bool = false;
          if b == 10 { special = true; 0 } else { 0 };
          if b == 13 { special = true; 0 } else { 0 };
          if b == 9 { special = true; 0 } else { 0 };
          if b == 34 { special = true; 0 } else { 0 };
          if b == 92 { special = true; 0 } else { 0 };
          if b == 0 { special = true; 0 } else { 0 };

          if special == false {
            match text_slice(s, i, i + 1) {
              None => { out = text_concat(out, "?"); 0 };
              Some(ch) => { out = text_concat(out, ch); 0 };
            }
          } else { 0 };
          0
        };
      };
      i = i + 1;
      0
    };
  };
  out
};

fn s1_cg_emit_prelude(strs: List<S1CgStrConst>) -> Text {
  let out: Text = "";
  let ot: Text = out;

  ot = s1_cg_line(ot, "; ModuleID = 'kooix_stage1_v0'");
  ot = s1_cg_line(ot, "");

  // Enum layout (Stage0 compatible): heap pointer to `{ i8 tag, i64 payload_word }`.
  ot = s1_cg_line(ot, "%Option = type { i8, i64 }");
  ot = s1_cg_line(ot, "%Result = type { i8, i64 }");
  ot = s1_cg_line(ot, "%List = type { i8, i64 }");
  ot = s1_cg_line(ot, "");

  // Minimal runtime + libc intrinsics used by Stage0 native backend.
  ot = s1_cg_line(ot, "declare i8* @malloc(i64)");
  ot = s1_cg_line(ot, "declare i64 @strlen(i8*)");
  ot = s1_cg_line(ot, "declare i32 @memcmp(i8*, i8*, i64)");
  ot = s1_cg_line(ot, "declare i8* @memcpy(i8*, i8*, i64)");
  ot = s1_cg_line(ot, "declare i32 @strcmp(i8*, i8*)");
  ot = s1_cg_line(ot, "");

  // Native host intrinsics (provided by crates/kooixc/native_runtime/runtime.c).
  ot = s1_cg_line(ot, "declare void @kx_runtime_init()");
  ot = s1_cg_line(ot, "declare i8* @kx_host_load_source_map(i8*)");
  ot = s1_cg_line(ot, "declare void @kx_host_eprintln(i8*)");
  ot = s1_cg_line(ot, "declare i8* @kx_host_write_file(i8*, i8*)");
  ot = s1_cg_line(ot, "declare i8* @kx_text_concat(i8*, i8*)");
  ot = s1_cg_line(ot, "declare i8* @kx_int_to_text(i64)");
  ot = s1_cg_line(ot, "");

  // String constants used by StringLit.
  let cur: List<S1CgStrConst> = strs;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        let init: Text = s1_cg_llvm_i8_array_init(c0.head.lit);
        let n_txt: Text = int_to_text(c0.head.n);
        let head: Text = text_concat(text_concat(text_concat(text_concat(c0.head.global, " = private unnamed_addr constant ["), n_txt), " x i8] "), init);
        let line: Text = text_concat(head, ", align 1");
        ot = s1_cg_line(ot, line);
        cur = c0.tail;
        0
      };
    }
  };

  match strs {
    Nil => ot;
    _ => s1_cg_line(ot, "");
  }
};

fn s1_emit_llvm_ir_real(source: Text) -> Result<Text, S1Diagnostic>
intent "Stage1 LLVM IR emitter (v0 real): parse+check then emit minimal LLVM for Int-only functions"
evidence {
  trace "stage1.emit_llvm_real.v0";
  metrics [stage1_emit_llvm_real_calls];
}
{
  let tokens: Result<List<S1Token>, S1Diagnostic> = s1_lex(source);
  match tokens {
    Err(e) => s1_cg_text_err(e);
    Ok(ts) => {
      let ast_r: Result<S1Program, S1Diagnostic> = s1_parse(ts);
      match ast_r {
        Err(e2) => s1_cg_text_err(e2);
        Ok(p) => {
          let res_r: Result<S1Program, S1Diagnostic> = s1_resolve_program(p);
          match res_r {
            Err(e3) => s1_cg_text_err(e3);
            Ok(p2) => {
              let tc_r: Result<S1Program, S1Diagnostic> = s1_typecheck_program(p2);
              match tc_r {
                Err(e4) => s1_cg_text_err(e4);
                Ok(p3) => {
                  let lits: List<Text> = s1_cg_collect_strs_program(p3);
                  let strs: List<S1CgStrConst> = s1_cg_build_str_table(lits);
                  let fnsigs: List<S1CgFnSig> = s1_cg_collect_fn_sigs_program(p3);
                  let prelude: Text = s1_cg_emit_prelude(strs);
                  let cur: List<S1Item> = p3.items;
                  let done: Bool = false;
                  let chunks_nil: List<Text> = Nil;
                  let chunks_rev: List<Text> = Cons(ListCons<Text> { head: prelude; tail: chunks_nil; });
                  let ok_cg: Bool = true;
                  let diag_cg: S1Diagnostic = s1_diag(Error, 0, 0, "codegen: failed");
                  let emitted_main: Bool = false;

                  while done == false {
                    match cur {
                      Nil => {
                        done = true;
                        0
                      };
                      Cons(c0) => {
                        match c0.head {
                          Function(f) => {
                            if s1_cg_function_supported(f) == true {
                              match s1_cg_emit_function_min("", p3.items, strs, f, fnsigs) {
                                Err(e5) => {
                                  ok_cg = false;
                                  let msg: Text = text_concat(text_concat(text_concat("codegen in fn ", f.name), ": "), e5.message);
                                  diag_cg = s1_diag(e5.severity, e5.span.start, e5.span.end, msg);
                                  done = true;
                                  0
                                };
                                Ok(t2) => {
                                  chunks_rev = Cons(ListCons<Text> { head: t2; tail: chunks_rev; });
                                  if f.name == "main" { emitted_main = true; 0 } else { 0 };
                                  0
                                };
                              };
                              0
                            } else {
                              0
                            };
                            0
                          };
                          _ => 0;
                        };
                        cur = c0.tail;
                        0
                      };
                    }
                  };

                  if ok_cg == false {
                    s1_cg_text_err(diag_cg)
                  } else {
                    if emitted_main == false {
                      s1_cg_text_err(s1_diag(Error, 0, 0, "codegen: no supported main() function found in v0 subset"))
                    } else {
                      let chunks: List<Text> = s1_cg_reverse_text_list(chunks_rev);
                      s1_cg_text_ok(s1_cg_join_text_chunks(chunks))
                    }
                  }
                };
              }
            };
          }
        };
      }
    };
  }
};

fn s1_emit_llvm_ir_debug(source: Text) -> Result<Text, S1Diagnostic>
intent "Stage1 LLVM IR emitter (debug): print progress to stderr"
evidence {
  trace "stage1.emit_llvm.debug.v0";
  metrics [stage1_emit_llvm_debug_calls];
}
{
  host_eprintln("emit_llvm: lex");
  let tokens: Result<List<S1Token>, S1Diagnostic> = s1_lex(source);
  match tokens {
    Err(e) => s1_cg_text_err(e);
    Ok(ts) => {
      host_eprintln("emit_llvm: parse");
      let ast_r: Result<S1Program, S1Diagnostic> = s1_parse(ts);
      match ast_r {
        Err(e2) => s1_cg_text_err(e2);
        Ok(p) => {
          host_eprintln("emit_llvm: resolve");
          let res_r: Result<S1Program, S1Diagnostic> = s1_resolve_program(p);
          match res_r {
            Err(e3) => s1_cg_text_err(e3);
            Ok(p2) => {
              host_eprintln("emit_llvm: typecheck");
              let tc_r: Result<S1Program, S1Diagnostic> = s1_typecheck_program(p2);
              match tc_r {
                Err(e4) => s1_cg_text_err(e4);
                Ok(p3) => {
                  host_eprintln("emit_llvm: collect strings");
                  let lits: List<Text> = s1_cg_collect_strs_program(p3);
                  let strs: List<S1CgStrConst> = s1_cg_build_str_table(lits);
                  host_eprintln("emit_llvm: collect fn sigs");
                  let fnsigs: List<S1CgFnSig> = s1_cg_collect_fn_sigs_program(p3);

                  host_eprintln("emit_llvm: codegen begin");
                  let prelude: Text = s1_cg_emit_prelude(strs);
                  let cur: List<S1Item> = p3.items;
                  let done: Bool = false;
                  let chunks_nil: List<Text> = Nil;
                  let chunks_rev: List<Text> = Cons(ListCons<Text> { head: prelude; tail: chunks_nil; });
                  let ok_cg: Bool = true;
                  let diag_cg: S1Diagnostic = s1_diag(Error, 0, 0, "codegen: failed");
                  let emitted_main: Bool = false;
                  let fn_i: Int = 0;

                  while done == false {
                    match cur {
                      Nil => {
                        done = true;
                        0
                      };
                      Cons(c0) => {
                        match c0.head {
                          Function(f) => {
                            if s1_cg_function_supported(f) == true {
                              host_eprintln(text_concat(text_concat("emit_llvm: cg fn ", f.name), text_concat(" #", int_to_text(fn_i))));
                              match s1_cg_emit_function_min("", p3.items, strs, f, fnsigs) {
                                Err(e5) => {
                                  ok_cg = false;
                                  let msg: Text = text_concat(text_concat(text_concat("codegen in fn ", f.name), ": "), e5.message);
                                  diag_cg = s1_diag(e5.severity, e5.span.start, e5.span.end, msg);
                                  done = true;
                                  0
                                };
                                Ok(t2) => {
                                  chunks_rev = Cons(ListCons<Text> { head: t2; tail: chunks_rev; });
                                  if f.name == "main" { emitted_main = true; 0 } else { 0 };
                                  0
                                };
                              };
                              fn_i = fn_i + 1;
                              0
                            } else {
                              0
                            };
                            0
                          };
                          _ => 0;
                        };
                        cur = c0.tail;
                        0
                      };
                    }
                  };

                  host_eprintln("emit_llvm: codegen end");
                  if ok_cg == false {
                    s1_cg_text_err(diag_cg)
                  } else {
                    if emitted_main == false {
                      s1_cg_text_err(s1_diag(Error, 0, 0, "codegen: no supported main() function found in v0 subset"))
                    } else {
                      let chunks: List<Text> = s1_cg_reverse_text_list(chunks_rev);
                      s1_cg_text_ok(s1_cg_join_text_chunks(chunks))
                    }
                  }
                };
              }
            };
          }
        };
      }
    };
  }
};

fn s1_emit_llvm_ir(_source: Text) -> Result<Text, S1Diagnostic>
intent "Stage1 LLVM IR emitter (v0): parse+check then emit minimal LLVM IR subset"
evidence {
  trace "stage1.emit_llvm.v0";
  metrics [stage1_emit_llvm_calls];
}
{
  s1_emit_llvm_ir_real(_source)
};
