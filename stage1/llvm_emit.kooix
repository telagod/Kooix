import "../stdlib/prelude";
import "diag";
import "ast";
import "lexer";
import "parser";
import "resolver";
import "typecheck";

record S1CgEnvBind { name: Text; llvm: Text; ty: Text; s1_ty: S1Type; };
record S1CgExprOut { text: Text; value: Text; ty: Text; s1_ty: Option<S1Type>; bb: Text; next_tmp: Int; };
record S1CgBlockOut { text: Text; env: List<S1CgEnvBind>; bb: Text; next_tmp: Int; };
record S1CgStrConst { lit: Text; global: Text; n: Int; };

fn s1_cg_s1_type_prim(name: Text) -> S1Type {
  let seg_tail: List<Text> = Nil;
  let segs: List<Text> = Cons(ListCons<Text> { head: name; tail: seg_tail; });
  let path: S1Path = S1Path { segments: segs; };
  let args: List<S1Type> = Nil;
  S1Type { path: path; args: args; }
};

fn s1_cg_s1_type_option_int() -> S1Type {
  s1_cg_s1_type_option(s1_cg_s1_type_prim("Int"))
};

fn s1_cg_s1_type_option_text() -> S1Type {
  s1_cg_s1_type_option(s1_cg_s1_type_prim("Text"))
};

fn s1_cg_s1_type_option(payload: S1Type) -> S1Type {
  let seg_tail: List<Text> = Nil;
  let segs: List<Text> = Cons(ListCons<Text> { head: "Option"; tail: seg_tail; });
  let path: S1Path = S1Path { segments: segs; };
  let args_tail: List<S1Type> = Nil;
  let args: List<S1Type> = Cons(ListCons<S1Type> { head: payload; tail: args_tail; });
  S1Type { path: path; args: args; }
};

fn s1_cg_s1_type_result(ok_ty: S1Type, err_ty: S1Type) -> S1Type {
  let seg_tail: List<Text> = Nil;
  let segs: List<Text> = Cons(ListCons<Text> { head: "Result"; tail: seg_tail; });
  let path: S1Path = S1Path { segments: segs; };
  let args0_tail: List<S1Type> = Nil;
  let args0: List<S1Type> = Cons(ListCons<S1Type> { head: ok_ty; tail: args0_tail; });
  let args: List<S1Type> = Cons(ListCons<S1Type> { head: err_ty; tail: args0; });
  // Note: we build args in reverse then fix order below (small lists, simple).
  let out: List<S1Type> = Nil;
  let cur: List<S1Type> = args;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => { out = Cons(ListCons<S1Type> { head: c0.head; tail: out; }); cur = c0.tail; 0 };
    }
  };
  S1Type { path: path; args: out; }
};

fn s1_cg_s1_ty_some(t: S1Type) -> Option<S1Type> {
  let out: Option<S1Type> = Some(t);
  out
};

fn s1_cg_s1_ty_none() -> Option<S1Type> {
  let out: Option<S1Type> = None;
  out
};

fn s1_cg_type_is_plain_int(ty: S1Type) -> Bool {
  let ok: Bool = false;
  match ty.args {
    Nil => {
      match s1_cg_path_single_name(ty.path) {
        Some(name) => {
          if name == "Int" { ok = true; 0 } else { 0 };
          0
        };
        _ => 0;
      };
      0
    };
    _ => 0;
  };
  ok
};

fn s1_cg_type_is_plain_bool(ty: S1Type) -> Bool {
  let ok: Bool = false;
  match ty.args {
    Nil => {
      match s1_cg_path_single_name(ty.path) {
        Some(name) => {
          if name == "Bool" { ok = true; 0 } else { 0 };
          0
        };
        _ => 0;
      };
      0
    };
    _ => 0;
  };
  ok
};

fn s1_cg_type_is_plain_text(ty: S1Type) -> Bool {
  let ok: Bool = false;
  match ty.args {
    Nil => {
      match s1_cg_path_single_name(ty.path) {
        Some(name) => {
          if name == "Text" { ok = true; 0 } else { 0 };
          0
        };
        _ => 0;
      };
      0
    };
    _ => 0;
  };
  ok
};

fn s1_cg_type_is_option_int(ty: S1Type) -> Bool {
  let ok: Bool = false;
  match s1_cg_path_single_name(ty.path) {
    Some(name) => {
      if name == "Option" {
        match ty.args {
          Cons(a0) => {
            match a0.tail {
              Nil => {
                if s1_cg_type_is_plain_int(a0.head) { ok = true; 0 } else { 0 };
                0
              };
              _ => 0;
            };
            0
          };
          _ => 0;
        };
        0
      } else { 0 };
      0
    };
    _ => 0;
  };
  ok
};

fn s1_cg_type_is_result(ty: S1Type) -> Bool {
  let ok: Bool = false;
  match s1_cg_path_single_name(ty.path) {
    Some(name) => {
      if name == "Result" {
        match ty.args {
          Cons(a0) => {
            match a0.tail {
              Cons(b0) => {
                match b0.tail {
                  Nil => { ok = true; 0 };
                  _ => 0;
                };
                0
              };
              _ => 0;
            };
            0
          };
          _ => 0;
        };
        0
      } else { 0 };
      0
    };
    _ => 0;
  };
  ok
};

fn s1_cg_block_supported(b: S1Block) -> Bool {
  let ok: Bool = true;
  let cur: List<S1Stmt> = b.stmts;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        match c0.head {
          Let(_l) => { cur = c0.tail; 0 };
          Assign(_a) => { cur = c0.tail; 0 };
          ExprStmt(_e) => { cur = c0.tail; 0 };
          While(w) => {
            if s1_cg_block_supported(w.body) == true {
              cur = c0.tail;
              0
            } else {
              ok = false;
              done = true;
              0
            }
          };
          Return(_r) => { ok = false; done = true; 0 };
        };
        0
      };
    }
  };
  ok
};

fn s1_cg_function_supported(f: S1Function) -> Bool {
  // v0 subset: no generics, Int-only params/ret.
  // Body supports:
  // - zero or more: `let` / assignment / `while` and expression statements
  // - trailing `result` expression (no `return` in v0 subset)
  let ok: Bool = true;

  match f.generics {
    Nil => 0;
    _ => { ok = false; 0 };
  };

  if ok == true {
    if s1_cg_type_is_plain_int(f.return_type) { 0 } else { ok = false; 0 };
    0
  } else { 0 };

  if ok == true {
    let curp: List<S1Param> = f.params;
    let donep: Bool = false;
    while donep == false {
      match curp {
        Nil => { donep = true; 0 };
        Cons(c0) => {
          if s1_cg_type_is_plain_int(c0.head.ty) { 0 } else { ok = false; donep = true; 0 };
          curp = c0.tail;
          0
        };
      }
    };
    0
  } else { 0 };

  if ok == true {
    match f.body {
      None => { ok = false; 0 };
      Some(b) => {
        if s1_cg_block_supported(b) == true { 0 } else { ok = false; 0 };

        if ok == true {
          match b.result {
            Some(_e) => 0;
            _ => { ok = false; 0 };
          };
          0
        } else { 0 };
        0
      };
    };
    0
  } else { 0 };

  ok
};

fn s1_cg_text_err(diag: S1Diagnostic) -> Result<Text, S1Diagnostic> {
  let r: Result<Text, S1Diagnostic> = Err(diag);
  r
};

fn s1_cg_text_ok(value: Text) -> Result<Text, S1Diagnostic> {
  let r: Result<Text, S1Diagnostic> = Ok(value);
  r
};

fn s1_cg_expr_err(diag: S1Diagnostic) -> Result<S1CgExprOut, S1Diagnostic> {
  let r: Result<S1CgExprOut, S1Diagnostic> = Err(diag);
  r
};

fn s1_cg_expr_ok(value: S1CgExprOut) -> Result<S1CgExprOut, S1Diagnostic> {
  let r: Result<S1CgExprOut, S1Diagnostic> = Ok(value);
  r
};

fn s1_cg_block_err(diag: S1Diagnostic) -> Result<S1CgBlockOut, S1Diagnostic> {
  let r: Result<S1CgBlockOut, S1Diagnostic> = Err(diag);
  r
};

fn s1_cg_block_ok(value: S1CgBlockOut) -> Result<S1CgBlockOut, S1Diagnostic> {
  let r: Result<S1CgBlockOut, S1Diagnostic> = Ok(value);
  r
};

fn s1_cg_err(message: Text) -> Result<Text, S1Diagnostic> {
  s1_cg_text_err(s1_diag(Error, 0, 0, message))
};

fn s1_cg_text_append(out: Text, s: Text) -> Text {
  text_concat(out, s)
};

fn s1_cg_line(out: Text, s: Text) -> Text {
  text_concat(text_concat(out, s), "\n")
};

fn s1_cg_path_single_name(path: S1Path) -> Option<Text> {
  let out: Option<Text> = None;
  match path.segments {
    Nil => 0;
    Cons(c0) => {
      match c0.tail {
        Nil => { out = Some(c0.head); 0 };
        _ => 0;
      };
      0
    };
  };
  out
};

fn s1_cg_path_last_name(path: S1Path) -> Option<Text> {
  let out: Option<Text> = None;
  let cur: List<Text> = path.segments;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        match c0.tail {
          Nil => { out = Some(c0.head); done = true; 0 };
          _ => { cur = c0.tail; 0 };
        };
        0
      };
    }
  };
  out
};

fn s1_cg_lookup_env(env: List<S1CgEnvBind>, name: Text) -> Option<S1CgEnvBind> {
  let out: Option<S1CgEnvBind> = None;
  let cur: List<S1CgEnvBind> = env;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        if c0.head.name == name {
          out = Some(c0.head);
          done = true;
          0
        } else {
          cur = c0.tail;
          0
        };
        0
      };
    }
  };
  out
};

fn s1_cg_build_env(params: List<S1Param>) -> List<S1CgEnvBind> {
  let acc: List<S1CgEnvBind> = Nil;
  let cur: List<S1Param> = params;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        let llvm: Text = text_concat("%", c0.head.name);
        let bind: S1CgEnvBind = S1CgEnvBind { name: c0.head.name; llvm: llvm; ty: "i64"; s1_ty: c0.head.ty; };
        acc = Cons(ListCons<S1CgEnvBind> { head: bind; tail: acc; });
        cur = c0.tail;
        0
      };
    }
  };

  // Reverse to preserve param order (small lists; simple impl).
  let out: List<S1CgEnvBind> = Nil;
  let cur2: List<S1CgEnvBind> = acc;
  let done2: Bool = false;
  while done2 == false {
    match cur2 {
      Nil => { done2 = true; 0 };
      Cons(c0) => {
        out = Cons(ListCons<S1CgEnvBind> { head: c0.head; tail: out; });
        cur2 = c0.tail;
        0
      };
    }
  };
  out
};

fn s1_cg_lookup_str_const(strs: List<S1CgStrConst>, lit: Text) -> Option<S1CgStrConst> {
  let out: Option<S1CgStrConst> = None;
  let cur: List<S1CgStrConst> = strs;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        if c0.head.lit == lit {
          out = Some(c0.head);
          done = true;
          0
        } else {
          cur = c0.tail;
          0
        };
        0
      };
    }
  };
  out
};

fn s1_cg_emit_expr_min(out: Text, env: List<S1CgEnvBind>, next_tmp: Int, bb: Text, strs: List<S1CgStrConst>, e: S1Expr) -> Result<S1CgExprOut, S1Diagnostic> {
  match e {
    IntLit(raw) => s1_cg_expr_ok(S1CgExprOut { text: out; value: raw; ty: "i64"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Int")); bb: bb; next_tmp: next_tmp; });
    BoolLit(v) => {
      let raw: Text = "0";
      if v == true { raw = "1"; 0 } else { 0 };
      s1_cg_expr_ok(S1CgExprOut { text: out; value: raw; ty: "i1"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Bool")); bb: bb; next_tmp: next_tmp; })
    };
    StringLit(raw) => {
      match s1_cg_lookup_str_const(strs, raw) {
        None => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: internal error: missing string literal constant"));
        Some(sc) => {
          let tmp_id: Text = int_to_text(next_tmp);
          let tmp: Text = text_concat("%t", tmp_id);
          let n_txt: Text = int_to_text(sc.n);
          let arr_ty: Text = text_concat(text_concat("[", n_txt), " x i8]");
          let head: Text = text_concat(text_concat(text_concat(text_concat("  ", tmp), " = getelementptr inbounds "), arr_ty), text_concat(text_concat(", ", arr_ty), "* "));
          let tail: Text = text_concat(text_concat(sc.global, ", i64 0"), ", i64 0");
          let out2: Text = s1_cg_line(out, text_concat(head, tail));
          s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: "i8*"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Text")); bb: bb; next_tmp: next_tmp + 1; })
        };
      }
    };
    Path(p) => {
      match s1_cg_path_single_name(p) {
        None => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: multi-segment path not supported"));
        Some(name) => {
          match s1_cg_lookup_env(env, name) {
            None => s1_cg_expr_err(s1_diag(Error, 0, 0, text_concat("codegen: unknown variable ", name)));
            Some(v) => {
              let tmp_id: Text = int_to_text(next_tmp);
              let tmp: Text = text_concat("%t", tmp_id);
              let inst1: Text = text_concat(text_concat(text_concat(text_concat("  ", tmp), " = load "), v.ty), text_concat(text_concat(", ", v.ty), text_concat("* ", v.llvm)));
              let out2: Text = s1_cg_line(out, inst1);
              s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: v.ty; s1_ty: s1_cg_s1_ty_some(v.s1_ty); bb: bb; next_tmp: next_tmp + 1; })
            };
          }
        };
      }
    };
    Binary(b) => {
      match b.op {
        Add => {
          let l_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(out, env, next_tmp, bb, strs, b.left);
          match l_r {
            Err(e1) => s1_cg_expr_err(e1);
            Ok(l) => {
              let r_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(l.text, env, l.next_tmp, l.bb, strs, b.right);
              match r_r {
                Err(e2) => s1_cg_expr_err(e2);
                Ok(r) => {
                  if l.ty == "i64" {
                    if r.ty == "i64" {
                      let tmp_id: Text = int_to_text(r.next_tmp);
                      let tmp: Text = text_concat("%t", tmp_id);
                      let inst: Text = text_concat(text_concat(text_concat(text_concat("  ", tmp), " = add i64 "), l.value), text_concat(", ", r.value));
                      let out2: Text = s1_cg_line(r.text, inst);
                      s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: "i64"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Int")); bb: r.bb; next_tmp: r.next_tmp + 1; })
                    } else {
                      s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: add expects i64 operands"))
                    }
                  } else {
                    s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: add expects i64 operands"))
                  }
                };
              }
            };
          }
        };
        Equals => {
          let l_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(out, env, next_tmp, bb, strs, b.left);
          match l_r {
            Err(e1) => s1_cg_expr_err(e1);
            Ok(l) => {
              let r_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(l.text, env, l.next_tmp, l.bb, strs, b.right);
              match r_r {
                Err(e2) => s1_cg_expr_err(e2);
                Ok(r) => {
                  if l.ty == r.ty {
                    if l.ty == "i64" {
                      let tmp_id: Text = int_to_text(r.next_tmp);
                      let tmp: Text = text_concat("%t", tmp_id);
                      let inst: Text = text_concat(text_concat(text_concat(text_concat("  ", tmp), " = icmp eq i64 "), l.value), text_concat(", ", r.value));
                      let out2: Text = s1_cg_line(r.text, inst);
                      s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: "i1"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Bool")); bb: r.bb; next_tmp: r.next_tmp + 1; })
                    } else {
                      if l.ty == "i1" {
                        let tmp_id: Text = int_to_text(r.next_tmp);
                        let tmp: Text = text_concat("%t", tmp_id);
                        let inst: Text = text_concat(text_concat(text_concat(text_concat("  ", tmp), " = icmp eq i1 "), l.value), text_concat(", ", r.value));
                        let out2: Text = s1_cg_line(r.text, inst);
                        s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: "i1"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Bool")); bb: r.bb; next_tmp: r.next_tmp + 1; })
                      } else {
                        if l.ty == "i8*" {
                          let cmp_id: Text = int_to_text(r.next_tmp);
                          let cmp: Text = text_concat("%t", cmp_id);
                          let inst0: Text = text_concat(text_concat(text_concat("  ", cmp), " = call i32 @strcmp(i8* "), l.value);
                          let inst1: Text = text_concat(inst0, ", i8* ");
                          let inst2: Text = text_concat(inst1, r.value);
                          let inst_cmp: Text = text_concat(inst2, ")");
                          let out2: Text = s1_cg_line(r.text, inst_cmp);

                          let tmp_id: Text = int_to_text(r.next_tmp + 1);
                          let tmp: Text = text_concat("%t", tmp_id);
                          let inst_eq: Text = text_concat(text_concat(text_concat(text_concat("  ", tmp), " = icmp eq i32 "), cmp), ", 0");
                          let out3: Text = s1_cg_line(out2, inst_eq);
                          s1_cg_expr_ok(S1CgExprOut { text: out3; value: tmp; ty: "i1"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Bool")); bb: r.bb; next_tmp: r.next_tmp + 2; })
	                        } else {
	                          s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: == expects i64/i1/Text operands"))
	                        }
	                      }
	                    }
	                  } else {
	                    s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: == expects same-typed operands"))
	                  }
                };
              }
            };
          }
        };
        NotEquals => {
          let l_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(out, env, next_tmp, bb, strs, b.left);
          match l_r {
            Err(e1) => s1_cg_expr_err(e1);
            Ok(l) => {
              let r_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(l.text, env, l.next_tmp, l.bb, strs, b.right);
              match r_r {
                Err(e2) => s1_cg_expr_err(e2);
                Ok(r) => {
                  if l.ty == r.ty {
                    if l.ty == "i64" {
                      let tmp_id: Text = int_to_text(r.next_tmp);
                      let tmp: Text = text_concat("%t", tmp_id);
                      let inst: Text = text_concat(text_concat(text_concat(text_concat("  ", tmp), " = icmp ne i64 "), l.value), text_concat(", ", r.value));
                      let out2: Text = s1_cg_line(r.text, inst);
                      s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: "i1"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Bool")); bb: r.bb; next_tmp: r.next_tmp + 1; })
                    } else {
                      if l.ty == "i1" {
                        let tmp_id: Text = int_to_text(r.next_tmp);
                        let tmp: Text = text_concat("%t", tmp_id);
                        let inst: Text = text_concat(text_concat(text_concat(text_concat("  ", tmp), " = icmp ne i1 "), l.value), text_concat(", ", r.value));
                        let out2: Text = s1_cg_line(r.text, inst);
                        s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: "i1"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Bool")); bb: r.bb; next_tmp: r.next_tmp + 1; })
                      } else {
                        if l.ty == "i8*" {
                          let cmp_id: Text = int_to_text(r.next_tmp);
                          let cmp: Text = text_concat("%t", cmp_id);
                          let inst0: Text = text_concat(text_concat(text_concat("  ", cmp), " = call i32 @strcmp(i8* "), l.value);
                          let inst1: Text = text_concat(inst0, ", i8* ");
                          let inst2: Text = text_concat(inst1, r.value);
                          let inst_cmp: Text = text_concat(inst2, ")");
                          let out2: Text = s1_cg_line(r.text, inst_cmp);

                          let tmp_id: Text = int_to_text(r.next_tmp + 1);
                          let tmp: Text = text_concat("%t", tmp_id);
                          let inst_ne: Text = text_concat(text_concat(text_concat(text_concat("  ", tmp), " = icmp ne i32 "), cmp), ", 0");
                          let out3: Text = s1_cg_line(out2, inst_ne);
                          s1_cg_expr_ok(S1CgExprOut { text: out3; value: tmp; ty: "i1"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Bool")); bb: r.bb; next_tmp: r.next_tmp + 2; })
	                        } else {
	                          s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: != expects i64/i1/Text operands"))
	                        }
	                      }
	                    }
	                  } else {
	                    s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: != expects same-typed operands"))
	                  }
                };
              }
            };
          }
        };
      }
    };
    Call(c) => {
      // Only support `callee` as:
      // - single-segment path (direct function call)
      // - Option::Some/Option::None constructors (Option<Int> only)
      match c.callee {
        Path(p) => {
          let is_option_ctor: Bool = false;
          let option_variant: Text = "";
          match p.segments {
            Cons(a0) => {
              // Accept either `Option::Some/Option::None` or unqualified `Some/None`.
              if a0.head == "Option" {
                match a0.tail {
                  Cons(b0) => {
                    match b0.tail {
                      Nil => { is_option_ctor = true; option_variant = b0.head; 0 };
                      _ => 0;
                    };
                    0
                  };
                  _ => 0;
                };
                0
              } else {
                match a0.tail {
                  Nil => {
                    if a0.head == "Some" { is_option_ctor = true; option_variant = "Some"; 0 } else { 0 };
                    if a0.head == "None" { is_option_ctor = true; option_variant = "None"; 0 } else { 0 };
                    0
                  };
                  _ => 0;
                };
                0
              };
              0
            };
            _ => 0;
          };

          if is_option_ctor == true {
            if option_variant == "None" {
              match c.args {
                Nil => {
                  let raw_id: Text = int_to_text(next_tmp);
                  let raw: Text = text_concat("%t", raw_id);
                  let out1: Text = s1_cg_line(out, text_concat(text_concat("  ", raw), " = call i8* @malloc(i64 16)"));
                  let ptr_id: Text = int_to_text(next_tmp + 1);
                  let ptr: Text = text_concat("%t", ptr_id);
                  let out2: Text = s1_cg_line(out1, text_concat(text_concat(text_concat("  ", ptr), " = bitcast i8* "), text_concat(raw, " to %Option*")));
                  let tagp_id: Text = int_to_text(next_tmp + 2);
                  let tagp: Text = text_concat("%t", tagp_id);
                  let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat("  ", tagp), " = getelementptr inbounds %Option, %Option* "), text_concat(ptr, ", i32 0, i32 0")));
                  let out4: Text = s1_cg_line(out3, text_concat("  store i8 1, i8* ", tagp));
                  let payp_id: Text = int_to_text(next_tmp + 3);
                  let payp: Text = text_concat("%t", payp_id);
                  let out5: Text = s1_cg_line(out4, text_concat(text_concat(text_concat("  ", payp), " = getelementptr inbounds %Option, %Option* "), text_concat(ptr, ", i32 0, i32 1")));
                  let out6: Text = s1_cg_line(out5, text_concat("  store i64 0, i64* ", payp));
                  s1_cg_expr_ok(S1CgExprOut { text: out6; value: ptr; ty: "%Option*"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_option_int()); bb: bb; next_tmp: next_tmp + 4; })
                };
                _ => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: Option::None expects no args"));
              }
            } else {
              if option_variant == "Some" {
                match c.args {
                  Cons(a0) => {
                    match a0.tail {
                      Nil => {
                        let ar: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(out, env, next_tmp, bb, strs, a0.head);
                        match ar {
                          Err(e1) => s1_cg_expr_err(e1);
                          Ok(av) => {
                            if av.ty == "i64" {
                              let raw_id: Text = int_to_text(av.next_tmp);
                              let raw: Text = text_concat("%t", raw_id);
                              let out1: Text = s1_cg_line(av.text, text_concat(text_concat("  ", raw), " = call i8* @malloc(i64 16)"));
                              let ptr_id: Text = int_to_text(av.next_tmp + 1);
                              let ptr: Text = text_concat("%t", ptr_id);
                              let out2: Text = s1_cg_line(out1, text_concat(text_concat(text_concat("  ", ptr), " = bitcast i8* "), text_concat(raw, " to %Option*")));
                              let tagp_id: Text = int_to_text(av.next_tmp + 2);
                              let tagp: Text = text_concat("%t", tagp_id);
                              let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat("  ", tagp), " = getelementptr inbounds %Option, %Option* "), text_concat(ptr, ", i32 0, i32 0")));
                              let out4: Text = s1_cg_line(out3, text_concat("  store i8 0, i8* ", tagp));
                              let payp_id: Text = int_to_text(av.next_tmp + 3);
                              let payp: Text = text_concat("%t", payp_id);
                              let out5: Text = s1_cg_line(out4, text_concat(text_concat(text_concat("  ", payp), " = getelementptr inbounds %Option, %Option* "), text_concat(ptr, ", i32 0, i32 1")));
                              let out6: Text = s1_cg_line(out5, text_concat(text_concat("  store i64 ", av.value), text_concat(", i64* ", payp)));
                              s1_cg_expr_ok(S1CgExprOut { text: out6; value: ptr; ty: "%Option*"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_option_int()); bb: bb; next_tmp: av.next_tmp + 4; })
                            } else {
                              s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: Option::Some expects Int payload in v0.4"))
                            }
                          };
                        }
                      };
                      _ => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: Option::Some expects one arg"));
                    }
                  };
                  _ => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: Option::Some expects one arg"));
                }
              } else {
                s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: unsupported Option variant in v0.4"))
              }
            }
          } else {
          match s1_cg_path_single_name(p) {
            None => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: callee path not supported"));
            Some(fname) => {
              // Evaluate args left-to-right.
              let args_text: Text = "";
              let out_acc: Text = out;
              let next_acc: Int = next_tmp;
              let cur: List<S1Expr> = c.args;
              let done: Bool = false;

              // Mutable accumulators.
              let at: Text = args_text;
              let ot: Text = out_acc;
              let nt: Int = next_acc;
              let bt: Text = bb;
              let first: Bool = true;
              let ok: Bool = true;
              let diag: S1Diagnostic = s1_diag(Error, 0, 0, "codegen: arg eval failed");
              let argc: Int = 0;
              let a_val: Text = "";
              let a_ty: Text = "";
              let b_val: Text = "";
              let b_ty: Text = "";
              let all_i64: Bool = true;

              while done == false {
                match cur {
                  Nil => { done = true; 0 };
                  Cons(c0) => {
                    let rr: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(ot, env, nt, bt, strs, c0.head);
                    match rr {
                      Err(e3) => {
                        ok = false;
                        diag = e3;
                        done = true;
                        0
                      };
                      Ok(r) => {
                        let piece: Text = text_concat(text_concat(r.ty, " "), r.value);
                        if first == true {
                          at = piece;
                          first = false;
                          0
                        } else {
                          at = text_concat(text_concat(at, ", "), piece);
                          0
                        };

                        if argc == 0 { a_val = r.value; a_ty = r.ty; 0 } else { 0 };
                        if argc == 1 { b_val = r.value; b_ty = r.ty; 0 } else { 0 };
                        argc = argc + 1;
                        if r.ty == "i64" { 0 } else { all_i64 = false; 0 };

                        ot = r.text;
                        nt = r.next_tmp;
                        bt = r.bb;
                        cur = c0.tail;
                        0
                      };
                    }
                    ;
                    0
                  };
                }
              };

              if ok == false {
                s1_cg_expr_err(diag)
              } else {
                if fname == "text_concat" {
                  if argc == 2 {
                    if a_ty == "i8*" {
                      if b_ty == "i8*" {
                        let tmp_id: Text = int_to_text(nt);
                        let tmp: Text = text_concat("%t", tmp_id);
                        let call_head: Text = text_concat(text_concat(text_concat("  ", tmp), " = call i8* @kx_text_concat"), "(");
                        let inst: Text = text_concat(call_head, text_concat(at, ")"));
                        let out2: Text = s1_cg_line(ot, inst);
                        s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: "i8*"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Text")); bb: bt; next_tmp: nt + 1; })
                      } else {
                        s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_concat expects (Text, Text)"))
                      }
                    } else {
                      s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_concat expects (Text, Text)"))
                    }
                  } else {
                    s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_concat expects (Text, Text)"))
                  }
                } else {
                  if fname == "int_to_text" {
                    if argc == 1 {
                      if a_ty == "i64" {
                        let tmp_id: Text = int_to_text(nt);
                        let tmp: Text = text_concat("%t", tmp_id);
                        let inst: Text = text_concat(
                          text_concat(text_concat(text_concat("  ", tmp), " = call i8* @kx_int_to_text(i64 "), a_val),
                          ")"
                        );
                        let out2: Text = s1_cg_line(ot, inst);
                        s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: "i8*"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Text")); bb: bt; next_tmp: nt + 1; })
                      } else {
                        s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: int_to_text expects (Int)"))
                      }
                    } else {
                      s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: int_to_text expects (Int)"))
                    }
                  } else {
                    if fname == "text_len" {
                      if argc == 1 {
                        if a_ty == "i8*" {
                          let tmp_id: Text = int_to_text(nt);
                          let tmp: Text = text_concat("%t", tmp_id);
                          let inst: Text = text_concat(
                            text_concat(text_concat(text_concat("  ", tmp), " = call i64 @strlen(i8* "), a_val),
                            ")"
                          );
                          let out2: Text = s1_cg_line(ot, inst);
                          s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: "i64"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Int")); bb: bt; next_tmp: nt + 1; })
                        } else {
                          s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_len expects (Text)"))
                        }
                      } else {
                        s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_len expects (Text)"))
                      }
                    } else {
                      if fname == "text_starts_with" {
                        if argc == 2 {
                          if a_ty == "i8*" {
                            if b_ty == "i8*" {
                          // Implemented in terms of strlen+memcmp; avoids out-of-bounds reads.
                          let plen_id: Text = int_to_text(nt);
                          let plen: Text = text_concat("%t", plen_id);
                          let inst_plen: Text = text_concat(
                            text_concat(text_concat(text_concat("  ", plen), " = call i64 @strlen(i8* "), b_val),
                            ")"
                          );
                          let out1: Text = s1_cg_line(ot, inst_plen);
	                          let slen_id: Text = int_to_text(nt + 1);
	                          let slen: Text = text_concat("%t", slen_id);
	                          let inst_slen: Text = text_concat(
	                            text_concat(text_concat(text_concat("  ", slen), " = call i64 @strlen(i8* "), a_val),
	                            ")"
	                          );
	                          let out2: Text = s1_cg_line(out1, inst_slen);
                          let ge_id: Text = int_to_text(nt + 2);
                          let ge: Text = text_concat("%t", ge_id);
                          let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat(text_concat("  ", ge), " = icmp uge i64 "), slen), text_concat(", ", plen)));

                          let slot_id: Text = int_to_text(nt + 3);
                          let slot: Text = text_concat("%t", slot_id);
                          let out4: Text = s1_cg_line(out3, text_concat(text_concat(text_concat("  ", slot), " = alloca "), "i1"));
                          let out5: Text = s1_cg_line(out4, text_concat("  store i1 0, i1* ", slot));

                          let ok_lbl: Text = text_concat("sw_ok", int_to_text(nt + 4));
                          let join_lbl: Text = text_concat("sw_join", int_to_text(nt + 5));
                          let br1: Text = text_concat(
                            text_concat(text_concat("  br i1 ", ge), text_concat(", label %", ok_lbl)),
                            text_concat(", label %", join_lbl)
                          );
                          let out6: Text = s1_cg_line(out5, br1);

	                          let out_ok_lbl: Text = s1_cg_line(out6, text_concat(ok_lbl, ":"));
	                          let cmp_id: Text = int_to_text(nt + 6);
	                          let cmp: Text = text_concat("%t", cmp_id);
	                          let inst_cmp0: Text = text_concat(text_concat("  ", cmp), " = call i32 @memcmp(i8* ");
	                          let inst_cmp1: Text = text_concat(inst_cmp0, a_val);
	                          let inst_cmp2: Text = text_concat(inst_cmp1, ", i8* ");
	                          let inst_cmp3: Text = text_concat(inst_cmp2, b_val);
	                          let inst_cmp4: Text = text_concat(inst_cmp3, ", i64 ");
	                          let inst_cmp5: Text = text_concat(inst_cmp4, plen);
	                          let inst_cmp: Text = text_concat(inst_cmp5, ")");
	                          let out7: Text = s1_cg_line(out_ok_lbl, inst_cmp);

                          let eq_id: Text = int_to_text(nt + 7);
                          let eq0: Text = text_concat("%t", eq_id);
                          let out8: Text = s1_cg_line(out7, text_concat(text_concat(text_concat(text_concat("  ", eq0), " = icmp eq i32 "), cmp), ", 0"));
                          let out9: Text = s1_cg_line(out8, text_concat("  store i1 ", text_concat(eq0, text_concat(", i1* ", slot))));
                          let out10: Text = s1_cg_line(out9, text_concat("  br label %", join_lbl));

                          let out_join_lbl: Text = s1_cg_line(out10, text_concat(join_lbl, ":"));
                          let outv_id: Text = int_to_text(nt + 8);
                          let outv: Text = text_concat("%t", outv_id);
                          let out11: Text = s1_cg_line(out_join_lbl, text_concat(text_concat(text_concat("  ", outv), " = load i1, i1* "), slot));

                          s1_cg_expr_ok(S1CgExprOut { text: out11; value: outv; ty: "i1"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Bool")); bb: join_lbl; next_tmp: nt + 9; })
                            } else {
                              s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_starts_with expects (Text, Text)"))
                            }
                          } else {
                            s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_starts_with expects (Text, Text)"))
                          }
                        } else {
                          s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_starts_with expects (Text, Text)"))
                        }
                      } else {
                        if fname == "text_byte_at" {
                          // Returns Option<Int>
                          if argc == 2 {
                            if a_ty == "i8*" {
                              if b_ty == "i64" {
                                let idx_neg_id: Text = int_to_text(nt);
                                let idx_neg: Text = text_concat("%t", idx_neg_id);
                                let out1: Text = s1_cg_line(ot, text_concat(text_concat(text_concat(text_concat("  ", idx_neg), " = icmp slt i64 "), b_val), ", 0"));
                                let len_id: Text = int_to_text(nt + 1);
                                let len: Text = text_concat("%t", len_id);
                                let out2: Text = s1_cg_line(out1, text_concat(text_concat(text_concat("  ", len), " = call i64 @strlen(i8* "), text_concat(a_val, ")")));
                                let idx_uge_id: Text = int_to_text(nt + 2);
                                let idx_uge: Text = text_concat("%t", idx_uge_id);
                                let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat(text_concat("  ", idx_uge), " = icmp uge i64 "), b_val), text_concat(", ", len)));
                                let oob_id: Text = int_to_text(nt + 3);
                                let oob: Text = text_concat("%t", oob_id);
                                let out4: Text = s1_cg_line(out3, text_concat(text_concat(text_concat(text_concat("  ", oob), " = or i1 "), idx_neg), text_concat(", ", idx_uge)));

                                let ok_lbl: Text = text_concat("tba_ok", int_to_text(nt + 5));
                                let none_lbl: Text = text_concat("tba_none", int_to_text(nt + 6));
                                let join_lbl: Text = text_concat("tba_join", int_to_text(nt + 7));

                                let slot_id: Text = int_to_text(nt + 4);
                                let slot: Text = text_concat("%t", slot_id);
                                let out5: Text = s1_cg_line(out4, text_concat(text_concat(text_concat("  ", slot), " = alloca "), "%Option*"));

                                let br0: Text = text_concat(
                                  text_concat(text_concat("  br i1 ", oob), text_concat(", label %", none_lbl)),
                                  text_concat(", label %", ok_lbl)
                                );
                                let out6: Text = s1_cg_line(out5, br0);

                                // ok: Some(byte)
                                let out_ok_lbl: Text = s1_cg_line(out6, text_concat(ok_lbl, ":"));
                                let gep_id: Text = int_to_text(nt + 5);
                                let gep: Text = text_concat("%t", gep_id);
                                let inst_gep: Text = text_concat(text_concat(text_concat("  ", gep), " = getelementptr inbounds i8, i8* "), text_concat(a_val, text_concat(", i64 ", b_val)));
                                let out7: Text = s1_cg_line(out_ok_lbl, inst_gep);
                                let b_id: Text = int_to_text(nt + 6);
                                let b: Text = text_concat("%t", b_id);
                                let out8: Text = s1_cg_line(out7, text_concat(text_concat(text_concat("  ", b), " = load i8, i8* "), gep));
                                let bz_id: Text = int_to_text(nt + 7);
                                let bz: Text = text_concat("%t", bz_id);
                                let out9: Text = s1_cg_line(out8, text_concat(text_concat(text_concat("  ", bz), " = zext i8 "), text_concat(b, " to i64")));

                                let raw_id: Text = int_to_text(nt + 8);
                                let raw: Text = text_concat("%t", raw_id);
                                let out10: Text = s1_cg_line(out9, text_concat(text_concat("  ", raw), " = call i8* @malloc(i64 16)"));
                                let ptr_id: Text = int_to_text(nt + 9);
                                let ptr: Text = text_concat("%t", ptr_id);
                                let out11: Text = s1_cg_line(out10, text_concat(text_concat(text_concat("  ", ptr), " = bitcast i8* "), text_concat(raw, " to %Option*")));
                                let tagp_id: Text = int_to_text(nt + 10);
                                let tagp: Text = text_concat("%t", tagp_id);
                                let out12: Text = s1_cg_line(out11, text_concat(text_concat(text_concat("  ", tagp), " = getelementptr inbounds %Option, %Option* "), text_concat(ptr, ", i32 0, i32 0")));
                                let out13: Text = s1_cg_line(out12, text_concat("  store i8 0, i8* ", tagp));
                                let payp_id: Text = int_to_text(nt + 11);
                                let payp: Text = text_concat("%t", payp_id);
                                let out14: Text = s1_cg_line(out13, text_concat(text_concat(text_concat("  ", payp), " = getelementptr inbounds %Option, %Option* "), text_concat(ptr, ", i32 0, i32 1")));
                                let out15: Text = s1_cg_line(out14, text_concat(text_concat("  store i64 ", bz), text_concat(", i64* ", payp)));
                                let out16: Text = s1_cg_line(out15, text_concat("  store %Option* ", text_concat(ptr, text_concat(", %Option** ", slot))));
                                let out17: Text = s1_cg_line(out16, text_concat("  br label %", join_lbl));

                                // none: None
                                let out_none_lbl: Text = s1_cg_line(out17, text_concat(none_lbl, ":"));
                                let raw2_id: Text = int_to_text(nt + 12);
                                let raw2: Text = text_concat("%t", raw2_id);
                                let out18: Text = s1_cg_line(out_none_lbl, text_concat(text_concat("  ", raw2), " = call i8* @malloc(i64 16)"));
                                let ptr2_id: Text = int_to_text(nt + 13);
                                let ptr2: Text = text_concat("%t", ptr2_id);
                                let out19: Text = s1_cg_line(out18, text_concat(text_concat(text_concat("  ", ptr2), " = bitcast i8* "), text_concat(raw2, " to %Option*")));
                                let tagp2_id: Text = int_to_text(nt + 14);
                                let tagp2: Text = text_concat("%t", tagp2_id);
                                let out20: Text = s1_cg_line(out19, text_concat(text_concat(text_concat("  ", tagp2), " = getelementptr inbounds %Option, %Option* "), text_concat(ptr2, ", i32 0, i32 0")));
                                let out21: Text = s1_cg_line(out20, text_concat("  store i8 1, i8* ", tagp2));
                                let payp2_id: Text = int_to_text(nt + 15);
                                let payp2: Text = text_concat("%t", payp2_id);
                                let out22: Text = s1_cg_line(out21, text_concat(text_concat(text_concat("  ", payp2), " = getelementptr inbounds %Option, %Option* "), text_concat(ptr2, ", i32 0, i32 1")));
                                let out23: Text = s1_cg_line(out22, text_concat("  store i64 0, i64* ", payp2));
                                let out24: Text = s1_cg_line(out23, text_concat("  store %Option* ", text_concat(ptr2, text_concat(", %Option** ", slot))));
                                let out25: Text = s1_cg_line(out24, text_concat("  br label %", join_lbl));

                                // join
                                let out_join_lbl: Text = s1_cg_line(out25, text_concat(join_lbl, ":"));
                                let outv_id: Text = int_to_text(nt + 16);
                                let outv: Text = text_concat("%t", outv_id);
                                let out26: Text = s1_cg_line(out_join_lbl, text_concat(text_concat(text_concat("  ", outv), " = load %Option*, %Option** "), slot));
                                s1_cg_expr_ok(S1CgExprOut { text: out26; value: outv; ty: "%Option*"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_option_int()); bb: join_lbl; next_tmp: nt + 17; })
                              } else {
                                s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_byte_at expects (Text, Int)"))
                              }
                            } else {
                              s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_byte_at expects (Text, Int)"))
                            }
                          } else {
                            s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: text_byte_at expects (Text, Int)"))
                          }
                        } else {
                        if fname == "host_load_source_map" {
                          if argc == 1 {
                            if a_ty == "i8*" {
                              let raw_id: Text = int_to_text(nt);
                              let raw: Text = text_concat("%t", raw_id);
                              let inst: Text = text_concat(text_concat("  ", raw), text_concat(" = call i8* @kx_host_load_source_map(i8* ", text_concat(a_val, ")")));
                              let out2: Text = s1_cg_line(ot, inst);
                              let cast_id: Text = int_to_text(nt + 1);
                              let cast: Text = text_concat("%t", cast_id);
                              let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat("  ", cast), " = bitcast i8* "), text_concat(raw, " to %Result*")));
                              let st: S1Type = s1_cg_s1_type_result(s1_cg_s1_type_prim("Text"), s1_cg_s1_type_prim("Text"));
                              s1_cg_expr_ok(S1CgExprOut { text: out3; value: cast; ty: "%Result*"; s1_ty: s1_cg_s1_ty_some(st); bb: bt; next_tmp: nt + 2; })
                            } else {
                              s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: host_load_source_map expects (Text)"))
                            }
                          } else {
                            s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: host_load_source_map expects (Text)"))
                          }
                        } else {
                          if fname == "host_write_file" {
                            if argc == 2 {
                              if a_ty == "i8*" {
                                if b_ty == "i8*" {
                                  let raw_id: Text = int_to_text(nt);
                                  let raw: Text = text_concat("%t", raw_id);
                                  let inst: Text = text_concat(text_concat("  ", raw), text_concat(" = call i8* @kx_host_write_file(i8* ", text_concat(a_val, text_concat(", i8* ", text_concat(b_val, ")")))));
                                  let out2: Text = s1_cg_line(ot, inst);
                                  let cast_id: Text = int_to_text(nt + 1);
                                  let cast: Text = text_concat("%t", cast_id);
                                  let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat("  ", cast), " = bitcast i8* "), text_concat(raw, " to %Result*")));
                                  let st: S1Type = s1_cg_s1_type_result(s1_cg_s1_type_prim("Int"), s1_cg_s1_type_prim("Text"));
                                  s1_cg_expr_ok(S1CgExprOut { text: out3; value: cast; ty: "%Result*"; s1_ty: s1_cg_s1_ty_some(st); bb: bt; next_tmp: nt + 2; })
                                } else {
                                  s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: host_write_file expects (Text, Text)"))
                                }
                              } else {
                                s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: host_write_file expects (Text, Text)"))
                              }
                            } else {
                              s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: host_write_file expects (Text, Text)"))
                            }
                          } else {
                            if fname == "host_eprintln" {
                              if argc == 1 {
                                if a_ty == "i8*" {
                                  let inst: Text = text_concat(text_concat("  call void @kx_host_eprintln(i8* ", a_val), ")");
                                  let out2: Text = s1_cg_line(ot, inst);
                                  s1_cg_expr_ok(S1CgExprOut { text: out2; value: "0"; ty: "void"; s1_ty: s1_cg_s1_ty_none(); bb: bt; next_tmp: nt; })
                                } else {
                                  s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: host_eprintln expects (Text)"))
                                }
                              } else {
                                s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: host_eprintln expects (Text)"))
                              }
                            } else {
                              if all_i64 == true {
                                let tmp_id: Text = int_to_text(nt);
                                let tmp: Text = text_concat("%t", tmp_id);
                                let call_head: Text = text_concat(text_concat(text_concat("  ", tmp), " = call i64 @"), fname);
                                let inst: Text = text_concat(text_concat(call_head, "("), text_concat(at, ")"));
                                let out2: Text = s1_cg_line(ot, inst);
                                s1_cg_expr_ok(S1CgExprOut { text: out2; value: tmp; ty: "i64"; s1_ty: s1_cg_s1_ty_some(s1_cg_s1_type_prim("Int")); bb: bt; next_tmp: nt + 1; })
                              } else {
                                s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: call expects i64 args in v0"))
                              }
                            }
                          }
                        }
                        }
                      }
                    }
                  }
                }
              }
            };
          }
          }
        };
        _ => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: callee must be a path in v0"));
      }
    };
    If(i) => {
      let c_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(out, env, next_tmp, bb, strs, i.cond);
      match c_r {
        Err(e1) => s1_cg_expr_err(e1);
        Ok(c0) => {
          if c0.ty == "i1" {
            match i.else_block {
              None => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: if expression requires else branch in v0"));
              Some(else_b) => {
                match i.then_block.result {
                  None => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: if-then block has no value"));
                  Some(then_e) => {
                    match else_b.result {
                      None => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: if-else block has no value"));
                      Some(else_e) => {
                        // Allocate labels.
                        let then_id: Text = int_to_text(c0.next_tmp);
                        let then_lbl: Text = text_concat("then", then_id);
                        let else_id: Text = int_to_text(c0.next_tmp + 1);
                        let else_lbl: Text = text_concat("else", else_id);
                        let join_id: Text = int_to_text(c0.next_tmp + 2);
                        let join_lbl: Text = text_concat("join", join_id);
                        let nt0: Int = c0.next_tmp + 3;

                        let br1: Text = text_concat(text_concat("  br i1 ", c0.value), text_concat(text_concat(", label %", then_lbl), text_concat(", label %", else_lbl)));
                        let out_br: Text = s1_cg_line(c0.text, br1);

                        // then:
                        let out_then_lbl: Text = s1_cg_line(out_br, text_concat(then_lbl, ":"));
                        let tr: Result<S1CgBlockOut, S1Diagnostic> =
                          s1_cg_emit_stmt_list_min(out_then_lbl, env, nt0, then_lbl, strs, i.then_block.stmts);
                        match tr {
                          Err(e2) => s1_cg_expr_err(e2);
                          Ok(tb) => {
                            let t_r: Result<S1CgExprOut, S1Diagnostic> =
                              s1_cg_emit_expr_min(tb.text, tb.env, tb.next_tmp, tb.bb, strs, then_e);
                            match t_r {
                              Err(e3) => s1_cg_expr_err(e3);
                              Ok(t0) => {
                                let out_then_end: Text = s1_cg_line(t0.text, text_concat("  br label %", join_lbl));

                                // else:
                                let out_else_lbl: Text = s1_cg_line(out_then_end, text_concat(else_lbl, ":"));
                                let er: Result<S1CgBlockOut, S1Diagnostic> =
                                  s1_cg_emit_stmt_list_min(out_else_lbl, env, t0.next_tmp, else_lbl, strs, else_b.stmts);
                                match er {
                                  Err(e4) => s1_cg_expr_err(e4);
                                  Ok(eb) => {
                                    let e_r: Result<S1CgExprOut, S1Diagnostic> =
                                      s1_cg_emit_expr_min(eb.text, eb.env, eb.next_tmp, eb.bb, strs, else_e);
                                    match e_r {
                                      Err(e5) => s1_cg_expr_err(e5);
                                      Ok(e0) => {
                                        if e0.ty == t0.ty {
                                          if t0.ty == "i64" {
                                            let out_else_end: Text = s1_cg_line(e0.text, text_concat("  br label %", join_lbl));
                                            let out_join_lbl: Text = s1_cg_line(out_else_end, text_concat(join_lbl, ":"));
                                            let phi_id: Text = int_to_text(e0.next_tmp);
                                            let phi_tmp: Text = text_concat("%t", phi_id);
                                            let p1: Text = text_concat(text_concat(text_concat("  ", phi_tmp), " = phi "), text_concat(t0.ty, " "));
                                            let in1: Text = text_concat(text_concat("[ ", t0.value), text_concat(text_concat(", %", t0.bb), " ]"));
                                            let in2: Text = text_concat(text_concat("[ ", e0.value), text_concat(text_concat(", %", e0.bb), " ]"));
                                            let inst: Text = text_concat(text_concat(p1, in1), text_concat(", ", in2));
                                            let out_phi: Text = s1_cg_line(out_join_lbl, inst);
                                            s1_cg_expr_ok(S1CgExprOut { text: out_phi; value: phi_tmp; ty: t0.ty; s1_ty: t0.s1_ty; bb: join_lbl; next_tmp: e0.next_tmp + 1; })
                                          } else {
                                            if t0.ty == "i1" {
                                              let out_else_end: Text = s1_cg_line(e0.text, text_concat("  br label %", join_lbl));
                                              let out_join_lbl: Text = s1_cg_line(out_else_end, text_concat(join_lbl, ":"));
                                              let phi_id: Text = int_to_text(e0.next_tmp);
                                              let phi_tmp: Text = text_concat("%t", phi_id);
                                              let p1: Text = text_concat(text_concat(text_concat("  ", phi_tmp), " = phi "), text_concat(t0.ty, " "));
                                              let in1: Text = text_concat(text_concat("[ ", t0.value), text_concat(text_concat(", %", t0.bb), " ]"));
                                              let in2: Text = text_concat(text_concat("[ ", e0.value), text_concat(text_concat(", %", e0.bb), " ]"));
                                              let inst: Text = text_concat(text_concat(p1, in1), text_concat(", ", in2));
                                              let out_phi: Text = s1_cg_line(out_join_lbl, inst);
                                              s1_cg_expr_ok(S1CgExprOut { text: out_phi; value: phi_tmp; ty: t0.ty; s1_ty: t0.s1_ty; bb: join_lbl; next_tmp: e0.next_tmp + 1; })
                                            } else {
                                              s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: if branch type not supported in v0"))
                                            }
                                          }
                                        } else {
                                          s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: if branches must return same type in v0"))
                                        }
                                      };
                                    }
                                  };
                                }
                              };
                            }
                          };
                        }
                      };
                    }
                  };
                }
              };
            }
          } else {
            s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: if condition must be Bool (i1)"))
          }
        };
      }
    };
    Block(b) => {
      match b.result {
        None => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: block has no value"));
        Some(e2) => {
          let br: Result<S1CgBlockOut, S1Diagnostic> = s1_cg_emit_stmt_list_min(out, env, next_tmp, bb, strs, b.stmts);
          match br {
            Err(e3) => s1_cg_expr_err(e3);
            Ok(b0) => {
              // Block scope: use the extended env for the tail expression, but do not leak it to callers.
              let rr: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(b0.text, b0.env, b0.next_tmp, b0.bb, strs, e2);
              match rr {
                Err(e4) => s1_cg_expr_err(e4);
                Ok(r0) => {
                  s1_cg_expr_ok(S1CgExprOut { text: r0.text; value: r0.value; ty: r0.ty; s1_ty: r0.s1_ty; bb: r0.bb; next_tmp: r0.next_tmp; })
                };
              }
            };
          }
        };
      }
    };
    Match(m) => {
      // v0.4: minimal enum match lowering for Option<Int> and Result<T, E>.
      // Current limitation: only supports exactly 2 arms.
      let scr_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(out, env, next_tmp, bb, strs, m.scrutinee);
      match scr_r {
        Err(e0) => s1_cg_expr_err(e0);
        Ok(s0) => {
          match m.arms {
            Nil => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: match has no arms"));
            Cons(a0) => {
              match a0.tail {
                Nil => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: match must have 2 arms in v0.4"));
                Cons(a1) => {
                  match a1.tail {
                    Nil => {
                      let arm0: S1MatchArm = a0.head;
                      let arm1: S1MatchArm = a1.head;

                      // Determine enum kind + payload types from scrutinee's S1Type.
                      let enum_name: Text = "";
                      let ok_payload_s1: S1Type = s1_cg_s1_type_prim("Int");
                      let err_payload_s1: S1Type = s1_cg_s1_type_prim("Int");
                      let have_enum: Bool = false;

                      match s0.s1_ty {
                        None => 0;
                        Some(st0) => {
                          if s1_cg_type_is_option_int(st0) == true {
                            enum_name = "Option";
                            ok_payload_s1 = s1_cg_s1_type_prim("Int");
                            err_payload_s1 = s1_cg_s1_type_prim("Int");
                            have_enum = true;
                            0
                          } else {
                            if s1_cg_type_is_result(st0) == true {
                              enum_name = "Result";
                              // Extract Result<T, E> args.
                              match st0.args {
                                Cons(r0) => {
                                  match r0.tail {
                                    Cons(r1) => {
                                      match r1.tail {
                                        Nil => { ok_payload_s1 = r0.head; err_payload_s1 = r1.head; have_enum = true; 0 };
                                        _ => 0;
                                      };
                                      0
                                    };
                                    _ => 0;
                                  };
                                  0
                                };
                                _ => 0;
                              };
                              0
                            } else { 0 };
                            0
                          };
                          0
                        };
                      };

                      if have_enum == false {
                        s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: match scrutinee must be Option<Int> or Result<T,E> in v0.4"))
                      } else {
                        // Parse patterns.
                        let a0_wild: Bool = false;
                        let a0_vname: Text = "";
                        let a0_bind_kind: Text = "none"; // none | wild | bind
                        let a0_bind_name: Text = "";
                        match arm0.pat {
                          Wildcard => { a0_wild = true; 0 };
                          Path(p0) => {
                            match s1_cg_path_last_name(p0) {
                              None => 0;
                              Some(n0) => { a0_vname = n0; 0 };
                            };
                            0
                          };
                          Variant(vp0) => {
                            match s1_cg_path_last_name(vp0.path) {
                              None => 0;
                              Some(n0) => { a0_vname = n0; 0 };
                            };
                            match vp0.payload {
                              None => 0;
                              Some(pl0) => {
                                match pl0 {
                                  Bind(nm) => { a0_bind_kind = "bind"; a0_bind_name = nm; 0 };
                                  Wildcard => { a0_bind_kind = "wild"; 0 };
                                };
                                0
                              };
                            };
                            0
                          };
                        };

                        let a1_wild: Bool = false;
                        let a1_vname: Text = "";
                        let a1_bind_kind: Text = "none";
                        let a1_bind_name: Text = "";
                        match arm1.pat {
                          Wildcard => { a1_wild = true; 0 };
                          Path(p1) => {
                            match s1_cg_path_last_name(p1) {
                              None => 0;
                              Some(n1) => { a1_vname = n1; 0 };
                            };
                            0
                          };
                          Variant(vp1) => {
                            match s1_cg_path_last_name(vp1.path) {
                              None => 0;
                              Some(n1) => { a1_vname = n1; 0 };
                            };
                            match vp1.payload {
                              None => 0;
                              Some(pl1) => {
                                match pl1 {
                                  Bind(nm) => { a1_bind_kind = "bind"; a1_bind_name = nm; 0 };
                                  Wildcard => { a1_bind_kind = "wild"; 0 };
                                };
                                0
                              };
                            };
                            0
                          };
                        };

                        // Map variant names to tags.
                        let a0_has_tag: Bool = false;
                        let a0_tag: Text = "0";
                        if a0_wild == false {
                          if enum_name == "Option" {
                            if a0_vname == "Some" { a0_has_tag = true; a0_tag = "0"; 0 } else { 0 };
                            if a0_vname == "None" { a0_has_tag = true; a0_tag = "1"; 0 } else { 0 };
                            0
                          } else {
                            if a0_vname == "Ok" { a0_has_tag = true; a0_tag = "0"; 0 } else { 0 };
                            if a0_vname == "Err" { a0_has_tag = true; a0_tag = "1"; 0 } else { 0 };
                            0
                          };
                          0
                        } else { 0 };

                        let a1_has_tag: Bool = false;
                        let a1_tag: Text = "0";
                        if a1_wild == false {
                          if enum_name == "Option" {
                            if a1_vname == "Some" { a1_has_tag = true; a1_tag = "0"; 0 } else { 0 };
                            if a1_vname == "None" { a1_has_tag = true; a1_tag = "1"; 0 } else { 0 };
                            0
                          } else {
                            if a1_vname == "Ok" { a1_has_tag = true; a1_tag = "0"; 0 } else { 0 };
                            if a1_vname == "Err" { a1_has_tag = true; a1_tag = "1"; 0 } else { 0 };
                            0
                          };
                          0
                        } else { 0 };

                        if a0_wild == false {
                          if a0_has_tag == false {
                            s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: unsupported match arm pattern in v0.4"))
                          } else {
                            if a1_wild == false {
                              if a1_has_tag == false {
                                s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: unsupported match arm pattern in v0.4"))
                              } else {
                                // ok
                                let arm0_lbl: Text = text_concat("match_a0", int_to_text(s0.next_tmp));
                                let arm1_lbl: Text = text_concat("match_a1", int_to_text(s0.next_tmp + 1));
                                let join_lbl: Text = text_concat("match_join", int_to_text(s0.next_tmp + 2));
                                let nt0: Int = s0.next_tmp + 3;

                                let en_ty: Text = text_concat("%", enum_name);
                                let en_ptr_ty: Text = text_concat(en_ty, "*");

                                // Load tag.
                                let tagp_id: Text = int_to_text(nt0);
                                let tagp: Text = text_concat("%t", tagp_id);
                                let out1: Text = s1_cg_line(s0.text, text_concat(text_concat(text_concat("  ", tagp), " = getelementptr inbounds "), text_concat(text_concat(en_ty, ", "), text_concat(en_ptr_ty, text_concat(" ", text_concat(s0.value, ", i32 0, i32 0"))))));
                                let tag8_id: Text = int_to_text(nt0 + 1);
                                let tag8: Text = text_concat("%t", tag8_id);
                                let out2: Text = s1_cg_line(out1, text_concat(text_concat(text_concat("  ", tag8), " = load i8, i8* "), tagp));
                                let is_a0_id: Text = int_to_text(nt0 + 2);
                                let is_a0: Text = text_concat("%t", is_a0_id);
                                let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat(text_concat("  ", is_a0), " = icmp eq i8 "), tag8), text_concat(", ", a0_tag)));
                                let br0: Text = text_concat(
                                  text_concat(text_concat("  br i1 ", is_a0), text_concat(", label %", arm0_lbl)),
                                  text_concat(", label %", arm1_lbl)
                                );
                                let out4: Text = s1_cg_line(out3, br0);

                                // arm0:
                                let out5: Text = s1_cg_line(out4, text_concat(arm0_lbl, ":"));
                                let env0: List<S1CgEnvBind> = env;
                                let ot0: Text = out5;
                                let nt_arm0: Int = nt0 + 3;
                                let env_arm0: List<S1CgEnvBind> = env0;
                                let ot_arm0: Text = ot0;
                                let nt0a: Int = nt_arm0;

                                if a0_bind_kind == "bind" {
                                  // Load payload word.
                                  let payp_id: Text = int_to_text(nt0a);
                                  let payp: Text = text_concat("%t", payp_id);
                                  ot_arm0 = s1_cg_line(ot_arm0, text_concat(text_concat(text_concat("  ", payp), " = getelementptr inbounds "), text_concat(text_concat(en_ty, ", "), text_concat(en_ptr_ty, text_concat(" ", text_concat(s0.value, ", i32 0, i32 1"))))));
                                  let payw_id: Text = int_to_text(nt0a + 1);
                                  let payw: Text = text_concat("%t", payw_id);
                                  ot_arm0 = s1_cg_line(ot_arm0, text_concat(text_concat(text_concat("  ", payw), " = load i64, i64* "), payp));

                                  // Determine binder LLVM type.
                                  let bind_llvm_ty: Text = "i64";
                                  let bind_s1_ty: S1Type = s1_cg_s1_type_prim("Int");
                                  if enum_name == "Option" {
                                    bind_llvm_ty = "i64";
                                    bind_s1_ty = s1_cg_s1_type_prim("Int");
                                    0
                                  } else {
                                    // Result: Ok uses ok_payload_s1; Err uses err_payload_s1.
                                    let pl: S1Type = ok_payload_s1;
                                    if a0_tag == "1" { pl = err_payload_s1; 0 } else { 0 };
                                    if s1_cg_type_is_plain_int(pl) == true { bind_llvm_ty = "i64"; bind_s1_ty = s1_cg_s1_type_prim("Int"); 0 } else { 0 };
                                    if s1_cg_type_is_plain_text(pl) == true { bind_llvm_ty = "i8*"; bind_s1_ty = s1_cg_s1_type_prim("Text"); 0 } else { 0 };
                                    0
                                  };

                                  let bind_val: Text = payw;
                                  let nt_adj: Int = nt0a;
                                  if bind_llvm_ty == "i8*" {
                                    let cast_id: Text = int_to_text(nt0a + 2);
                                    let cast: Text = text_concat("%t", cast_id);
                                    ot_arm0 = s1_cg_line(ot_arm0, text_concat(text_concat(text_concat(text_concat("  ", cast), " = inttoptr i64 "), payw), " to i8*"));
                                    bind_val = cast;
                                    nt_adj = nt0a + 1;
                                    0
                                  } else { 0 };

                                  let slot_id: Text = int_to_text(nt_adj + 2);
                                  let slot: Text = text_concat("%t", slot_id);
                                  ot_arm0 = s1_cg_line(ot_arm0, text_concat(text_concat(text_concat("  ", slot), " = alloca "), bind_llvm_ty));
                                  ot_arm0 = s1_cg_line(ot_arm0, text_concat(text_concat(text_concat("  store ", bind_llvm_ty), text_concat(" ", bind_val)), text_concat(text_concat(", ", bind_llvm_ty), text_concat("* ", slot))));
                                  let bind0: S1CgEnvBind = S1CgEnvBind { name: a0_bind_name; llvm: slot; ty: bind_llvm_ty; s1_ty: bind_s1_ty; };
                                  env_arm0 = Cons(ListCons<S1CgEnvBind> { head: bind0; tail: env_arm0; });
                                  nt0a = nt_adj + 3;
                                  0
                                } else { 0 };

                                let e0_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(ot_arm0, env_arm0, nt0a, arm0_lbl, strs, arm0.value);
                                match e0_r {
                                  Err(ea0) => s1_cg_expr_err(ea0);
                                  Ok(v0) => {
                                    let out_arm0_end: Text = s1_cg_line(v0.text, text_concat("  br label %", join_lbl));

                                    // arm1:
                                    let out6: Text = s1_cg_line(out_arm0_end, text_concat(arm1_lbl, ":"));
                                    let nt1a: Int = v0.next_tmp;
                                    let env_arm1: List<S1CgEnvBind> = env;
                                    let ot_arm1: Text = out6;
                                    let nt1: Int = nt1a;

                                    if a1_bind_kind == "bind" {
                                      let payp_id: Text = int_to_text(nt1);
                                      let payp: Text = text_concat("%t", payp_id);
                                      ot_arm1 = s1_cg_line(ot_arm1, text_concat(text_concat(text_concat("  ", payp), " = getelementptr inbounds "), text_concat(text_concat(en_ty, ", "), text_concat(en_ptr_ty, text_concat(" ", text_concat(s0.value, ", i32 0, i32 1"))))));
                                      let payw_id: Text = int_to_text(nt1 + 1);
                                      let payw: Text = text_concat("%t", payw_id);
                                      ot_arm1 = s1_cg_line(ot_arm1, text_concat(text_concat(text_concat("  ", payw), " = load i64, i64* "), payp));

                                      let bind_llvm_ty: Text = "i64";
                                      let bind_s1_ty: S1Type = s1_cg_s1_type_prim("Int");
                                      if enum_name == "Option" {
                                        bind_llvm_ty = "i64";
                                        bind_s1_ty = s1_cg_s1_type_prim("Int");
                                        0
                                      } else {
                                        let pl: S1Type = ok_payload_s1;
                                        if a1_tag == "1" { pl = err_payload_s1; 0 } else { 0 };
                                        if s1_cg_type_is_plain_int(pl) == true { bind_llvm_ty = "i64"; bind_s1_ty = s1_cg_s1_type_prim("Int"); 0 } else { 0 };
                                        if s1_cg_type_is_plain_text(pl) == true { bind_llvm_ty = "i8*"; bind_s1_ty = s1_cg_s1_type_prim("Text"); 0 } else { 0 };
                                        0
                                      };

                                      let bind_val: Text = payw;
                                      let nt_adj: Int = nt1;
                                      if bind_llvm_ty == "i8*" {
                                        let cast_id: Text = int_to_text(nt1 + 2);
                                        let cast: Text = text_concat("%t", cast_id);
                                        ot_arm1 = s1_cg_line(ot_arm1, text_concat(text_concat(text_concat(text_concat("  ", cast), " = inttoptr i64 "), payw), " to i8*"));
                                        bind_val = cast;
                                        nt_adj = nt1 + 1;
                                        0
                                      } else { 0 };

                                      let slot_id: Text = int_to_text(nt_adj + 2);
                                      let slot: Text = text_concat("%t", slot_id);
                                      ot_arm1 = s1_cg_line(ot_arm1, text_concat(text_concat(text_concat("  ", slot), " = alloca "), bind_llvm_ty));
                                      ot_arm1 = s1_cg_line(ot_arm1, text_concat(text_concat(text_concat("  store ", bind_llvm_ty), text_concat(" ", bind_val)), text_concat(text_concat(", ", bind_llvm_ty), text_concat("* ", slot))));
                                      let bind1: S1CgEnvBind = S1CgEnvBind { name: a1_bind_name; llvm: slot; ty: bind_llvm_ty; s1_ty: bind_s1_ty; };
                                      env_arm1 = Cons(ListCons<S1CgEnvBind> { head: bind1; tail: env_arm1; });
                                      nt1 = nt_adj + 3;
                                      0
                                    } else { 0 };

                                    let e1_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(ot_arm1, env_arm1, nt1, arm1_lbl, strs, arm1.value);
                                    match e1_r {
                                      Err(ea1) => s1_cg_expr_err(ea1);
                                      Ok(v1) => {
                                        if v1.ty == v0.ty {
                                          let out_arm1_end: Text = s1_cg_line(v1.text, text_concat("  br label %", join_lbl));
                                          let out_join: Text = s1_cg_line(out_arm1_end, text_concat(join_lbl, ":"));
                                          let phi_id: Text = int_to_text(v1.next_tmp);
                                          let phi: Text = text_concat("%t", phi_id);
                                          if v0.ty == "i64" {
                                            let p1: Text = text_concat(text_concat(text_concat("  ", phi), " = phi i64 "), "");
                                            let in0: Text = text_concat(text_concat("[ ", v0.value), text_concat(text_concat(", %", v0.bb), " ]"));
                                            let in1: Text = text_concat(text_concat("[ ", v1.value), text_concat(text_concat(", %", v1.bb), " ]"));
                                            let inst: Text = text_concat(text_concat(p1, in0), text_concat(", ", in1));
                                            let out_phi: Text = s1_cg_line(out_join, inst);
                                            s1_cg_expr_ok(S1CgExprOut { text: out_phi; value: phi; ty: "i64"; s1_ty: v0.s1_ty; bb: join_lbl; next_tmp: v1.next_tmp + 1; })
                                          } else {
                                            if v0.ty == "i1" {
                                              let p1: Text = text_concat(text_concat(text_concat("  ", phi), " = phi i1 "), "");
                                              let in0: Text = text_concat(text_concat("[ ", v0.value), text_concat(text_concat(", %", v0.bb), " ]"));
                                              let in1: Text = text_concat(text_concat("[ ", v1.value), text_concat(text_concat(", %", v1.bb), " ]"));
                                              let inst: Text = text_concat(text_concat(p1, in0), text_concat(", ", in1));
                                              let out_phi: Text = s1_cg_line(out_join, inst);
                                              s1_cg_expr_ok(S1CgExprOut { text: out_phi; value: phi; ty: "i1"; s1_ty: v0.s1_ty; bb: join_lbl; next_tmp: v1.next_tmp + 1; })
                                            } else {
                                              if v0.ty == "i8*" {
                                                let p1: Text = text_concat(text_concat(text_concat("  ", phi), " = phi i8* "), "");
                                                let in0: Text = text_concat(text_concat("[ ", v0.value), text_concat(text_concat(", %", v0.bb), " ]"));
                                                let in1: Text = text_concat(text_concat("[ ", v1.value), text_concat(text_concat(", %", v1.bb), " ]"));
                                                let inst: Text = text_concat(text_concat(p1, in0), text_concat(", ", in1));
                                                let out_phi: Text = s1_cg_line(out_join, inst);
                                                s1_cg_expr_ok(S1CgExprOut { text: out_phi; value: phi; ty: "i8*"; s1_ty: v0.s1_ty; bb: join_lbl; next_tmp: v1.next_tmp + 1; })
                                              } else {
                                                s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: match result type not supported in v0.4"))
                                              }
                                            }
                                          }
                                        } else {
                                          s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: match arms must return same type in v0.4"))
                                        }
                                      };
                                    }
                                  };
                                }
                              }
                            } else {
                              // a1 is wildcard, still ok.
                              let arm0_lbl: Text = text_concat("match_a0", int_to_text(s0.next_tmp));
                              let arm1_lbl: Text = text_concat("match_a1", int_to_text(s0.next_tmp + 1));
                              let join_lbl: Text = text_concat("match_join", int_to_text(s0.next_tmp + 2));
                              let nt0: Int = s0.next_tmp + 3;

                              let en_ty: Text = text_concat("%", enum_name);
                              let en_ptr_ty: Text = text_concat(en_ty, "*");

                              let tagp_id: Text = int_to_text(nt0);
                              let tagp: Text = text_concat("%t", tagp_id);
                              let out1: Text = s1_cg_line(s0.text, text_concat(text_concat(text_concat("  ", tagp), " = getelementptr inbounds "), text_concat(text_concat(en_ty, ", "), text_concat(en_ptr_ty, text_concat(" ", text_concat(s0.value, ", i32 0, i32 0"))))));
                              let tag8_id: Text = int_to_text(nt0 + 1);
                              let tag8: Text = text_concat("%t", tag8_id);
                              let out2: Text = s1_cg_line(out1, text_concat(text_concat(text_concat("  ", tag8), " = load i8, i8* "), tagp));
                              let is_a0_id: Text = int_to_text(nt0 + 2);
                              let is_a0: Text = text_concat("%t", is_a0_id);
                              let out3: Text = s1_cg_line(out2, text_concat(text_concat(text_concat(text_concat("  ", is_a0), " = icmp eq i8 "), tag8), text_concat(", ", a0_tag)));
                              let br0: Text = text_concat(
                                text_concat(text_concat("  br i1 ", is_a0), text_concat(", label %", arm0_lbl)),
                                text_concat(", label %", arm1_lbl)
                              );
                              let out4: Text = s1_cg_line(out3, br0);

                              let out5: Text = s1_cg_line(out4, text_concat(arm0_lbl, ":"));
                              let e0_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(out5, env, nt0 + 3, arm0_lbl, strs, arm0.value);
                              match e0_r {
                                Err(ea0) => s1_cg_expr_err(ea0);
                                Ok(v0) => {
                                  let out_arm0_end: Text = s1_cg_line(v0.text, text_concat("  br label %", join_lbl));
                                  let out6: Text = s1_cg_line(out_arm0_end, text_concat(arm1_lbl, ":"));
                                  let e1_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(out6, env, v0.next_tmp, arm1_lbl, strs, arm1.value);
                                  match e1_r {
                                    Err(ea1) => s1_cg_expr_err(ea1);
                                    Ok(v1) => {
                                      if v1.ty == v0.ty {
                                        let out_arm1_end: Text = s1_cg_line(v1.text, text_concat("  br label %", join_lbl));
                                        let out_join: Text = s1_cg_line(out_arm1_end, text_concat(join_lbl, ":"));
                                        let phi_id: Text = int_to_text(v1.next_tmp);
                                        let phi: Text = text_concat("%t", phi_id);
                                        if v0.ty == "i64" {
                                          let p1: Text = text_concat(text_concat(text_concat("  ", phi), " = phi i64 "), "");
                                          let in0: Text = text_concat(text_concat("[ ", v0.value), text_concat(text_concat(", %", v0.bb), " ]"));
                                          let in1: Text = text_concat(text_concat("[ ", v1.value), text_concat(text_concat(", %", v1.bb), " ]"));
                                          let inst: Text = text_concat(text_concat(p1, in0), text_concat(", ", in1));
                                          let out_phi: Text = s1_cg_line(out_join, inst);
                                          s1_cg_expr_ok(S1CgExprOut { text: out_phi; value: phi; ty: "i64"; s1_ty: v0.s1_ty; bb: join_lbl; next_tmp: v1.next_tmp + 1; })
                                        } else {
                                          s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: match result type not supported in v0.4"))
                                        }
                                      } else {
                                        s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: match arms must return same type in v0.4"))
                                      }
                                    };
                                  }
                                };
                              }
                            }
                          }
                        } else {
                          // First arm wildcard: just emit arm0.
                          s1_cg_emit_expr_min(s0.text, env, s0.next_tmp, bb, strs, arm0.value)
                        }
                      }
                    };
                    _ => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: match must have 2 arms in v0.4"));
                  }
                };
              }
            };
          }
        };
      }
    };
    _ => s1_cg_expr_err(s1_diag(Error, 0, 0, "codegen: expr kind not supported in v0"));
  }
};

fn s1_cg_emit_while_stmt_min(out: Text, env: List<S1CgEnvBind>, next_tmp: Int, strs: List<S1CgStrConst>, w: S1While) -> Result<S1CgBlockOut, S1Diagnostic> {
  let cond_id: Text = int_to_text(next_tmp);
  let cond_lbl: Text = text_concat("while_cond", cond_id);
  let body_id: Text = int_to_text(next_tmp + 1);
  let body_lbl: Text = text_concat("while_body", body_id);
  let end_id: Text = int_to_text(next_tmp + 2);
  let end_lbl: Text = text_concat("while_end", end_id);
  let nt0: Int = next_tmp + 3;

  let out1: Text = s1_cg_line(out, text_concat("  br label %", cond_lbl));
  let out2: Text = s1_cg_line(out1, text_concat(cond_lbl, ":"));
  let cond_r: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(out2, env, nt0, cond_lbl, strs, w.cond);
  match cond_r {
    Err(e) => s1_cg_block_err(e);
    Ok(c0) => {
      if c0.ty == "i1" {
        let br2: Text =
          text_concat(
            text_concat(text_concat("  br i1 ", c0.value), text_concat(", label %", body_lbl)),
            text_concat(", label %", end_lbl)
          );
        let out3: Text = s1_cg_line(c0.text, br2);
        let out4: Text = s1_cg_line(out3, text_concat(body_lbl, ":"));

        let body_env: List<S1CgEnvBind> = env;
        let body_r: Result<S1CgBlockOut, S1Diagnostic> =
          s1_cg_emit_stmt_list_min(out4, body_env, c0.next_tmp, body_lbl, strs, w.body.stmts);
        match body_r {
          Err(e2) => s1_cg_block_err(e2);
          Ok(b0) => {
            let ot: Text = b0.text;
            let nt: Int = b0.next_tmp;
            let env2: List<S1CgEnvBind> = b0.env;

            // Evaluate (and drop) tail expr if present.
            match w.body.result {
              None => {
                let out_back: Text = s1_cg_line(ot, text_concat("  br label %", cond_lbl));
                let out_end: Text = s1_cg_line(out_back, text_concat(end_lbl, ":"));
                s1_cg_block_ok(S1CgBlockOut { text: out_end; env: env; bb: end_lbl; next_tmp: nt; })
              };
              Some(expr) => {
                let rr: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(ot, env2, nt, b0.bb, strs, expr);
                match rr {
                  Err(e3) => s1_cg_block_err(e3);
                  Ok(r0) => {
                    let out_back: Text = s1_cg_line(r0.text, text_concat("  br label %", cond_lbl));
                    let out_end: Text = s1_cg_line(out_back, text_concat(end_lbl, ":"));
                    s1_cg_block_ok(S1CgBlockOut { text: out_end; env: env; bb: end_lbl; next_tmp: r0.next_tmp; })
                  };
                }
              };
            }
          };
        }
      } else {
        s1_cg_block_err(s1_diag(Error, 0, 0, "codegen: while condition must be Bool (i1)"))
      }
    };
  }
};

fn s1_cg_emit_stmt_list_min(out: Text, env: List<S1CgEnvBind>, next_tmp: Int, bb: Text, strs: List<S1CgStrConst>, stmts: List<S1Stmt>) -> Result<S1CgBlockOut, S1Diagnostic> {
  let ot: Text = out;
  let envt: List<S1CgEnvBind> = env;
  let bbt: Text = bb;
  let nt: Int = next_tmp;
  let ok: Bool = true;
  let diag: S1Diagnostic = s1_diag(Error, 0, 0, "codegen: stmt list failed");

  let cur: List<S1Stmt> = stmts;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        if ok == false {
          done = true;
          0
        } else {
          match c0.head {
            Let(l0) => {
              let rr: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(ot, envt, nt, bbt, strs, l0.value);
              match rr {
                Err(e) => { ok = false; diag = e; done = true; 0 };
                Ok(r) => {
                  // v0 subset: Int/Bool/Text locals.
                  // v0.4: allow Option<Int> and Result<_, _> pointers (enum layout { i8 tag, i64 payload }).
                  let expected: Text = "i64";
                  if s1_cg_type_is_plain_int(l0.ty) == true {
                    expected = "i64";
                    0
                  } else {
                    if s1_cg_type_is_plain_bool(l0.ty) == true {
                      expected = "i1";
                      0
                    } else {
                      if s1_cg_type_is_plain_text(l0.ty) == true {
                        expected = "i8*";
                        0
                      } else {
                        if s1_cg_type_is_option_int(l0.ty) == true {
                          expected = "%Option*";
                          0
                        } else {
                          if s1_cg_type_is_result(l0.ty) == true {
                            expected = "%Result*";
                            0
                          } else {
                            ok = false;
                            diag = s1_diag(Error, 0, 0, "codegen: let type not supported in v0 subset");
                            done = true;
                            0
                          }
                        }
                      }
                    }
                  };

                  if ok == true {
                    if r.ty == expected {
                      let slot_id: Text = int_to_text(r.next_tmp);
                      let slot: Text = text_concat("%t", slot_id);
                      let alloca_inst: Text = text_concat(text_concat(text_concat("  ", slot), " = alloca "), expected);
                      let out1: Text = s1_cg_line(r.text, alloca_inst);
                      let store_head: Text = text_concat(text_concat("  store ", expected), text_concat(" ", r.value));
                      let store_tail: Text = text_concat(text_concat(", ", expected), text_concat("* ", slot));
                      let out2: Text = s1_cg_line(out1, text_concat(store_head, store_tail));

                      let bind: S1CgEnvBind = S1CgEnvBind { name: l0.name; llvm: slot; ty: expected; s1_ty: l0.ty; };
                      envt = Cons(ListCons<S1CgEnvBind> { head: bind; tail: envt; });
                      ot = out2;
                      bbt = r.bb;
                      nt = r.next_tmp + 1;
                      cur = c0.tail;
                      0
                    } else {
                      ok = false;
                      diag = s1_diag(Error, 0, 0, "codegen: let value type mismatch in v0");
                      done = true;
                      0
                    }
                  } else { 0 };
                  0
                };
              }
            };
            Assign(a0) => {
              match s1_cg_lookup_env(envt, a0.name) {
                None => {
                  ok = false;
                  diag = s1_diag(Error, 0, 0, text_concat("codegen: assignment to unknown variable ", a0.name));
                  done = true;
                  0
                };
                Some(v) => {
                  let rr: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(ot, envt, nt, bbt, strs, a0.value);
                  match rr {
                    Err(e) => { ok = false; diag = e; done = true; 0 };
                    Ok(r) => {
                      if r.ty == v.ty {
                        let store_head: Text = text_concat(text_concat("  store ", v.ty), text_concat(" ", r.value));
                        let store_tail: Text = text_concat(text_concat(", ", v.ty), text_concat("* ", v.llvm));
                        ot = s1_cg_line(r.text, text_concat(store_head, store_tail));
                        bbt = r.bb;
                        nt = r.next_tmp;
                        cur = c0.tail;
                        0
                      } else {
                        ok = false;
                        diag = s1_diag(Error, 0, 0, "codegen: assignment type mismatch in v0");
                        done = true;
                        0
                      }
                    };
                  }
                };
              }
            };
            While(w0) => {
              let wr: Result<S1CgBlockOut, S1Diagnostic> = s1_cg_emit_while_stmt_min(ot, envt, nt, strs, w0);
              match wr {
                Err(e) => { ok = false; diag = e; done = true; 0 };
                Ok(b) => {
                  ot = b.text;
                  bbt = b.bb;
                  nt = b.next_tmp;
                  cur = c0.tail;
                  0
                };
              }
            };
            ExprStmt(e0) => {
              let rr: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(ot, envt, nt, bbt, strs, e0);
              match rr {
                Err(e) => { ok = false; diag = e; done = true; 0 };
                Ok(r) => {
                  ot = r.text;
                  bbt = r.bb;
                  nt = r.next_tmp;
                  cur = c0.tail;
                  0
                };
              }
            };
            Return(_r0) => {
              ok = false;
              diag = s1_diag(Error, 0, 0, "codegen: return statement not supported in v0 subset");
              done = true;
              0
            };
          };
          0
        };
        0
      };
    }
  };

  if ok == false {
    s1_cg_block_err(diag)
  } else {
    s1_cg_block_ok(S1CgBlockOut { text: ot; env: envt; bb: bbt; next_tmp: nt; })
  }
};

fn s1_cg_emit_function_min(out: Text, strs: List<S1CgStrConst>, f: S1Function) -> Result<Text, S1Diagnostic> {
  // Caller must ensure `s1_cg_function_supported(f) == true`.
  let params_str: Text = "";
  let curp: List<S1Param> = f.params;
  let donep: Bool = false;
  let ps: Text = params_str;
  let first: Bool = true;
  while donep == false {
    match curp {
      Nil => { donep = true; 0 };
      Cons(c0) => {
        let seg: Text = text_concat("i64 %", c0.head.name);
        if first == true {
          ps = seg;
          first = false;
          0
        } else {
          ps = text_concat(text_concat(ps, ", "), seg);
          0
        };
        curp = c0.tail;
        0
      };
    }
  };

  match f.body {
    None => s1_cg_text_ok(out);
    Some(body) => {
      let out1: Text = s1_cg_line(out, text_concat(text_concat("define i64 @", f.name), text_concat("(", text_concat(ps, ") {"))));
      let out2: Text = s1_cg_line(out1, "entry:");

      // Parameters become stack slots so assignment works without SSA/phi complexity.
      let env: List<S1CgEnvBind> = Nil;
      let ot: Text = out2;
      let nt: Int = 0;
      let pcur: List<S1Param> = f.params;
      let pdone: Bool = false;
      while pdone == false {
        match pcur {
          Nil => { pdone = true; 0 };
          Cons(pc0) => {
            let slot_id: Text = int_to_text(nt);
            let slot: Text = text_concat("%t", slot_id);
            let alloca_inst: Text = text_concat(text_concat(text_concat("  ", slot), " = alloca "), "i64");
            let out3: Text = s1_cg_line(ot, alloca_inst);
            let store_head: Text = text_concat("  store i64 %", pc0.head.name);
            let store_tail: Text = text_concat(", i64* ", slot);
            let out4: Text = s1_cg_line(out3, text_concat(store_head, store_tail));

            let bind: S1CgEnvBind = S1CgEnvBind { name: pc0.head.name; llvm: slot; ty: "i64"; s1_ty: pc0.head.ty; };
            env = Cons(ListCons<S1CgEnvBind> { head: bind; tail: env; });
            ot = out4;
            nt = nt + 1;
            pcur = pc0.tail;
            0
          };
        }
      };

      let stmts_r: Result<S1CgBlockOut, S1Diagnostic> = s1_cg_emit_stmt_list_min(ot, env, nt, "entry", strs, body.stmts);
      match stmts_r {
        Err(e) => s1_cg_text_err(e);
        Ok(s0) => {
          match body.result {
            None => s1_cg_text_err(s1_diag(Error, 0, 0, "codegen: function body has no result"));
            Some(expr) => {
              let rr: Result<S1CgExprOut, S1Diagnostic> = s1_cg_emit_expr_min(s0.text, s0.env, s0.next_tmp, s0.bb, strs, expr);
              match rr {
                Err(e2) => s1_cg_text_err(e2);
                Ok(r0) => {
                  if r0.ty == "i64" {
                    let out3: Text = s1_cg_line(r0.text, text_concat("  ret i64 ", r0.value));
                    let out4: Text = s1_cg_line(out3, "}");
                    let out5: Text = s1_cg_line(out4, "");
                    s1_cg_text_ok(out5)
                  } else {
                    s1_cg_text_err(s1_diag(Error, 0, 0, "codegen: function result must be Int in v0"))
                  }
                };
              }
            };
          }
        };
      }
    };
  }
};

fn s1_cg_text_list_contains(xs: List<Text>, value: Text) -> Bool {
  let ok: Bool = false;
  let cur: List<Text> = xs;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        if c0.head == value { ok = true; done = true; 0 } else { cur = c0.tail; 0 };
        0
      };
    }
  };
  ok
};

fn s1_cg_add_str_lit(acc: List<Text>, lit: Text) -> List<Text> {
  if s1_cg_text_list_contains(acc, lit) == true {
    acc
  } else {
    let out: List<Text> = Cons(ListCons<Text> { head: lit; tail: acc; });
    out
  }
};

fn s1_cg_reverse_text_list(xs: List<Text>) -> List<Text> {
  let out: List<Text> = Nil;
  let cur: List<Text> = xs;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        out = Cons(ListCons<Text> { head: c0.head; tail: out; });
        cur = c0.tail;
        0
      };
    }
  };
  out
};

fn s1_cg_reverse_str_const_list(xs: List<S1CgStrConst>) -> List<S1CgStrConst> {
  let out: List<S1CgStrConst> = Nil;
  let cur: List<S1CgStrConst> = xs;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        out = Cons(ListCons<S1CgStrConst> { head: c0.head; tail: out; });
        cur = c0.tail;
        0
      };
    }
  };
  out
};

fn s1_cg_collect_strs_expr(acc: List<Text>, e: S1Expr) -> List<Text> {
  match e {
    IntLit(_n) => acc;
    BoolLit(_b) => acc;
    Path(_p) => acc;
    StringLit(s) => s1_cg_add_str_lit(acc, s);
    Member(m) => s1_cg_collect_strs_expr(acc, m.base);
    Binary(b) => {
      let a1: List<Text> = s1_cg_collect_strs_expr(acc, b.left);
      s1_cg_collect_strs_expr(a1, b.right)
    };
    Call(c) => {
      let a1: List<Text> = s1_cg_collect_strs_expr(acc, c.callee);
      let cur: List<S1Expr> = c.args;
      let out: List<Text> = a1;
      let done: Bool = false;
      while done == false {
        match cur {
          Nil => { done = true; 0 };
          Cons(c0) => { out = s1_cg_collect_strs_expr(out, c0.head); cur = c0.tail; 0 };
        }
      };
      out
    };
    Block(b) => s1_cg_collect_strs_block(acc, b);
    If(i) => {
      let a1: List<Text> = s1_cg_collect_strs_expr(acc, i.cond);
      let a2: List<Text> = s1_cg_collect_strs_block(a1, i.then_block);
      match i.else_block {
        None => a2;
        Some(eb) => s1_cg_collect_strs_block(a2, eb);
      }
    };
    Match(m) => {
      let a1: List<Text> = s1_cg_collect_strs_expr(acc, m.scrutinee);
      let cur: List<S1MatchArm> = m.arms;
      let out: List<Text> = a1;
      let done: Bool = false;
      while done == false {
        match cur {
          Nil => { done = true; 0 };
          Cons(c0) => { out = s1_cg_collect_strs_expr(out, c0.head.value); cur = c0.tail; 0 };
        }
      };
      out
    };
    RecordLit(r) => {
      let cur: List<S1RecordLitField> = r.fields;
      let out: List<Text> = acc;
      let done: Bool = false;
      while done == false {
        match cur {
          Nil => { done = true; 0 };
          Cons(c0) => { out = s1_cg_collect_strs_expr(out, c0.head.value); cur = c0.tail; 0 };
        }
      };
      out
    };
  }
};

fn s1_cg_collect_strs_block(acc: List<Text>, b: S1Block) -> List<Text> {
  let out: List<Text> = acc;
  let cur: List<S1Stmt> = b.stmts;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        match c0.head {
          Let(l) => { out = s1_cg_collect_strs_expr(out, l.value); 0 };
          Assign(a) => { out = s1_cg_collect_strs_expr(out, a.value); 0 };
          Return(r) => { out = s1_cg_collect_strs_expr(out, r.value); 0 };
          ExprStmt(e) => { out = s1_cg_collect_strs_expr(out, e); 0 };
          While(w) => {
            out = s1_cg_collect_strs_expr(out, w.cond);
            out = s1_cg_collect_strs_block(out, w.body);
            0
          };
        };
        cur = c0.tail;
        0
      };
    }
  };
  match b.result {
    None => out;
    Some(e2) => s1_cg_collect_strs_expr(out, e2);
  }
};

fn s1_cg_collect_strs_program(p: S1Program) -> List<Text> {
  let acc: List<Text> = Nil;
  let cur: List<S1Item> = p.items;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        match c0.head {
          Function(f) => {
            match f.body {
              None => 0;
              Some(b) => { acc = s1_cg_collect_strs_block(acc, b); 0 };
            };
            0
          };
          _ => 0;
        };
        cur = c0.tail;
        0
      };
    }
  };
  s1_cg_reverse_text_list(acc)
};

fn s1_cg_build_str_table(lits: List<Text>) -> List<S1CgStrConst> {
  let acc: List<S1CgStrConst> = Nil;
  let next_id: Int = 0;
  let cur: List<Text> = lits;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        let global: Text = text_concat("@.str.", int_to_text(next_id));
        let n: Int = text_len(c0.head) + 1;
        let sc: S1CgStrConst = S1CgStrConst { lit: c0.head; global: global; n: n; };
        acc = Cons(ListCons<S1CgStrConst> { head: sc; tail: acc; });
        next_id = next_id + 1;
        cur = c0.tail;
        0
      };
    }
  };
  s1_cg_reverse_str_const_list(acc)
};

fn s1_cg_llvm_i8_array_init(s: Text) -> Text {
  // Emit a numeric i8 array initializer to avoid relying on LLVM c"..." escaping.
  // Example: [i8 52, i8 50, i8 0]
  let pieces: Text = "";
  let out: Text = pieces;
  let first: Bool = true;

  let i: Int = 0;
  let n: Int = text_len(s);
  let done: Bool = false;
  while done == false {
    if i == n {
      done = true;
      0
    } else {
      match text_byte_at(s, i) {
        None => 0;
        Some(b) => {
          let piece: Text = text_concat("i8 ", int_to_text(b));
          if first == true {
            out = piece;
            first = false;
            0
          } else {
            out = text_concat(text_concat(out, ", "), piece);
            0
          };
          0
        };
      };
      i = i + 1;
      0
    };
  };

  // NUL terminator.
  if first == true {
    out = "i8 0";
    0
  } else {
    out = text_concat(out, ", i8 0");
    0
  };

  text_concat("[", text_concat(out, "]"))
};

fn s1_cg_llvm_escape_text_bytes(s: Text) -> Text {
  let out: Text = "";
  let i: Int = 0;
  let n: Int = text_len(s);
  let done: Bool = false;
  while done == false {
    if i == n {
      done = true;
      0
    } else {
      match text_byte_at(s, i) {
        None => 0;
        Some(b) => {
          if b == 10 { out = text_concat(out, "\\0A"); 0 } else { 0 };
          if b == 13 { out = text_concat(out, "\\0D"); 0 } else { 0 };
          if b == 9 { out = text_concat(out, "\\09"); 0 } else { 0 };
          if b == 34 { out = text_concat(out, "\\22"); 0 } else { 0 }; // "
          if b == 92 { out = text_concat(out, "\\5C"); 0 } else { 0 }; // \
          if b == 0 { out = text_concat(out, "\\00"); 0 } else { 0 };

          let special: Bool = false;
          if b == 10 { special = true; 0 } else { 0 };
          if b == 13 { special = true; 0 } else { 0 };
          if b == 9 { special = true; 0 } else { 0 };
          if b == 34 { special = true; 0 } else { 0 };
          if b == 92 { special = true; 0 } else { 0 };
          if b == 0 { special = true; 0 } else { 0 };

          if special == false {
            match text_slice(s, i, i + 1) {
              None => { out = text_concat(out, "?"); 0 };
              Some(ch) => { out = text_concat(out, ch); 0 };
            }
          } else { 0 };
          0
        };
      };
      i = i + 1;
      0
    };
  };
  out
};

fn s1_cg_emit_prelude(strs: List<S1CgStrConst>) -> Text {
  let out: Text = "";
  let ot: Text = out;

  ot = s1_cg_line(ot, "; ModuleID = 'kooix_stage1_v0'");
  ot = s1_cg_line(ot, "source_filename = \"kooix\"");
  ot = s1_cg_line(ot, "");

  // Enum layout (Stage0 compatible): heap pointer to `{ i8 tag, i64 payload_word }`.
  ot = s1_cg_line(ot, "%Option = type { i8, i64 }");
  ot = s1_cg_line(ot, "%Result = type { i8, i64 }");
  ot = s1_cg_line(ot, "");

  // Minimal runtime + libc intrinsics used by Stage0 native backend.
  ot = s1_cg_line(ot, "declare i8* @malloc(i64)");
  ot = s1_cg_line(ot, "declare i64 @strlen(i8*)");
  ot = s1_cg_line(ot, "declare i32 @memcmp(i8*, i8*, i64)");
  ot = s1_cg_line(ot, "declare i8* @memcpy(i8*, i8*, i64)");
  ot = s1_cg_line(ot, "declare i32 @strcmp(i8*, i8*)");
  ot = s1_cg_line(ot, "");

  // Native host intrinsics (provided by crates/kooixc/native_runtime/runtime.c).
  ot = s1_cg_line(ot, "declare i8* @kx_host_load_source_map(i8*)");
  ot = s1_cg_line(ot, "declare void @kx_host_eprintln(i8*)");
  ot = s1_cg_line(ot, "declare i8* @kx_host_write_file(i8*, i8*)");
  ot = s1_cg_line(ot, "declare i8* @kx_text_concat(i8*, i8*)");
  ot = s1_cg_line(ot, "declare i8* @kx_int_to_text(i64)");
  ot = s1_cg_line(ot, "");

  // String constants used by StringLit.
  let cur: List<S1CgStrConst> = strs;
  let done: Bool = false;
  while done == false {
    match cur {
      Nil => { done = true; 0 };
      Cons(c0) => {
        let init: Text = s1_cg_llvm_i8_array_init(c0.head.lit);
        let n_txt: Text = int_to_text(c0.head.n);
        let head: Text = text_concat(text_concat(text_concat(text_concat(c0.head.global, " = private unnamed_addr constant ["), n_txt), " x i8] "), init);
        let line: Text = text_concat(head, ", align 1");
        ot = s1_cg_line(ot, line);
        cur = c0.tail;
        0
      };
    }
  };

  match strs {
    Nil => ot;
    _ => s1_cg_line(ot, "");
  }
};

fn s1_emit_llvm_ir_real(source: Text) -> Result<Text, S1Diagnostic>
intent "Stage1 LLVM IR emitter (v0 real): parse+check then emit minimal LLVM for Int-only functions"
evidence {
  trace "stage1.emit_llvm_real.v0";
  metrics [stage1_emit_llvm_real_calls];
}
{
  let tokens: Result<List<S1Token>, S1Diagnostic> = s1_lex(source);
  match tokens {
    Err(e) => s1_cg_text_err(e);
    Ok(ts) => {
      let ast_r: Result<S1Program, S1Diagnostic> = s1_parse(ts);
      match ast_r {
        Err(e2) => s1_cg_text_err(e2);
        Ok(p) => {
          let res_r: Result<S1Program, S1Diagnostic> = s1_resolve_program(p);
          match res_r {
            Err(e3) => s1_cg_text_err(e3);
            Ok(p2) => {
              let tc_r: Result<S1Program, S1Diagnostic> = s1_typecheck_program(p2);
              match tc_r {
                Err(e4) => s1_cg_text_err(e4);
                Ok(p3) => {
                  let lits: List<Text> = s1_cg_collect_strs_program(p3);
                  let strs: List<S1CgStrConst> = s1_cg_build_str_table(lits);
                  let out: Text = s1_cg_emit_prelude(strs);
                  let cur: List<S1Item> = p3.items;
                  let done: Bool = false;
                  let ot: Text = out;
                  let ok_cg: Bool = true;
                  let diag_cg: S1Diagnostic = s1_diag(Error, 0, 0, "codegen: failed");
                  let emitted_main: Bool = false;

                  while done == false {
                    match cur {
                      Nil => {
                        done = true;
                        0
                      };
                      Cons(c0) => {
                        match c0.head {
                          Function(f) => {
                            if s1_cg_function_supported(f) == true {
                              match s1_cg_emit_function_min(ot, strs, f) {
                                Err(e5) => {
                                  ok_cg = false;
                                  diag_cg = e5;
                                  done = true;
                                  0
                                };
                                Ok(t2) => {
                                  ot = t2;
                                  if f.name == "main" { emitted_main = true; 0 } else { 0 };
                                  0
                                };
                              };
                              0
                            } else {
                              0
                            };
                            0
                          };
                          _ => 0;
                        };
                        cur = c0.tail;
                        0
                      };
                    }
                  };

                  if ok_cg == false {
                    s1_cg_text_err(diag_cg)
                  } else {
                    if emitted_main == false {
                      s1_cg_text_err(s1_diag(Error, 0, 0, "codegen: no supported main() -> Int function found (v0 Int-only subset)"))
                    } else {
                      s1_cg_text_ok(ot)
                    }
                  }
                };
              }
            };
          }
        };
      }
    };
  }
};

fn s1_emit_llvm_ir(_source: Text) -> Result<Text, S1Diagnostic>
intent "Stage1 LLVM IR emitter (v0): parse+check then emit minimal LLVM IR subset"
evidence {
  trace "stage1.emit_llvm.v0";
  metrics [stage1_emit_llvm_calls];
}
{
  s1_emit_llvm_ir_real(_source)
};
