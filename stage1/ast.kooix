import "../stdlib/prelude";

record S1Program { items: List<S1Item>; };

record S1Type { name: Text; args: List<S1Type>; };

record S1GenericParam {
  name: Text;
  bounds: List<S1Type>;
};

enum S1Item {
  Import(S1Import);
  Function(S1Function);
  Record(S1Record);
  Enum(S1Enum);
};

record S1Import {
  path: Text;
  ns: Text;
};

record S1Function {
  name: Text;
  generics: List<S1GenericParam>;
  params: List<S1Param>;
  return_type: S1Type;
  body: Option<S1Block>;
};

record S1Param {
  name: Text;
  ty: S1Type;
};

record S1Record {
  name: Text;
  generics: List<S1GenericParam>;
  fields: List<S1RecordField>;
};

record S1RecordField {
  name: Text;
  ty: S1Type;
};

record S1Enum {
  name: Text;
  generics: List<S1GenericParam>;
  variants: List<S1EnumVariant>;
};

record S1EnumVariant {
  name: Text;
  payload_ty: Option<S1Type>;
};

record S1Block {
  stmts: List<S1Stmt>;
  result: Option<S1Expr>;
};

enum S1Stmt {
  Let(S1Let);
  Assign(S1Assign);
  Return(S1Return);
  While(S1While);
  ExprStmt(S1Expr);
};

record S1Let {
  name: Text;
  ty: S1Type;
  value: S1Expr;
};

record S1Assign {
  name: Text;
  value: S1Expr;
};

record S1Return {
  value: S1Expr;
};

record S1While {
  cond: S1Expr;
  body: S1Block;
};

enum S1Expr {
  Path(Text);
  IntLit(Text);
  StringLit(Text);
  Call(S1Call);
  Block(S1Block);
  If(S1If);
  Match(S1Match);
};

record S1Call {
  callee: Text;
  args: List<S1Expr>;
};

record S1If {
  cond: S1Expr;
  then_block: S1Block;
  else_block: Option<S1Block>;
};

enum S1Pattern {
  Wildcard;
  Path(Text);
};

record S1MatchArm {
  pat: S1Pattern;
  value: S1Expr;
};

record S1Match {
  scrutinee: S1Expr;
  arms: List<S1MatchArm>;
};
